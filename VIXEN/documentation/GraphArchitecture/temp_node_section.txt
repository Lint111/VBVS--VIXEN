
```cpp
class NodeType {
    // Type Identification
    NodeTypeId typeId;                    // Unique type identifier
    std::string typeName;                 // Type name (e.g., "ShadowMapPass")

    // Schema Definition
    std::vector<ResourceDescriptor> inputSchema;   // Expected inputs
    std::vector<ResourceDescriptor> outputSchema;  // Produced outputs

    // Requirements
    DeviceCapabilityFlags requiredCapabilities;    // GPU features needed
    PipelineType pipelineType;                     // Graphics/Compute/RayTracing

    // Instancing
    bool supportsInstancing;              // Can be instanced in pipeline
    uint32_t maxInstances;                // Max instances per graph (0 = unlimited)

    // Factory
    std::function<NodeInstance*()> CreateInstance;
};
```

**Examples of Node Types:**
- `ShadowMapPass` - Can be instanced once per light
- `GeometryPass` - Typically single instance
- `BlurPass` - Can be instanced for multi-pass effects
- `ComputeShaderPass` - Can be instanced for parallel work

#### 2.1.2 Node Instance (Graph Node)

```cpp
class NodeInstance {
    // Instance Identification
    UUID instanceId;                      // Unique instance ID
    std::string instanceName;             // Instance name (e.g., "ShadowMap_Light0")
    NodeType* nodeType;                   // Reference to type definition

    // Device Affinity
    VulkanDevice* device;                 // Device this instance executes on
    uint32_t deviceIndex;                 // Device index for multi-GPU

    // Instance-Specific Data
    std::vector<Resource> inputs;         // Actual input resources for this instance
    std::vector<Resource> outputs;        // Actual output resources for this instance
    std::map<std::string, Variant> parameters;  // Instance-specific parameters

    // Execution State
    NodeState state;                      // Ready, Compiled, Executing, Complete
    std::vector<NodeInstance*> dependencies;

    // Pipeline Resources (shared across instances of same type)
    VkPipeline pipeline;                  // May be shared with other instances
    VkPipelineLayout pipelineLayout;      // Shared layout

    // Instance-Specific Resources
    VkDescriptorSet descriptorSet;        // Unique per instance
    std::vector<VkCommandBuffer> commandBuffers;  // Per-instance commands

    // Caching
    uint64_t cacheKey;                    // Hash for this instance's output
    bool cacheable;                       // Whether output can be cached
};
```

#### 2.1.3 Pipeline Instancing During Compilation

During graph compilation, the system analyzes instances of the same type to optimize pipeline creation:

```cpp
struct PipelineInstanceGroup {
    NodeType* nodeType;                           // The type being instanced
    std::vector<NodeInstance*> instances;         // All instances of this type
    VkPipeline sharedPipeline;                    // Shared pipeline (if compatible)
    std::map<uint64_t, VkPipeline> variantPipelines;  // Variants for different configs
};

class GraphCompiler {
    void CompilePipelines() {
        // Group instances by type
        std::map<NodeTypeId, PipelineInstanceGroup> instanceGroups;

        for (auto& instance : allInstances) {
            instanceGroups[instance->nodeType->typeId].instances.push_back(instance);
        }

        // For each type, determine if instances can share a pipeline
        for (auto& [typeId, group] : instanceGroups) {
            if (CanSharePipeline(group.instances)) {
                // Create single pipeline for all instances
                group.sharedPipeline = CreatePipeline(group.instances[0]);

                // All instances use the same pipeline
                for (auto* instance : group.instances) {
                    instance->pipeline = group.sharedPipeline;
                }
            } else {
                // Create variants based on instance differences
                for (auto* instance : group.instances) {
                    uint64_t variantKey = GenerateVariantKey(instance);
                    if (!group.variantPipelines.contains(variantKey)) {
                        group.variantPipelines[variantKey] = CreatePipeline(instance);
                    }
                    instance->pipeline = group.variantPipelines[variantKey];
                }
            }
        }
    }

    bool CanSharePipeline(const std::vector<NodeInstance*>& instances) {
        // Check if all instances have compatible state
        // - Same shader variants
        // - Same render pass format
        // - Same vertex input layout
        // - Same dynamic state requirements
        return AllInstancesHaveCompatibleState(instances);
    }
};
```

**Example:** 10 shadow map instances:
- **Scenario A (Identical)**: All shadows use same resolution, format → 1 shared pipeline
- **Scenario B (Variants)**: 8 use 1024x1024, 2 use 2048x2048 → 2 pipeline variants
- **Scenario C (All Different)**: Each uses different config → 10 separate pipelines

#### 2.1.4 Node Type Categories

**Process Node Types:**
- Geometry rendering
- Post-processing effects
- Compute operations
- Texture generation

**Resource Node Types:**
- Image/Texture resources
- Buffer resources
- Constant values
- Render targets

**Device Communication Node Types:**
- Cross-device transfer
- Device synchronization
- Multi-GPU composition

### 2.2 Resource Types

#### 2.2.1 Resource Classification

```cpp
enum class ResourceType {
    Variable,    // Constant input (uniforms, push constants)
    Product,     // Output from another node
    Transient,   // Temporary resource within frame
    Persistent   // Lives across multiple frames
};

struct Resource {
    std::string name;
    ResourceType type;

    union {
        // Variable (constant)
        struct {
            void* data;
            size_t size;
        } constant;

        // Product (from node)
        struct {
            RenderGraphNode* sourceNode;
            uint32_t outputIndex;
        } product;

        // Vulkan resource handles
        struct {
            VkImage image;
            VkBuffer buffer;
            VkDeviceMemory memory;
            VkImageView imageView;
        } vulkan;
    };
};
```

### 2.3 Node Type Registration & Instancing

#### 2.3.1 Node Type Registry

```cpp
class NodeTypeRegistry {
public:
    // Register a new node type
    void RegisterNodeType(std::unique_ptr<NodeType> nodeType);

    // Query registered types
    NodeType* GetNodeType(NodeTypeId typeId);
    NodeType* GetNodeType(const std::string& typeName);

    // Get all registered types
    const std::vector<NodeType*>& GetAllTypes() const;

private:
    std::map<NodeTypeId, std::unique_ptr<NodeType>> typeRegistry;
    std::map<std::string, NodeTypeId> nameToIdMap;
};

// Example registration
void RegisterBuiltInNodeTypes(NodeTypeRegistry& registry) {
    // Shadow Map Type
    auto shadowMapType = std::make_unique<NodeType>();
    shadowMapType->typeId = NodeTypeId::ShadowMap;
    shadowMapType->typeName = "ShadowMapPass";
    shadowMapType->supportsInstancing = true;
    shadowMapType->maxInstances = 0;  // Unlimited
    shadowMapType->inputSchema = {
        {"geometry", ResourceType::GeometryBuffer},
        {"lightTransform", ResourceType::Matrix4x4}
    };
    shadowMapType->outputSchema = {
        {"depthMap", ResourceType::Texture2D}
    };
    registry.RegisterNodeType(std::move(shadowMapType));

    // Geometry Pass Type (single instance)
    auto geometryType = std::make_unique<NodeType>();
    geometryType->typeId = NodeTypeId::GeometryPass;
    geometryType->typeName = "GeometryPass";
    geometryType->supportsInstancing = false;
    geometryType->maxInstances = 1;
    // ... configure schema
    registry.RegisterNodeType(std::move(geometryType));
}
```

#### 2.3.2 Creating Node Instances

```cpp
class RenderGraph {
public:
    // Create instance from type name
    NodeHandle AddNode(const std::string& typeName, const std::string& instanceName);

    // Create instance from type ID
    NodeHandle AddNode(NodeTypeId typeId, const std::string& instanceName);

    // Create instance with explicit device
    NodeHandle AddNode(NodeTypeId typeId, const std::string& instanceName,
                      VulkanDevice* device);

    // Get instance count for a type
    uint32_t GetInstanceCount(NodeTypeId typeId) const;

    // Get all instances of a type
    std::vector<NodeInstance*> GetInstancesOfType(NodeTypeId typeId);

private:
    NodeTypeRegistry* typeRegistry;
    std::map<NodeTypeId, std::vector<NodeInstance*>> instancesByType;
};
```

**Example Usage:**
```cpp
RenderGraph graph(device, &registry);

// Create multiple shadow map instances
for (int i = 0; i < numLights; i++) {
    std::string instanceName = "ShadowMap_" + std::to_string(i);
    auto shadowMap = graph.AddNode(NodeTypeId::ShadowMap, instanceName);
    // Each instance is unique, but shares the ShadowMapPass type
}

// Later, during compilation:
uint32_t shadowMapCount = graph.GetInstanceCount(NodeTypeId::ShadowMap);
// shadowMapCount = numLights

// Compiler can optimize: "I have 10 instances of ShadowMap type,
// can they share a pipeline?"
```

**Use Cases:**
- Multiple shadow maps (one per light source) - **Same Type, Multiple Instances**
- Multiple blur passes with different radii - **Same Type, Different Parameters → Variants**
- Instanced geometry rendering with different transforms - **Same Type, Different Uniforms**

#### 2.3.3 Type-Instance Relationship

```
┌─────────────────────────────────────────────────────────────┐
│              Node Type Registry                              │
│  ┌──────────────────┐  ┌──────────────────┐                │
│  │ ShadowMapPass    │  │ GeometryPass     │  ...           │
│  │ - typeId         │  │ - typeId         │                │
│  │ - inputSchema    │  │ - inputSchema    │                │
│  │ - outputSchema   │  │ - outputSchema   │                │
│  │ - instancing: ✓  │  │ - instancing: ✗  │                │
│  └──────────────────┘  └──────────────────┘                │
└────────┬─────────────────────┬──────────────────────────────┘
         │                     │
         │ instantiate         │ instantiate (once)
         ▼                     ▼
┌─────────────────────────────────────────────────────────────┐
│                  Render Graph Instances                      │
│                                                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ ShadowMap_0 │  │ ShadowMap_1 │  │ ShadowMap_2 │ ...     │
│  │ instanceId  │  │ instanceId  │  │ instanceId  │         │
│  │ type: ─────────┼─── type: ───┼──── type: ShadowMapPass  │
│  │ device: gpu0│  │ device: gpu1│  │ device: gpu2│         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│                                                               │
│  ┌─────────────┐                                            │
│  │ MainScene   │                                            │
│  │ instanceId  │                                            │
│  │ type: GeometryPass                                      │
│  │ device: gpu0│                                            │
│  └─────────────┘                                            │
└─────────────────────────────────────────────────────────────┘
         │
         │ compilation
         ▼
┌─────────────────────────────────────────────────────────────┐
│           Pipeline Instance Grouping                         │
│                                                               │
│  ShadowMapPass:                                              │
│    sharedPipeline: VkPipeline (used by all 3 instances)     │
│    instances: [ShadowMap_0, ShadowMap_1, ShadowMap_2]       │
│                                                               │
│  GeometryPass:                                               │
│    sharedPipeline: VkPipeline (used by MainScene)           │
│    instances: [MainScene]                                    │
└─────────────────────────────────────────────────────────────┘
```

**Key Points:**
1. **NodeType** = Template/Definition (1 per process type)
2. **NodeInstance** = Concrete usage (N per graph, based on scene requirements)
3. **Pipeline Sharing** = Determined at compile time based on instance compatibility
4. **Each instance** has unique descriptor sets, command buffers, and parameters
5. **Instances can share** pipelines, pipeline layouts, and shader modules

---

## 3. Graph Compilation & Execution

### 3.1 Graph Construction

```cpp
class RenderGraph {
