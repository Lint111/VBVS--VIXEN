# CashSystem Integration Documentation

## Overview

The CashSystem is a comprehensive caching framework designed to optimize resource creation and management within the RenderGraph system and ShaderManagement library. It provides automatic caching for expensive-to-create Vulkan resources such as shader modules, textures, descriptor sets, and graphics pipelines.

## Architecture

### Core Components

1. **MainCacher** - Singleton registry that manages all specialized cachers
2. **TypedCacher<T, CI>** - Template base for type-safe caching
3. **Specialized Cachers**:
   - `ShaderModuleCacher` - Caches compiled shader modules
   - `TextureCacher` - Caches loaded textures
   - `DescriptorCacher` - Caches descriptor set layouts and pools
   - `PipelineCacher` - Caches graphics pipeline state

### Resource Wrappers

Each cacher manages a wrapper type that contains:
- Vulkan handles (VkImage, VkPipeline, etc.)
- Cache identification data (hashes, paths, parameters)
- Creation metadata for cache key generation

## Key Features

### 1. Type-Safe Caching
- Template-based `TypedCacher` ensures compile-time type safety
- Automatic cache key generation from creation parameters
- Zero-overhead abstraction layer

### 2. Thread-Safe Operations
- `std::shared_mutex` for concurrent read access
- Lock-free fast path for cache hits
- Promise-based async creation for expensive operations

### 3. Cache Key Generation
- Deterministic hash generation from resource parameters
- File content checksum integration
- Parameter combination analysis

### 4. Integration Points

#### RenderGraph Nodes
- **GraphicsPipelineNode**: Pipeline caching based on shader keys and configuration
- **ShaderLibraryNode**: Shader module caching from source files
- **TextureLoaderNode**: Texture caching with format and filter parameters
- **DescriptorSetNode**: Descriptor layout caching for repeated layouts

#### ShaderManagement Library
- **ShaderLibrary**: Shader module compilation and caching
- **DescriptorLayoutSpec**: Layout specification caching

## Usage Patterns

### Basic Usage

```cpp
#include "CashSystem/MainCacher.h"

// Initialize cache system
auto& mainCacher = CashSystem::MainCacher::Instance();
mainCacher->Initialize(device);

// Get cached shader module
auto shaderModule = mainCacher->GetShaderModuleCacher()->GetOrCreateShaderModule(
    "vertex.vert",           // source path
    "main",                  // entry point
    {},                      // macro definitions
    VK_SHADER_STAGE_VERTEX_BIT,
    "MyVertexShader"
);

// Get cached texture
auto texture = mainCacher->GetTextureCacher()->GetOrCreateTexture(
    "texture.png",           // file path
    VK_FORMAT_R8G8B8A8_UNORM, // format
    true,                    // generate mipmaps
    VK_FILTER_LINEAR,        // min filter
    VK_FILTER_LINEAR,        // mag filter
    VK_SAMPLER_ADDRESS_MODE_REPEAT
);
```

### RenderGraph Integration

```cpp
void GraphicsPipelineNode::Compile() {
    // Get pipeline cacher
    auto* pipelineCacher = CashSystem::MainCacher::Instance().GetPipelineCacher();
    
    // Try cache-first approach
    auto pipeline = pipelineCacher->GetOrCreatePipeline(
        vertexShaderKey,
        fragmentShaderKey,
        layoutKey,
        renderPassKey,
        enableDepthTest,
        cullMode,
        polygonMode
    );
    
    if (pipeline && pipeline->pipeline != VK_NULL_HANDLE) {
        // Use cached pipeline
        pipeline = cachedPipeline->pipeline;
        return;
    }
    
    // Fallback to manual creation if cache miss
    CreatePipelineManually();
}
```

## Cache Key Generation

### Shader Module Keys
- Source file path + content checksum
- Entry point name
- Macro definitions
- Shader stage
- Compilation options

### Texture Keys
- File path + content checksum
- Format and dimensions
- Filter modes (min/mag)
- Address modes (U/V/W)
- Mipmap generation flag

### Pipeline Keys
- Vertex/fragment shader keys
- Pipeline layout key
- Render pass compatibility
- Rasterization state (cull mode, polygon mode)
- Depth test configuration

### Descriptor Keys
- Layout specification hash
- Pool configuration
- Maximum set count

## Performance Characteristics

### Cache Hit Performance
- **O(1)** lookup time for cached resources
- **Lock-free** fast path for read access
- **No creation overhead** for cache hits

### Cache Miss Performance
- **Single creation** per unique parameter combination
- **Async creation** support for expensive operations
- **Lazy initialization** - caches created on first use

### Memory Usage
- **LRU-style** natural expiration via handle invalidation
- **Shared ownership** via `std::shared_ptr`
- **Automatic cleanup** on graph recompilation

## Serialization Support

Each cacher supports:
- **SerializeToFile()** - Save cache to disk
- **DeserializeFromFile()** - Load cache from disk
- **Device fingerprinting** - Cache validation across devices
- **Version compatibility** - Schema evolution support

## Best Practices

### 1. Cache Key Design
- Include all parameters that affect resource creation
- Use content hashes for file-based resources
- Ensure deterministic key generation

### 2. Resource Lifetime
- Leverage RenderGraph's cleanup system
- Use `std::shared_ptr` for shared ownership
- Let caches handle memory management

### 3. Integration Strategy
- Cache-first approach (try cache before creation)
- Graceful fallback to manual creation
- Log cache hits/misses for optimization

### 4. Performance Monitoring
- Track cache hit rates per resource type
- Monitor memory usage of cached resources
- Profile creation time vs cache lookup time

## Testing

Comprehensive test suite includes:
- **Unit tests** for each cacher type
- **Integration tests** for RenderGraph nodes
- **Performance tests** for cache effectiveness
- **Concurrency tests** for thread safety

## Future Enhancements

### Planned Features
1. **Persistent cache** - Disk-based caching across sessions
2. **Cache warming** - Preload common resources
3. **Memory pressure** - Automatic cache eviction
4. **Distributed caching** - Multi-GPU cache sharing
5. **Compression** - Cache data size optimization

### Advanced Optimization
1. **Predictive caching** - Pre-cache likely needed resources
2. **Cache statistics** - Detailed performance metrics
3. **Adaptive strategies** - Learn usage patterns
4. **Hot reload** - Cache invalidation on file changes

## Migration Guide

### From Manual Resource Management

1. **Identify cached resources** in your node implementations
2. **Replace creation code** with cache-first approach
3. **Add cache parameters** to creation info structs
4. **Test cache effectiveness** with performance profiling

### Integration Checklist

- [ ] Initialize MainCacher in application startup
- [ ] Update CMakeLists.txt to link CashSystem
- [ ] Add cache includes to node implementations
- [ ] Replace manual creation with cache-first approach
- [ ] Add cache persistence if needed
- [ ] Implement comprehensive tests
- [ ] Monitor cache performance metrics

## Troubleshooting

### Common Issues

1. **Cache miss on valid resource**
   - Verify cache key generation parameters
   - Check for device-specific parameters
   - Ensure deterministic key generation

2. **Memory leaks from cached resources**
   - Verify cleanup integration with RenderGraph
   - Check shared_ptr reference counting
   - Monitor cache size limits

3. **Thread safety issues**
   - Use proper locking in custom cacher implementations
   - Verify thread-safe cache key generation
   - Test concurrent access patterns

### Debug Features

- **Cache logging** - Track hits/misses per resource
- **Performance metrics** - Creation time vs cache time
- **Memory profiling** - Cache size and growth patterns
- **Key visualization** - Debug cache key generation