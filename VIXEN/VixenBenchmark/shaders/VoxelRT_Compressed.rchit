#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

// ============================================================================
// VoxelRT_Compressed.rchit - Compressed Closest Hit Shader (Phase K: Hardware RT)
// ============================================================================
// Called when a ray hits the closest voxel AABB.
// Uses DXT-compressed color/normal buffers with brick mapping for lookup.
//
// COMPRESSION: Uses same DXT compression scheme as VoxelRayMarch_Compressed.comp
// - Color:  32 blocks * 8 bytes  = 256 bytes per brick
// - Normal: 32 blocks * 16 bytes = 512 bytes per brick
// - Total:  768 bytes per brick (4:1 compression vs uncompressed)
//
// BINDING LAYOUT (consistent with VoxelRT.rchit):
// - Binding 3: materialIdBuffer (same as uncompressed)
// - Binding 5: octreeConfig (UBO, same as uncompressed)
// - Binding 6: compressedColors (DXT1 color blocks) [compressed only]
// - Binding 7: compressedNormals (DXT normal blocks) [compressed only]
// - Binding 8: brickMapping (SSBO) - Maps gl_PrimitiveID to (brickIndex, localVoxelIdx)
// ============================================================================

#include "Compression.glsl"
#include "Materials.glsl"

// Hit attributes from intersection shader
hitAttributeEXT vec3 hitNormal;

// Ray payload - color output
layout(location = 0) rayPayloadInEXT vec3 hitColor;

// Material ID buffer - indexed by gl_PrimitiveID to get material
// Same binding as uncompressed shader for consistent naming
layout(std430, binding = 3) readonly buffer MaterialIdBuffer {
    uint materialIds[];  // Material IDs (512 per brick)
} materialIdBuffer;

// DXT1 compressed colors - 32 blocks per brick, 8 bytes (uvec2) per block
layout(std430, binding = 6) readonly buffer CompressedColorBuffer {
    uvec2 compressedColors[];
};

// DXT compressed normals - 32 blocks per brick, 16 bytes (uvec4) per block
layout(std430, binding = 7) readonly buffer CompressedNormalBuffer {
    uvec4 compressedNormals[];
};

// Brick mapping buffer - one entry per AABB primitive
// Maps gl_PrimitiveID to (brickIndex, localVoxelIdx) for compressed buffer access
// Generated by VoxelAABBConverterNode during AABB extraction
layout(std430, binding = 8) readonly buffer BrickMappingBuffer {
    uvec2 brickMapping[];  // .x = brickIndex, .y = localVoxelIdx (0-511)
};

// OctreeConfigUBO - matches compute shader binding 5
layout(std140, binding = 5) uniform OctreeConfigUBO {
    int esvoMaxScale;
    int userMaxLevels;
    int brickDepthLevels;
    int brickSize;
    int minESVOScale;
    int brickESVOScale;
    int bricksPerAxis;
    int _padding1;
    vec3 gridMin;
    float _padding2;
    vec3 gridMax;
    float _padding3;
    mat4 localToWorld;
    mat4 worldToLocal;
} octreeConfig;

// Push constants (same as compute shader)
layout(push_constant) uniform PushConstants {
    vec3 cameraPos;
    float time;
    vec3 cameraDir;
    float fov;
    vec3 cameraUp;
    float aspect;
    vec3 cameraRight;
    int debugMode;
} pc;

// ============================================================================
// COMPRESSED BUFFER ACCESS FUNCTIONS
// ============================================================================

uvec2 loadColorBlock(uint brickIndex, int voxelLinearIdx) {
    int blockIdx = voxelLinearIdx >> 4;
    return compressedColors[brickIndex * 32u + uint(blockIdx)];
}

void loadNormalBlocks(uint brickIndex, int voxelLinearIdx, out uvec2 blockA, out uvec2 blockB) {
    int blockIdx = voxelLinearIdx >> 4;
    uvec4 packed = compressedNormals[brickIndex * 32u + uint(blockIdx)];
    blockA = packed.xy;
    blockB = packed.zw;
}

vec3 getCompressedVoxelColor(uint brickIndex, int voxelLinearIdx) {
    uvec2 block = loadColorBlock(brickIndex, voxelLinearIdx);
    int texelIdx = voxelLinearIdx & 15;
    return decodeDXT1Color(block, texelIdx);
}

vec3 getCompressedVoxelNormal(uint brickIndex, int voxelLinearIdx) {
    uvec2 blockA, blockB;
    loadNormalBlocks(brickIndex, voxelLinearIdx, blockA, blockB);
    int texelIdx = voxelLinearIdx & 15;
    return normalize(decodeDXTNormal(blockA, blockB, texelIdx));
}

// Lighting computation - matches compute shader (Lighting.glsl)
vec3 computeLighting(vec3 baseColor, vec3 normal, vec3 rayDir) {
    // Simple directional light from upper-right (same as compute)
    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));

    // Basic diffuse lighting
    float NdotL = max(dot(normal, lightDir), 0.0);

    // Ambient term (matches compute shader)
    float ambient = 0.3;

    // Final color with lighting
    float lighting = ambient + (1.0 - ambient) * NdotL;
    return baseColor * lighting;
}

// getMaterialColor() is now provided by Materials.glsl

void main() {
    // Get ray direction (in local voxel space, matches rgen)
    vec3 rayDir = gl_WorldRayDirectionEXT;

    // Normalize the hit normal from intersection shader
    vec3 N = normalize(hitNormal);

    // Get brick mapping from buffer using primitive ID
    // This maps the AABB primitive to its brick and local voxel position
    uvec2 mapping = brickMapping[gl_PrimitiveID];
    uint brickIndex = mapping.x;
    int localVoxelIdx = int(mapping.y);

    // Get compressed color from DXT1 buffer
    vec3 baseColor = getCompressedVoxelColor(brickIndex, localVoxelIdx);

    // DEBUG: Check if DXT block is all zeros (indicates buffer not populated)
    uvec2 debugBlock = loadColorBlock(brickIndex, localVoxelIdx);
    bool blockIsZero = (debugBlock.x == 0u && debugBlock.y == 0u);

    // Get compressed normal from DXT buffer (use if hitNormal is unreliable)
    // For now, use intersection shader's hitNormal since it's per-face accurate
    // vec3 compressedNormal = getCompressedVoxelNormal(brickIndex, localVoxelIdx);

    // Apply lighting (or show debug red if buffer is empty)
    if (blockIsZero) {
        hitColor = vec3(1.0, 0.0, 0.0);  // RED = DXT block is zeros!
    } else {
        // DEBUG: Show raw baseColor without lighting to verify DXT decode
        // hitColor = baseColor;  // Uncomment to see raw DXT colors
        hitColor = computeLighting(baseColor, N, rayDir);
    }

    // DEBUG: Always show raw DXT color for now (bypass lighting)
    hitColor = baseColor;

    // Debug modes (keys 0-9 accessible)
    // 0 = normal rendering (raw DXT color)
    // 1 = BRICK_INDEX - visualize Morton-sorted brick index
    // 2 = DEPTH - depth visualization
    // 3 = LOCAL_VOXEL_IDX - local voxel index within brick (0-511)
    // 4 = DXT_BLOCK_RAW - raw RGB565 ref0 from DXT block
    // 5 = NORMALS - surface normals
    // 6 = POSITION - fractional hit position
    // 7 = MATERIAL_COLOR - getMaterialColor(matID) lookup
    // 8 = MATERIALS - material ID visualization
    // 9 = DXT_BLOCK_NONZERO - show if block has data (green) or is zero (red)
    if (pc.debugMode > 0) {
        vec3 hitPos = gl_WorldRayOriginEXT + gl_WorldRayDirectionEXT * gl_HitTEXT;
        uint matID = materialIdBuffer.materialIds[gl_PrimitiveID];

        switch (pc.debugMode) {
            case 1:  // BRICK_INDEX - visualize brick index as RGB
                {
                    float r = float(brickIndex % 8u) / 7.0;
                    float g = float((brickIndex / 8u) % 8u) / 7.0;
                    float b = float((brickIndex / 64u) % 8u) / 7.0;
                    hitColor = vec3(r, g, b);
                }
                break;

            case 2:  // DEPTH
                {
                    float depth = gl_HitTEXT / 100.0;
                    hitColor = vec3(depth, depth * 0.5, 1.0 - depth);
                }
                break;

            case 3:  // LOCAL_VOXEL_IDX - visualize local voxel index (0-511)
                {
                    float idx = float(localVoxelIdx) / 511.0;
                    hitColor = vec3(idx, 1.0 - idx, 0.5);
                }
                break;

            case 4:  // DXT_BLOCK_RAW - show raw RGB565 ref0 color from DXT
                {
                    uvec2 block = loadColorBlock(brickIndex, localVoxelIdx);
                    uint ref0 = block.x & 0xFFFFu;
                    float r0 = float((ref0 >> 11) & 0x1Fu) / 31.0;
                    float g0 = float((ref0 >> 5) & 0x3Fu) / 63.0;
                    float b0 = float(ref0 & 0x1Fu) / 31.0;
                    hitColor = vec3(r0, g0, b0);
                }
                break;

            case 5:  // NORMALS
                hitColor = N * 0.5 + 0.5;
                break;

            case 6:  // POSITION - fractional hit position
                hitColor = fract(hitPos);
                break;

            case 7:  // MATERIAL_COLOR - use getMaterialColor() lookup
                hitColor = getMaterialColor(matID);
                break;

            case 8:  // MATERIALS - material ID as color gradient
                hitColor = vec3(float(matID) / 10.0, float(matID % 3u) / 3.0, float(matID % 5u) / 5.0);
                break;

            case 9:  // DXT_BLOCK_NONZERO - green if data, red if zero
                {
                    uvec2 block = loadColorBlock(brickIndex, localVoxelIdx);
                    bool hasData = (block.x != 0u || block.y != 0u);
                    hitColor = hasData ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
                }
                break;
        }
    }
}
