#version 460
#extension GL_GOOGLE_include_directive : require

// ============================================================================
// VoxelRayMarch_Compressed.comp - DXT Compressed Voxel Ray Marching (Refactored)
// ============================================================================
// Reads voxel color/normal from DXT-compressed brick buffers.
// Uses shared include files for ESVO traversal algorithm.
//
// Compression layout per brick (8x8x8 = 512 voxels = 32 DXT blocks):
//   Color:  32 blocks * 8 bytes  = 256 bytes (was 1536 bytes @ 3 floats/voxel)
//   Normal: 32 blocks * 16 bytes = 512 bytes (was 1536 bytes @ 3 floats/voxel)
//   Total:  768 bytes per brick (was 3072 bytes) = 4:1 compression
// ============================================================================

// Debug flags - Set to 1 to enable specific debug visualization
#define DEBUG_MATERIAL_ID 0
#define DEBUG_BRICK_INDEX 0
#define DEBUG_POS_IN_BRICK 0
#define DEBUG_VOXEL_COORD 0
#define DEBUG_COMPRESSED_RAW 0
#define DEBUG_FIRST_VOXEL 0

#include "SVOTypes.glsl"
#include "Compression.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BUFFER BINDINGS (Must be defined BEFORE includes)
// ============================================================================

layout(binding = 0) uniform writeonly image2D outputImage;

layout(std430, binding = 1) readonly buffer ESVOBuffer {
    uvec2 esvoNodes[];
};

layout(std430, binding = 2) readonly buffer BrickBuffer {
    uint brickData[];
};

// DXT1 compressed colors - 32 blocks per brick, 8 bytes (uvec2) per block
layout(std430, binding = 6) readonly buffer CompressedColorBuffer {
    uvec2 compressedColors[];
};

// DXT compressed normals - 32 blocks per brick, 16 bytes (uvec4) per block
layout(std430, binding = 7) readonly buffer CompressedNormalBuffer {
    uvec4 compressedNormals[];
};

layout(std430, binding = 4) buffer RayTraceBuffer {
    uint traceWriteIndex;
    uint traceCapacity;
    uint _padding[2];
    uint traceData[];
};

layout(std140, binding = 5) uniform OctreeConfigUBO {
    int esvoMaxScale;
    int userMaxLevels;
    int brickDepthLevels;
    int brickSize;
    int minESVOScale;
    int brickESVOScale;
    int bricksPerAxis;
    int _padding1;
    vec3 gridMin;
    float _padding2;
    vec3 gridMax;
    float _padding3;
    mat4 localToWorld;
    mat4 worldToLocal;
    float _padding4[16];
} octreeConfig;

// ============================================================================
// SHADER COUNTERS (Performance Metrics)
// ============================================================================
// Shader counter buffer for collecting ray traversal statistics.
// Enabled by default - ShaderCountersBuffer bound at binding 8 by VoxelGridNode.
// Counters are atomically incremented by each invocation and read back by CPU.
#define ENABLE_SHADER_COUNTERS
#define SHADER_COUNTERS_BINDING 8
#include "ShaderCounters.glsl"

// ============================================================================
// PUSH CONSTANTS
// ============================================================================

#define DEBUG_MODE_NORMAL 0
#define DEBUG_MODE_OCTANT 1
#define DEBUG_MODE_DEPTH 2
#define DEBUG_MODE_ITERATIONS 3
#define DEBUG_MODE_T_SPAN 4
#define DEBUG_MODE_NORMALS 5
#define DEBUG_MODE_POSITION 6
#define DEBUG_MODE_BRICKS 7
#define DEBUG_MODE_MATERIALS 8

layout(push_constant) uniform PushConstants {
    vec3 cameraPos;
    float time;
    vec3 cameraDir;
    float fov;
    vec3 cameraUp;
    float aspect;
    vec3 cameraRight;
    int debugMode;
} pc;

// ============================================================================
// SHARED INCLUDES
// ============================================================================

#include "CoordinateTransforms.glsl"
#include "RayGeneration.glsl"
#include "ESVOCoefficients.glsl"
#include "TraceRecording.glsl"
#include "ESVOTraversal.glsl"
#include "Lighting.glsl"

// ============================================================================
// ADDITIONAL DEBUG FLAGS
// ============================================================================

#define DEBUG_OCTANT_MASK 0
#define DEBUG_ISOLATE_OCTANT 0
#define DEBUG_ONLY_OCTANT 0
#define DEBUG_FORCE_OCTANT_ZERO 0
#define DEBUG_LOCAL_NORM 0
#define DEBUG_BRICK_COORD 0
#define DEBUG_RAY_BRICK_LOOKUP 0
#define DEBUG_BYPASS_ESVO 0
#define DEBUG_AXIS_PARALLEL 0

// ============================================================================
// COMPRESSED BUFFER ACCESS FUNCTIONS
// ============================================================================

uvec2 loadColorBlock(uint brickIndex, int voxelLinearIdx) {
    int blockIdx = voxelLinearIdx >> 4;
    return compressedColors[brickIndex * 32u + uint(blockIdx)];
}

void loadNormalBlocks(uint brickIndex, int voxelLinearIdx, out uvec2 blockA, out uvec2 blockB) {
    int blockIdx = voxelLinearIdx >> 4;
    uvec4 packed = compressedNormals[brickIndex * 32u + uint(blockIdx)];
    blockA = packed.xy;
    blockB = packed.zw;
}

vec3 getCompressedVoxelColor(uint brickIndex, int voxelLinearIdx) {
    uvec2 block = loadColorBlock(brickIndex, voxelLinearIdx);
    int texelIdx = voxelLinearIdx & 15;
    return decodeDXT1Color(block, texelIdx);
}

vec3 getCompressedVoxelNormal(uint brickIndex, int voxelLinearIdx) {
    uvec2 blockA, blockB;
    loadNormalBlocks(brickIndex, voxelLinearIdx, blockA, blockB);
    int texelIdx = voxelLinearIdx & 15;
    return normalize(decodeDXTNormal(blockA, blockB, texelIdx));
}

// ============================================================================
// COMPRESSED BRICK DDA
// ============================================================================

bool marchBrickFromPosCompressed(vec3 rayDir, vec3 posInBrick, uint brickIndex,
                                  out vec3 hitColor, out vec3 hitNormal, out uint axisMask) {
    int BRICK_SIZE_VAL = octreeConfig.brickSize;

    ivec3 currentVoxel = ivec3(floor(posInBrick));
    currentVoxel = clamp(currentVoxel, ivec3(0), ivec3(7));

    ivec3 step = ivec3(sign(rayDir));
    if (step.x == 0) step.x = 1;
    if (step.y == 0) step.y = 1;
    if (step.z == 0) step.z = 1;

    if ((posInBrick.x <= 0.001 && rayDir.x < 0.0) || (posInBrick.x >= float(BRICK_SIZE_VAL)-0.001 && rayDir.x > 0.0) ||
        (posInBrick.y <= 0.001 && rayDir.y < 0.0) || (posInBrick.y >= float(BRICK_SIZE_VAL)-0.001 && rayDir.y > 0.0) ||
        (posInBrick.z <= 0.001 && rayDir.z < 0.0) || (posInBrick.z >= float(BRICK_SIZE_VAL)-0.001 && rayDir.z > 0.0)) {
        return false;
    }

    vec3 deltaDist;
    deltaDist.x = abs(rayDir.x) > DIR_EPSILON ? 1.0 / abs(rayDir.x) : 1e20;
    deltaDist.y = abs(rayDir.y) > DIR_EPSILON ? 1.0 / abs(rayDir.y) : 1e20;
    deltaDist.z = abs(rayDir.z) > DIR_EPSILON ? 1.0 / abs(rayDir.z) : 1e20;

    vec3 tMax;
    const float MIN_DIST = 0.0001;
    for (int axis = 0; axis < 3; axis++) {
        if (abs(rayDir[axis]) < DIR_EPSILON) {
            tMax[axis] = 1e20;
        } else {
            float posLocal = posInBrick[axis];
            float distToNext;
            if (rayDir[axis] > 0.0) {
                distToNext = float(currentVoxel[axis] + 1) - posLocal;
            } else {
                distToNext = posLocal - float(currentVoxel[axis]);
            }
            distToNext = max(distToNext, MIN_DIST);
            tMax[axis] = distToNext / abs(rayDir[axis]);
        }
    }

    axisMask = 0u;
    const int MAX_STEPS = 64;
    for (int i = 0; i < MAX_STEPS; i++) {
        if (any(lessThan(currentVoxel, ivec3(0))) || any(greaterThanEqual(currentVoxel, ivec3(8)))) {
            break;
        }

        int voxelLinearIdx = currentVoxel.z * 64 + currentVoxel.y * 8 + currentVoxel.x;
        uint voxelData = brickData[brickIndex * 512u + uint(voxelLinearIdx)];

        if (voxelData != 0u) {
#if DEBUG_MATERIAL_ID
            uint matId = voxelData;
            if (matId == 1u) hitColor = vec3(0.9, 0.1, 0.1);
            else if (matId == 2u) hitColor = vec3(0.1, 0.9, 0.1);
            else if (matId == 3u) hitColor = vec3(0.9, 0.9, 0.9);
            else if (matId == 4u) hitColor = vec3(0.8, 0.8, 0.8);
            else if (matId == 5u) hitColor = vec3(0.85, 0.85, 0.85);
            else if (matId == 6u) hitColor = vec3(0.7, 0.7, 0.7);
            else if (matId == 7u) hitColor = vec3(0.3, 0.3, 0.3);
            else if (matId == 10u) hitColor = vec3(0.8, 0.6, 0.4);
            else if (matId == 11u) hitColor = vec3(0.4, 0.6, 0.8);
            else if (matId == 20u) hitColor = vec3(1.0, 1.0, 0.8);
            else hitColor = vec3(float(matId) / 25.0, 0.5, 1.0 - float(matId) / 25.0);
#else
            hitColor = getCompressedVoxelColor(brickIndex, voxelLinearIdx);
#endif
            hitNormal = getCompressedVoxelNormal(brickIndex, voxelLinearIdx);

            if (axisMask == 0u) {
                vec3 absRayDir = abs(rayDir);
                if (absRayDir.x > absRayDir.y && absRayDir.x > absRayDir.z) {
                    hitNormal = vec3(-sign(rayDir.x), 0.0, 0.0);
                } else if (absRayDir.y > absRayDir.z) {
                    hitNormal = vec3(0.0, -sign(rayDir.y), 0.0);
                } else {
                    hitNormal = vec3(0.0, 0.0, -sign(rayDir.z));
                }
            } else {
                vec3 ddaNormal = vec3(0.0);
                if (axisMask == 1u) ddaNormal.x = -float(step.x);
                else if (axisMask == 2u) ddaNormal.y = -float(step.y);
                else ddaNormal.z = -float(step.z);
                hitNormal = normalize(hitNormal + ddaNormal * 0.5);
            }

            return true;
        }

        if (tMax.x < tMax.y && tMax.x < tMax.z) {
            currentVoxel.x += step.x;
            tMax.x += deltaDist.x;
            axisMask = 1u;
        } else if (tMax.y < tMax.z) {
            currentVoxel.y += step.y;
            tMax.y += deltaDist.y;
            axisMask = 2u;
        } else {
            currentVoxel.z += step.z;
            tMax.z += deltaDist.z;
            axisMask = 4u;
        }
    }

    return false;
}

// ============================================================================
// LEAF HIT HANDLING - COMPRESSED VERSION
// ============================================================================

bool handleLeafHitCompressed(TraversalState state, RayCoefficients coef,
                             vec3 rayStartWorld, vec3 rayDir, float tBias,
                             uvec2 parentDescriptor, uint validMask, uint leafMask, uint parentNodeIndex,
                             inout StackEntry stack[STACK_SIZE],
                             out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    int BRICK_SIZE_VAL = octreeConfig.brickSize;

    int localChildIdx = mirroredToLocalOctant(state.idx, coef.octant_mask);
    if (localChildIdx < 0 || localChildIdx > 7) {
        return false;
    }

    uint childPointer = getChildPointer(parentDescriptor);
    uint totalInternalChildren = bitCount(validMask & ~leafMask);
    uint leafsBefore = countLeavesBefore(validMask, leafMask, localChildIdx);
    uint leafDescriptorIndex = childPointer + totalInternalChildren + leafsBefore;

    uvec2 leafDescriptor = fetchESVONode(leafDescriptorIndex);
    uint brickIndex = getBrickIndex(leafDescriptor);
    if (brickIndex == SVO_INVALID_INDEX) {
        return false;
    }

    float tHit = state.t_min;

    vec3 rayDirLocal = mat3(octreeConfig.worldToLocal) * rayDir;
    vec3 hitPos12 = coef.normOrigin + rayDirLocal * tHit;

    vec3 hitPosMirrored = hitPos12;
    if ((coef.octant_mask & 1) == 0) hitPosMirrored.x = 3.0 - hitPosMirrored.x;
    if ((coef.octant_mask & 2) == 0) hitPosMirrored.y = 3.0 - hitPosMirrored.y;
    if ((coef.octant_mask & 4) == 0) hitPosMirrored.z = 3.0 - hitPosMirrored.z;

    vec3 offsetMirrored = hitPosMirrored - state.pos;
    vec3 posInBrickMirrored = (offsetMirrored / state.scale_exp2) * float(BRICK_SIZE_VAL);

    vec3 posInBrick = posInBrickMirrored;
    if ((coef.octant_mask & 1) == 0) posInBrick.x = float(BRICK_SIZE_VAL) - posInBrick.x;
    if ((coef.octant_mask & 2) == 0) posInBrick.y = float(BRICK_SIZE_VAL) - posInBrick.y;
    if ((coef.octant_mask & 4) == 0) posInBrick.z = float(BRICK_SIZE_VAL) - posInBrick.z;

    posInBrick = clamp(posInBrick, vec3(0.0), vec3(float(BRICK_SIZE_VAL)));

    uint axisMask;
    bool ddaHit = marchBrickFromPosCompressed(rayDir, posInBrick, brickIndex,
                                               hitColor, hitNormal, axisMask);

    if (ddaHit) {
        hitT = tHit + tBias;
        return true;
    }

    return false;
}

// ============================================================================
// MAIN TRAVERSAL LOOP
// ============================================================================

bool traverseOctree(vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                    out vec3 hitColor, out vec3 hitNormal, out float hitT,
                    inout DebugRaySample debugInfo) {

    debugInfo.hitFlag = 0u;
    debugInfo.exitCode = DEBUG_EXIT_NONE;
    debugInfo.lastStepMask = 0u;
    debugInfo.iterationCount = 0u;

    vec3 rayOriginLocal = (octreeConfig.worldToLocal * vec4(rayOrigin, 1.0)).xyz;
    vec3 rayDirLocal = mat3(octreeConfig.worldToLocal) * rayDir;

    vec2 gridT = rayAABBIntersection(rayOriginLocal, rayDirLocal, vec3(0.0), vec3(1.0));
    if (gridT.y < 0.0) {
        debugInfo.exitCode = DEBUG_EXIT_INVALID_SPAN;
        debugInfo.tMin = gridT.x;
        debugInfo.tMax = gridT.y;
        return false;
    }

    bool rayStartsInside = (gridT.x < 0.0);

    vec3 rayStartWorld;
    float tEntryWorld = 0.0;
    if (rayStartsInside) {
        rayStartWorld = rayOrigin;
        tEntryWorld = 0.0;
    } else {
        vec3 entryPointLocal = rayOriginLocal + rayDirLocal * (gridT.x + EPSILON);
        rayStartWorld = (octreeConfig.localToWorld * vec4(entryPointLocal, 1.0)).xyz;
        tEntryWorld = length(rayStartWorld - rayOrigin);
    }

    RayCoefficients coef = initRayCoefficients(rayDir, rayStartWorld);
    debugInfo.octantMask = uint(coef.octant_mask);

    StackEntry stack[STACK_SIZE];
    TraversalState state = initTraversalState(coef, stack, rayStartsInside);
    snapshotTraversalState(state, coef, debugInfo);

    ivec2 pixelCoords = ivec2(debugInfo.pixel);
    bool isTracing = beginRayTrace(pixelCoords);

    if (state.t_min >= state.t_max) {
        snapshotTraversalState(state, coef, debugInfo);
        debugInfo.exitCode = DEBUG_EXIT_INVALID_SPAN;
        debugInfo.iterationCount = 0u;
        recordTraceStep(TRACE_STEP_MISS, state.parentPtr, state.scale, uint(state.idx),
                        state.pos, state.t_min, state.t_max, uvec2(0u));
        endRayTrace(false);
        return false;
    }

    int iter = 0;
    for (; iter < MAX_ITERS && state.scale <= octreeConfig.esvoMaxScale; ++iter) {

        uvec2 parent_descriptor = fetchESVONode(state.parentPtr);
        uint validMask = getValidMask(parent_descriptor);
        uint leafMask = getLeafMask(parent_descriptor);
        uint childPointer = getChildPointer(parent_descriptor);

        bool isLeaf;
        float tv_max, tx_center, ty_center, tz_center;

        if (checkChildValidity(state, coef, validMask, leafMask,
                               isLeaf, tv_max, tx_center, ty_center, tz_center)) {

            if (isLeaf) {
                recordTraceStep(TRACE_STEP_BRICK_ENTER, state.parentPtr, state.scale, uint(state.idx),
                                state.pos, state.t_min, tv_max, parent_descriptor);

                float tBias = tEntryWorld;
                if (handleLeafHitCompressed(state, coef, rayStartWorld, rayDir, tBias,
                                            parent_descriptor, validMask, leafMask, state.parentPtr,
                                            stack, hitColor, hitNormal, hitT)) {
                    recordTraceStep(TRACE_STEP_HIT, state.parentPtr, state.scale, uint(state.idx),
                                    state.pos, state.t_min, tv_max, parent_descriptor);
                    endRayTrace(true);

                    snapshotTraversalState(state, coef, debugInfo);
                    debugInfo.hitFlag = 1u;
                    debugInfo.exitCode = DEBUG_EXIT_HIT;
                    debugInfo.iterationCount = uint(iter + 1);
                    return true;
                }

                recordTraceStep(TRACE_STEP_BRICK_EXIT, state.parentPtr, state.scale, uint(state.idx),
                                state.pos, state.t_min, tv_max, parent_descriptor);

                state.t_min = tv_max;
                snapshotTraversalState(state, coef, debugInfo);
            } else {
                executePushPhase(state, coef, stack, validMask, leafMask, childPointer,
                                 tv_max, tx_center, ty_center, tz_center);

                recordTraceStep(TRACE_STEP_PUSH, state.parentPtr, state.scale, uint(state.idx),
                                state.pos, state.t_min, state.t_max, parent_descriptor);

                snapshotTraversalState(state, coef, debugInfo);
                continue;
            }
        }

        int step_mask;
        int advanceResult = executeAdvancePhase(state, coef, step_mask);

        recordTraceStep(TRACE_STEP_ADVANCE, state.parentPtr, state.scale, uint(state.idx),
                        state.pos, state.t_min, state.t_max, parent_descriptor);

        debugInfo.lastStepMask = uint(step_mask);
        snapshotTraversalState(state, coef, debugInfo);

        if (advanceResult == 0) {
             if (state.scale < octreeConfig.esvoMaxScale) {
                 state.t_max = stack[state.scale + 1].t_max;
             }
        }

        if (advanceResult == 1) {
            int popResult = executePopPhase(state, coef, stack, step_mask);

            recordTraceStep(TRACE_STEP_POP, state.parentPtr, state.scale, uint(state.idx),
                            state.pos, state.t_min, state.t_max, uvec2(0u));

            snapshotTraversalState(state, coef, debugInfo);
            if (popResult == 1) {
                recordTraceStep(TRACE_STEP_MISS, state.parentPtr, state.scale, uint(state.idx),
                                state.pos, state.t_min, state.t_max, uvec2(0u));
                endRayTrace(false);

                debugInfo.exitCode = DEBUG_EXIT_STACK;
                debugInfo.iterationCount = uint(iter + 1);
                return false;
            }
        }
    }

    recordTraceStep(TRACE_STEP_MISS, state.parentPtr, state.scale, uint(state.idx),
                    state.pos, state.t_min, state.t_max, uvec2(0u));
    endRayTrace(false);

    debugInfo.exitCode = DEBUG_EXIT_NO_HIT;
    debugInfo.iterationCount = uint(iter);
    return false;
}

// ============================================================================
// MAIN
// ============================================================================

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(imageSize);
    vec3 rayOrigin = pc.cameraPos;
    vec3 rayDir = getRayDir(uv);

    vec3 color = vec3(0.0);
    float hitT = 0.0;
    DebugRaySample debugSample;
    debugSample.pixel = uvec2(pixelCoords);
    debugSample.rayDir = rayDir;
    debugSample.octantMask = 0u;
    debugSample.hitFlag = 0u;
    debugSample.exitCode = DEBUG_EXIT_NONE;
    debugSample.lastStepMask = 0u;
    debugSample.iterationCount = 0u;
    debugSample.scale = octreeConfig.esvoMaxScale;
    debugSample.stateIdx = 0u;
    debugSample.tMin = 0.0;
    debugSample.tMax = 0.0;
    debugSample.scaleExp2 = 0.0;
    debugSample.posMirrored = vec3(0.0);
    debugSample.localNorm = vec3(0.0);

    vec3 gridMin = octreeConfig.gridMin;
    vec3 gridMax = octreeConfig.gridMax;

    vec3 rayOriginLocal = (octreeConfig.worldToLocal * vec4(rayOrigin, 1.0)).xyz;
    vec3 rayDirLocal = mat3(octreeConfig.worldToLocal) * rayDir;

    vec2 gridT = rayAABBIntersection(rayOriginLocal, rayDirLocal, vec3(0.0), vec3(1.0));

    // Record ray start for metrics
    recordRayStart();

    bool hit = false;
    if (gridT.y >= 0.0) {
        vec3 hitColor, hitNormal;

        hit = traverseOctree(rayOrigin, rayDir, vec3(0.0), vec3(1.0),
                                  hitColor, hitNormal, hitT, debugSample);

        if (hit) {
            color = computeLighting(hitColor, hitNormal, rayDir);
        } else {
            color = vec3(0.5, 0.7, 1.0) * (1.0 - uv.y * 0.5);
        }
    } else {
        color = vec3(0.5, 0.7, 1.0) * (1.0 - uv.y * 0.5);
    }

    // Record traversal metrics
    bool earlyTermination = (debugSample.iterationCount >= 500u);
    recordVoxelSteps(debugSample.iterationCount);
    recordRayEnd(hit, earlyTermination);

    if (pc.debugMode > 0) {
        switch (pc.debugMode) {
            case DEBUG_MODE_OCTANT:
                color = vec3(
                    float(debugSample.octantMask & 1u),
                    float((debugSample.octantMask >> 1u) & 1u),
                    float((debugSample.octantMask >> 2u) & 1u)
                );
                break;

            case DEBUG_MODE_DEPTH:
                {
                    float normalizedScale = float(debugSample.scale - 16) / float(octreeConfig.esvoMaxScale - 16);
                    color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), normalizedScale);
                }
                break;

            case DEBUG_MODE_ITERATIONS:
                {
                    float normalizedIter = float(debugSample.iterationCount) / 100.0;
                    color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), clamp(normalizedIter, 0.0, 1.0));
                }
                break;

            case DEBUG_MODE_T_SPAN:
                color = vec3(debugSample.tMin * 0.1, debugSample.tMax * 0.1, 0.0);
                break;

            case DEBUG_MODE_NORMALS:
                color = normalShading(debugSample.localNorm);
                break;

            case DEBUG_MODE_POSITION:
                color = debugSample.posMirrored - vec3(1.0);
                break;
        }
    }

    imageStore(outputImage, pixelCoords, vec4(color, 1.0));
}
