bool traverseOctreeSimple(vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                          out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    const int S_MAX = 5;
    const float EPSILON_ESVO = exp2(-float(S_MAX));

    // World-space AABB test
    vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);
    if (gridT.y < 0.0) return false;

    vec3 gridSize = gridMax - gridMin;
    vec3 rayStartWorld = (gridT.x > 0.0) ? (rayOrigin + rayDir * (gridT.x + EPSILON)) : rayOrigin;

    // Transform to octree space [1,2] - ESVO standard space
    vec3 p = ((rayStartWorld - gridMin) / gridSize) + 1.0;
    vec3 d = normalize(rayDir);

    // Avoid division by zero
    if(abs(d.x) < EPSILON_ESVO) d.x = sign(d.x) * EPSILON_ESVO;
    if(abs(d.y) < EPSILON_ESVO) d.y = sign(d.y) * EPSILON_ESVO;
    if(abs(d.z) < EPSILON_ESVO) d.z = sign(d.z) * EPSILON_ESVO;

    // Parametric coefficients for ray equation: p + t*d
    float tx_coef = 1.0 / -abs(d.x);
    float ty_coef = 1.0 / -abs(d.y);
    float tz_coef = 1.0 / -abs(d.z);
    float tx_bias = tx_coef * p.x;
    float ty_bias = ty_coef * p.y;
    float tz_bias = tz_coef * p.z;

    // Octant mirroring to handle all ray directions
    int octant_mask = 7;
    if (d.x > 0.0) { octant_mask ^= 1; tx_bias = 3.0 * tx_coef - tx_bias; }
    if (d.y > 0.0) { octant_mask ^= 2; ty_bias = 3.0 * ty_coef - ty_bias; }
    if (d.z > 0.0) { octant_mask ^= 4; tz_bias = 3.0 * tz_coef - tz_bias; }

    // Root node t-span
    float t_min = max(max(2.0 * tx_coef - tx_bias, 2.0 * ty_coef - ty_bias), 2.0 * tz_coef - tz_bias);
    float t_max = min(min(tx_coef - tx_bias, ty_coef - ty_bias), tz_coef - tz_bias);
    float h = t_max;
    t_min = max(t_min, 0.0);

    if (t_min >= t_max) return false;

    // Stack for DFS traversal
    struct StackEntry {
        uint parentPtr;
        float t_max;
    };

    const int STACK_SIZE = 23;
    StackEntry stack[STACK_SIZE];
    int stackPtr = 0;

    // Initialize traversal at root
    uint parentPtr = 0u;
    int scale = S_MAX - 1;
    float scale_exp2 = exp2(-float(scale));

    // Position in mirrored octree space
    vec3 pos = vec3(1.0);

    // Select initial child octant based on ray entry point (1.5 is center of [1,2])
    int idx = 0;
    if (1.5 * tx_coef - tx_bias > t_min) { idx ^= 1; pos.x = 1.5; }
    if (1.5 * ty_coef - ty_bias > t_min) { idx ^= 2; pos.y = 1.5; }
    if (1.5 * tz_coef - tz_bias > t_min) { idx ^= 4; pos.z = 1.5; }

    const int MAX_ITERS = 500;
    for (int iter = 0; iter < MAX_ITERS && scale < S_MAX; ++iter) {

        // Early termination check
        if (t_min >= h) {
            // No hit in current subtree, try popping
            if (stackPtr == 0) break;
            stackPtr--;
            parentPtr = stack[stackPtr].parentPtr;
            t_max = stack[stackPtr].t_max;
            scale = int(findMSB(parentPtr)) >> 1;
            scale_exp2 = exp2(-float(scale));

            // Reconstruct position from parent pointer
            int ofs = int(parentPtr) >> (scale * 3);
            pos.x = 1.0 + scale_exp2 * float((ofs & 1) != 0 ? 1.0 : 0.0);
            pos.y = 1.0 + scale_exp2 * float((ofs & 2) != 0 ? 1.0 : 0.0);
            pos.z = 1.0 + scale_exp2 * float((ofs & 4) != 0 ? 1.0 : 0.0);

            // Update idx for current position
            idx = ((pos.x > 1.0) ? 1 : 0) |
                  ((pos.y > 1.0) ? 2 : 0) |
                  ((pos.z > 1.0) ? 4 : 0);

            h = 0.0;
            continue;
        }

        // Fetch current parent node
        uvec2 parent_descriptor = fetchESVONode(parentPtr);
        uint childMask = getChildMask(parent_descriptor);
        uint childOffset = getChildOffset(parent_descriptor);

        // Compute current voxel exit planes
        float tx_corner = pos.x * tx_coef - tx_bias;
        float ty_corner = pos.y * ty_coef - ty_bias;
        float tz_corner = pos.z * tz_coef - tz_bias;
        float tc_max = min(min(tx_corner, ty_corner), tz_corner);

        // Check if current child exists in octree
        int child_shift = idx ^ octant_mask ^ 7;  // Invert for correct bit position
        bool childExists = ((childMask >> child_shift) & 1u) != 0u;

        if (childExists && t_min <= t_max) {
            float tv_max = min(t_max, tc_max);
            float halfScale = scale_exp2 * 0.5;

            if (tc_max * halfScale >= scale_exp2 * t_min) {  // Overlap test

                // Check if this is a leaf
                uint nonLeafMask = getNonLeafMask(parent_descriptor);
                bool isLeaf = ((nonLeafMask >> child_shift) & 1u) == 0u;

                if (isLeaf) {
                    // Process leaf voxel/brick
                    uint childIdx = uint(idx ^ octant_mask);
                    uint childPtr = childOffset + childIdx;
                    uvec2 childNode = fetchESVONode(childPtr);

                    // Check for constant material
                    if (isConstant(childNode)) {
                        uint matID = getConstantMaterialID(childNode);
                        Material m = getMaterial(matID);
                        hitColor = m.albedo;

                        // Compute normal based on exit plane
                        vec3 normal = vec3(0.0);
                        if (tx_corner <= tc_max) normal.x = (idx & 1) != 0 ? 1.0 : -1.0;
                        if (ty_corner <= tc_max) normal.y = (idx & 2) != 0 ? 1.0 : -1.0;
                        if (tz_corner <= tc_max) normal.z = (idx & 4) != 0 ? 1.0 : -1.0;
                        hitNormal = normalize(normal);
                        hitT = t_min;
                        return true;
                    }

                    // Process brick
                    uint brickIndex = getBrickOffset(childNode);
                    vec3 leafMin = pos - vec3(scale_exp2);
                    vec3 leafMax = pos;
                    vec3 brickMin = gridMin + (leafMin - 1.0) * gridSize;
                    vec3 brickMax = gridMin + (leafMax - 1.0) * gridSize;

                    uint axisMask;
                    if (marchBrick(rayOrigin, rayDir, t_min * length(gridSize) * 0.5,
                                   brickMin, brickMax, brickIndex, hitColor, hitNormal, axisMask)) {
                        hitT = t_min;
                        return true;
                    }

                    // Skip past empty brick
                    t_min = tv_max;

                } else {
                    // Internal node - PUSH & DESCEND

                    // Compute child center for subdivision
                    float tx_center = halfScale * tx_coef + tx_corner;
                    float ty_center = halfScale * ty_coef + ty_corner;
                    float tz_center = halfScale * tz_coef + tz_corner;

                    // Push far children to stack if they exist
                    if (t_min < tc_max && stackPtr < STACK_SIZE) {
                        // Determine which children are "far" based on ray direction
                        int child_idx = 0;

                        // Check all 8 potential children
                        for (int i = 0; i < 8; i++) {
                            if (i == (idx ^ octant_mask)) continue; // Skip current

                            // Check if child exists
                            int bit_pos = i ^ octant_mask ^ 7;
                            if (((childMask >> bit_pos) & 1u) == 0u) continue;

                            // Compute child's t-span
                            vec3 child_pos = pos - vec3(scale_exp2);
                            if ((i & 1) != 0) child_pos.x += halfScale;
                            if ((i & 2) != 0) child_pos.y += halfScale;
                            if ((i & 4) != 0) child_pos.z += halfScale;

                            float ctx = (child_pos.x + halfScale) * tx_coef - tx_bias;
                            float cty = (child_pos.y + halfScale) * ty_coef - ty_bias;
                            float ctz = (child_pos.z + halfScale) * tz_coef - tz_bias;
                            float ct_max = min(min(ctx, cty), ctz);

                            // If ray will intersect this child, push it
                            if (ct_max > t_min) {
                                uint push_ptr = childOffset + uint(i);
                                stack[stackPtr].parentPtr = push_ptr;
                                stack[stackPtr].t_max = min(ct_max, t_max);
                                stackPtr++;
                                if (stackPtr >= STACK_SIZE) break;
                            }
                        }
                    }

                    // Descend to near child
                    uint childIdx = uint(idx ^ octant_mask);
                    parentPtr = childOffset + childIdx;

                    // Update position for child level
                    idx = 0;
                    scale--;
                    scale_exp2 = halfScale;

                    if (tx_center > t_min) { idx ^= 1; pos.x += scale_exp2; }
                    else                   { pos.x -= scale_exp2; }
                    if (ty_center > t_min) { idx ^= 2; pos.y += scale_exp2; }
                    else                   { pos.y -= scale_exp2; }
                    if (tz_center > t_min) { idx ^= 4; pos.z += scale_exp2; }
                    else                   { pos.z -= scale_exp2; }

                    t_max = tv_max;
                    h = tc_max;
                    continue;
                }
            }
        }

        // ADVANCE - Move to next sibling voxel
        int step_mask = 0;
        if (tx_corner <= tc_max) { step_mask ^= 1; pos.x -= scale_exp2; }
        if (ty_corner <= tc_max) { step_mask ^= 2; pos.y -= scale_exp2; }
        if (tz_corner <= tc_max) { step_mask ^= 4; pos.z -= scale_exp2; }

        t_min = tc_max;
        idx ^= step_mask;

        // Check if we've exited the parent voxel
        if ((idx & step_mask) != 0) {
            // POP - We need to go back up
            if (stackPtr == 0) break;  // Nothing left to traverse

            stackPtr--;
            parentPtr = stack[stackPtr].parentPtr;
            t_max = stack[stackPtr].t_max;
            scale = int(findMSB(parentPtr)) >> 1;
            scale_exp2 = exp2(-float(scale));

            // Reconstruct position
            int ofs = int(parentPtr) >> (scale * 3);
            pos.x = 1.0 + scale_exp2 * float((ofs & 1) != 0 ? 1.0 : 0.0);
            pos.y = 1.0 + scale_exp2 * float((ofs & 2) != 0 ? 1.0 : 0.0);
            pos.z = 1.0 + scale_exp2 * float((ofs & 4) != 0 ? 1.0 : 0.0);

            idx = ((pos.x > 1.0) ? 1 : 0) |
                  ((pos.y > 1.0) ? 2 : 0) |
                  ((pos.z > 1.0) ? 4 : 0);

            h = 0.0;
        }
    }

    return false;
}