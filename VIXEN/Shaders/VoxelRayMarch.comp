// VoxelRayMarch.comp
// Hierarchical octree-based voxel ray marching with empty-space skipping and brick-local DDA
//
// Research References:
// - [1] Nousiainen: "Performance comparison on rendering methods for voxel data"
// - [5] Voetter: "Volumetric Ray Tracing with Vulkan"
// - [16] Derin et al.: "BlockWalk" (target for later block-level optimization)
//
// Notes:
// - Traversal: Ray-guided descent; if child octant empty, jump to exit plane (skipDistance)
// - Leaves: 8^3 bricks; inside-brick traversal uses parametric 3D DDA for exact face stepping
// - Debug: Optional overlays via VOXEL_RAY_DEBUG_* macros; default path returns shaded material
// - Background: Dark blue-gray; can be replaced with sky or GI later

#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

// Workgroup size: 8x8 threads per group (64 threads total)
// Optimal for most GPUs, balances occupancy vs register pressure
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BINDINGS
// ============================================================================

// Binding 0: Output image (storage image, write-only)
// NOTE: Shader uses rgba8, swapchain is bgra8 (VK_FORMAT_B8G8R8A8_UNORM)
// This causes validation warnings but hardware typically handles the format difference gracefully
layout(set = 0, binding = 0) uniform writeonly image2D outputImage;

// Binding 1: Camera data (uniform buffer)
layout(set = 0, binding = 1) uniform CameraData {
    mat4 invProjection;      // Inverse projection matrix
    mat4 invView;            // Inverse view matrix
    vec3 cameraPos;          // Camera world position
    uint gridResolution;     // Voxel grid resolution (32, 64, 128, 256, 512)
} camera;

// Binding 2: Octree nodes (SSBO, read-only)
// Each node is 40 bytes: childOffsets[8] + childMask + leafMask + padding + brickOffset
layout(std430, set = 0, binding = 2) readonly buffer OctreeNodesBuffer {
    uint data[];  // Packed OctreeNode data (40 bytes per node)
} octreeNodes;

// Binding 3: Voxel bricks (SSBO, read-only)
// Each brick is 512 bytes: 8x8x8 dense voxel array
layout(std430, set = 0, binding = 3) readonly buffer VoxelBricksBuffer {
    uint data[];  // Packed VoxelBrick data (128 uints per brick, 4 voxels per uint)
} voxelBricks;

// Binding 4: Material palette (SSBO, read-only)
// Each material is 32 bytes: vec3 albedo, float roughness, float metallic, float emissive, float[2] padding
layout(std430, set = 0, binding = 4) readonly buffer MaterialPaletteBuffer {
    vec4 data[];  // Packed VoxelMaterial data (2 vec4s per material)
} materialPalette;

// ============================================================================
// CONSTANTS
// ============================================================================

const int MAX_STEPS = 1024;          // Safety cap for outer traversal iterations
const float EPSILON = 0.001;         // Small value for floating-point comparisons
const vec3 BACKGROUND_COLOR = vec3(0.1, 0.1, 0.2);  // Dark blue-gray
const vec3 LIGHT_DIR = normalize(vec3(1.0, 1.0, 0.5));  // Directional light

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Generate ray direction from screen-space pixel coordinates
// Maps pixel coords → NDC → clip space → world space
vec3 generateRayDirection(ivec2 pixelCoords, ivec2 screenSize) {
    // Convert pixel coords to NDC [-1, 1]
    // Flip Y to match Vulkan coordinate system (Y+ down in screen space, up in world space)
    vec2 ndc = (vec2(pixelCoords) + vec2(0.5)) / vec2(screenSize) * 2.0 - 1.0;
    ndc.y = -ndc.y;  // Flip Y-axis for correct orientation

    // Unproject near and far planes to clip space
    vec4 clipNear = vec4(ndc, -1.0, 1.0);  // Near plane (z = -1)
    vec4 clipFar = vec4(ndc, 1.0, 1.0);    // Far plane (z = 1)

    // Transform to view space
    vec4 viewNear = camera.invProjection * clipNear;
    vec4 viewFar = camera.invProjection * clipFar;

    // Perspective divide
    viewNear /= viewNear.w;
    viewFar /= viewFar.w;

    // Transform to world space
    vec4 worldNear = camera.invView * viewNear;
    vec4 worldFar = camera.invView * viewFar;

    // Calculate ray direction (from camera to far plane point)
    return normalize(worldFar.xyz - worldNear.xyz);
}

// Calculate voxel face normal from hit position
// Used for simple diffuse shading
vec3 calculateVoxelNormal(vec3 hitPos, ivec3 voxelPos) {
    // Local position within voxel [0, 1]
    vec3 localPos = hitPos - vec3(voxelPos);

    // Distance from each face (centered at 0.5)
    vec3 absLocalPos = abs(localPos - 0.5);

    // Find which face we hit (maximum component)
    float maxComponent = max(max(absLocalPos.x, absLocalPos.y), absLocalPos.z);

    // Return normal for the hit face
    if (absLocalPos.x == maxComponent) {
        return vec3(sign(localPos.x - 0.5), 0.0, 0.0);
    } else if (absLocalPos.y == maxComponent) {
        return vec3(0.0, sign(localPos.y - 0.5), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(localPos.z - 0.5));
    }
}

// Simple diffuse shading
vec3 shadeVoxel(vec3 normal, vec3 albedo) {
    float diffuse = max(dot(normal, LIGHT_DIR), 0.0);
    vec3 ambient = vec3(0.2);
    return albedo * (ambient + diffuse * 0.8);
}

// ============================================================================
// OCTREE DATA ACCESS
// ============================================================================

// OctreeNode accessor functions
// Memory layout: childOffsets[8] (32 bytes) + childMask (1 byte) + leafMask (1 byte) + padding (2 bytes) + brickOffset (4 bytes) = 40 bytes
// Packed as 10 uints per node

uint getChildOffset(uint nodeIndex, uint childIndex) {
    uint baseOffset = nodeIndex * 10;  // 10 uints per node (40 bytes)
    return octreeNodes.data[baseOffset + childIndex];
}

uint getChildMask(uint nodeIndex) {
    uint baseOffset = nodeIndex * 10;
    uint packed = octreeNodes.data[baseOffset + 8];  // childMask + leafMask + padding
    return packed & 0xFF;  // Extract childMask (byte 0)
}

uint getLeafMask(uint nodeIndex) {
    uint baseOffset = nodeIndex * 10;
    uint packed = octreeNodes.data[baseOffset + 8];
    return (packed >> 8) & 0xFF;  // Extract leafMask (byte 1)
}

uint getBrickOffset(uint nodeIndex) {
    uint baseOffset = nodeIndex * 10;
    return octreeNodes.data[baseOffset + 9];
}

bool hasChild(uint childMask, uint childIndex) {
    return (childMask & (1u << childIndex)) != 0u;
}

bool isLeaf(uint leafMask, uint childIndex) {
    return (leafMask & (1u << childIndex)) != 0u;
}

// VoxelBrick accessor
// Each brick is 8x8x8 = 512 bytes = 128 uints (4 voxels packed per uint)
uint getVoxelFromBrick(uint brickIndex, ivec3 localPos) {
    uint baseOffset = brickIndex * 128;  // 128 uints per brick
    uint voxelIndex = uint(localPos.z * 64 + localPos.y * 8 + localPos.x);  // 0-511
    uint uintIndex = voxelIndex / 4u;  // 4 voxels per uint
    uint byteIndex = voxelIndex % 4u;

    uint packed = voxelBricks.data[baseOffset + uintIndex];
    return (packed >> (byteIndex * 8u)) & 0xFFu;  // Extract byte
}

// Material accessor
// Each material is 32 bytes = 8 floats = 2 vec4s
// Layout: vec3 albedo + float roughness + float metallic + float emissive + float[2] padding
struct Material {
    vec3 albedo;
    float roughness;
    float metallic;
    float emissive;
};

Material getMaterial(uint materialID) {
    uint baseOffset = materialID * 2u;  // 2 vec4s per material
    vec4 data0 = materialPalette.data[baseOffset];
    vec4 data1 = materialPalette.data[baseOffset + 1u];

    Material mat;
    mat.albedo = data0.xyz;
    mat.roughness = data0.w;
    mat.metallic = data1.x;
    mat.emissive = data1.y;
    return mat;
}

// Compute child octant index from position within node bounds
// Returns 0-7 based on which octant the position falls into
uint getChildOctant(vec3 posInNode) {
    uvec3 octant = uvec3(greaterThanEqual(posInNode, vec3(0.5)));
    return octant.x + octant.y * 2u + octant.z * 4u;
}

// ============================================================================
// OCTREE TRAVERSAL
// ============================================================================

// Octree traversal & brick DDA
// Combines hierarchical descent (child masks) with precise voxel stepping in leaf bricks.
// Empty-space skipping implemented by advancing ray directly to node AABB exit.

// Ray-AABB intersection helper
// Returns (tEnter, tExit) for ray-box intersection, or (-1, -1) if no hit
vec2 rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 invDir = 1.0 / (rayDir + vec3(EPSILON));
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit = min(min(tmax.x, tmax.y), tmax.z);

    if (tExit < 0.0 || tEnter > tExit) {
        return vec2(-1.0, -1.0);  // No intersection
    }

    return vec2(max(tEnter, 0.0), tExit);
}

// DDA march through 8^3 brick using parametric voxel traversal.
// Returns true if hit solid voxel and fills hitColor/hitNormal.
bool marchBrick(vec3 rayOrigin, vec3 rayDir, vec3 brickMin, vec3 brickMax,
                uint brickOffset, out vec3 hitColor, out vec3 hitNormal) {
    vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
    if (brickT.x < 0.0) return false; // Missed brick

    // Compute voxel size (uniform cube assumed)
    vec3 brickSize = brickMax - brickMin;
    float voxelSize = brickSize.x / 8.0;

    // Start position: ray entry (clamped to current global t)
    vec3 startPos = rayOrigin + rayDir * brickT.x;
    ivec3 voxelPos = ivec3(floor((startPos - brickMin) / voxelSize));
    voxelPos = clamp(voxelPos, ivec3(0), ivec3(7));

    // Step direction per axis
    ivec3 step = ivec3(sign(rayDir));
    // If rayDir component == 0, prevent division by zero by treating tDelta as huge
    vec3 tDelta = vec3(
        (rayDir.x != 0.0) ? abs(voxelSize / rayDir.x) : 1e30,
        (rayDir.y != 0.0) ? abs(voxelSize / rayDir.y) : 1e30,
        (rayDir.z != 0.0) ? abs(voxelSize / rayDir.z) : 1e30);

    // Distances to first voxel boundary along each axis
    vec3 voxelMin = brickMin + vec3(voxelPos) * voxelSize;
    vec3 voxelMax = voxelMin + vec3(voxelSize);
    vec3 tMax;
    for (int axis = 0; axis < 3; ++axis) {
        if (rayDir[axis] > 0.0)
            tMax[axis] = (voxelMax[axis] - startPos[axis]) / rayDir[axis];
        else if (rayDir[axis] < 0.0)
            tMax[axis] = (voxelMin[axis] - startPos[axis]) / rayDir[axis];
        else
            tMax[axis] = 1e30; // Parallel axis
    }

    // Traverse up to reasonable limit (8^3 worst-case)
    for (int iter = 0; iter < 128; ++iter) {
        // Bounds check
        if (any(lessThan(voxelPos, ivec3(0))) || any(greaterThan(voxelPos, ivec3(7)))) {
            break; // Exited brick
        }

        // Sample voxel
        uint voxelValue = getVoxelFromBrick(brickOffset, voxelPos);
        if (voxelValue > 0u) {
            Material mat = getMaterial(voxelValue);
            // Approximate local position for normal; use center approach
            vec3 worldPosCenter = brickMin + (vec3(voxelPos) + 0.5) * voxelSize;
            vec3 localPos = (worldPosCenter - voxelMin) / voxelSize; // [0,1]
            hitNormal = calculateVoxelNormal(localPos, ivec3(0));
            hitColor = shadeVoxel(hitNormal, mat.albedo);
            return true;
        }

        // Advance to next voxel boundary
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                voxelPos.x += step.x;
                tMax.x += tDelta.x;
            } else {
                voxelPos.z += step.z;
                tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                voxelPos.y += step.y;
                tMax.y += tDelta.y;
            } else {
                voxelPos.z += step.z;
                tMax.z += tDelta.z;
            }
        }
    }
    return false; // No hit inside brick
}

vec4 traceRay(vec3 rayOrigin, vec3 rayDir) {
    // Grid positioning in world space
    float halfGrid = float(camera.gridResolution) * 0.5;
    vec3 gridWorldCenter = vec3(0.0, 0.0, -200.0);
    vec3 gridMin = gridWorldCenter - vec3(halfGrid);
    vec3 gridMax = gridWorldCenter + vec3(halfGrid);

    // Intersect ray with grid root AABB
    vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);
    if (gridT.x < 0.0) {
        return vec4(BACKGROUND_COLOR, 1.0);  // Ray missed grid
    }

    // Start ray at grid entry point
    float t = gridT.x;
    float tMax = gridT.y;

    const int MAX_RAY_STEPS = 1024;

    for (int rayStep = 0; rayStep < MAX_RAY_STEPS && t < tMax; rayStep++) {

        vec3 rayPos = rayOrigin + rayDir * t;

        // Transform to grid-local space [0, gridRes]
        vec3 gridLocalPos = rayPos - (gridWorldCenter - vec3(halfGrid));
        // Normalize to [0, 1] for octree traversal
        vec3 normalizedPos = gridLocalPos / float(camera.gridResolution);

        // Ensure we're still within grid bounds (allow boundary voxels)
        if (any(lessThan(normalizedPos, vec3(0.0))) || any(greaterThan(normalizedPos, vec3(1.0)))) {
            break;
        }

        // Hierarchical octree descent at this ray position
        const int MAX_DEPTH = 9;
        uint nodeStack[MAX_DEPTH];
        vec3 minStack[MAX_DEPTH];
        vec3 maxStack[MAX_DEPTH];
        int stackPtr = 0;

        // Push root node (normalized space [0, 1])
        nodeStack[0] = 0u;
        minStack[0] = vec3(0.0);
        maxStack[0] = vec3(1.0);

        vec3 hitColor;
        vec3 hitNormal;
        float skipDistance = 0.0;

        // Traverse octree to find node containing this ray position
        for (int iter = 0; iter < 64 && stackPtr >= 0; iter++) {
            // Pop node from stack
            uint nodeIndex = nodeStack[stackPtr];
            vec3 nodeMin = minStack[stackPtr];
            vec3 nodeMax = maxStack[stackPtr];
            stackPtr--;

            // Check if position is inside this node
            if (any(lessThan(normalizedPos, nodeMin)) || any(greaterThanEqual(normalizedPos, nodeMax))) {
                continue;  // Position outside node
            }

            // Read node data
            uint childMask = getChildMask(nodeIndex);
            uint leafMask = getLeafMask(nodeIndex);

            // Determine which child octant contains the ray position
            vec3 posInNode = (normalizedPos - nodeMin) / (nodeMax - nodeMin);  // [0, 1] within node
            uint octantIndex = getChildOctant(posInNode);

            // Check if child exists
            if (!hasChild(childMask, octantIndex)) {
                // Empty child - compute distance to exit this node and skip
                vec3 nodeWorldMin = gridMin + nodeMin * (gridMax - gridMin);
                vec3 nodeWorldMax = gridMin + nodeMax * (gridMax - gridMin);
                vec2 nodeT = rayAABBIntersection(rayOrigin, rayDir, nodeWorldMin, nodeWorldMax);
                if (nodeT.y > t) {
                    skipDistance = nodeT.y - t + EPSILON;  // Jump to node exit
                }
                break;  // Exit octree descent for this position
            }

            // Compute child bounds in normalized space
            vec3 childMin = nodeMin + vec3(uvec3(octantIndex & 1u, (octantIndex >> 1u) & 1u, (octantIndex >> 2u) & 1u)) * (nodeMax - nodeMin) * 0.5;
            vec3 childMax = childMin + (nodeMax - nodeMin) * 0.5;

            // Check if child is a leaf brick
            if (isLeaf(leafMask, octantIndex)) {
                // Leaf brick - DDA march inside brick
                uint brickOffset = getChildOffset(nodeIndex, octantIndex);
                if (brickOffset == 0u) {
                    // Invalid brick - treat as empty, skip this node
                    vec3 nodeWorldMin = gridMin + childMin * (gridMax - gridMin);
                    vec3 nodeWorldMax = gridMin + childMax * (gridMax - gridMin);
                    vec2 nodeT = rayAABBIntersection(rayOrigin, rayDir, nodeWorldMin, nodeWorldMax);
                    if (nodeT.y > t) {
                        skipDistance = nodeT.y - t + EPSILON;
                    }
                    break;
                }
                vec3 brickWorldMin = gridMin + childMin * (gridMax - gridMin);
                vec3 brickWorldMax = gridMin + childMax * (gridMax - gridMin);
                if (marchBrick(rayOrigin, rayDir, brickWorldMin, brickWorldMax, brickOffset, hitColor, hitNormal)) {
                    return vec4(hitColor, 1.0);
                }
                // Skip to brick exit if no hit
                vec2 bT = rayAABBIntersection(rayOrigin, rayDir, brickWorldMin, brickWorldMax);
                if (bT.y > t) skipDistance = bT.y - t + EPSILON;
                break;
            } else {
                // Internal node - descend into child
                uint childOffset = getChildOffset(nodeIndex, octantIndex);
                if (childOffset == 0u) {
                    // Invalid child - skip this node
                    vec3 nodeWorldMin = gridMin + childMin * (gridMax - gridMin);
                    vec3 nodeWorldMax = gridMin + childMax * (gridMax - gridMin);
                    vec2 nodeT = rayAABBIntersection(rayOrigin, rayDir, nodeWorldMin, nodeWorldMax);
                    if (nodeT.y > t) {
                        skipDistance = nodeT.y - t + EPSILON;
                    }
                    break;
                }

                // Push child onto stack
                stackPtr++;
                if (stackPtr >= MAX_DEPTH) break;

                nodeStack[stackPtr] = childOffset;
                minStack[stackPtr] = childMin;
                maxStack[stackPtr] = childMax;
            }
        }  // End octree descent

        // Advance ray
        if (skipDistance > 0.0) t += skipDistance; else t += EPSILON * 2.0;
    }  // End ray march loop

    // No hit - return background
    return vec4(BACKGROUND_COLOR, 1.0);
}

// ============================================================================
// MAIN
// ============================================================================

void main() {
    // Get pixel coordinates from global invocation ID
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screenSize = imageSize(outputImage);

    // Boundary check (avoid out-of-bounds writes)
    if (pixelCoords.x >= screenSize.x || pixelCoords.y >= screenSize.y) {
        return;
    }

    // Generate ray direction for this pixel
    vec3 rayDir = generateRayDirection(pixelCoords, screenSize);

    // Trace ray through octree
    vec4 color = traceRay(camera.cameraPos, rayDir);

    // Write final color to output image
    imageStore(outputImage, pixelCoords, color);
}
