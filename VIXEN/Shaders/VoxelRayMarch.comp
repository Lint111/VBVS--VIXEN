// VoxelRayMarch.comp
// Hierarchical octree-based voxel ray marching with empty-space skipping and brick-local DDA
//
// Research References:
// - [1] Nousiainen: "Performance comparison on rendering methods for voxel data"
// - [5] Voetter: "Volumetric Ray Tracing with Vulkan"
// - [16] Derin et al.: "BlockWalk" (target for later block-level optimization)
//
// Notes:
// - Traversal: Ray-guided descent; if child octant empty, jump to exit plane (skipDistance)
// - Leaves: 8^3 bricks; inside-brick traversal uses parametric 3D DDA for exact face stepping
// - Debug: Optional overlays via VOXEL_RAY_DEBUG_* macros; default path returns shaded material
// - Background: Dark blue-gray; can be replaced with sky or GI later

#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

// Workgroup size: 8x8 threads per group (64 threads total)
// Optimal for most GPUs, balances occupancy vs register pressure
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BINDINGS
// ============================================================================

// Binding 0: Output image (storage image, write-only)
// NOTE: Shader uses rgba8, swapchain is bgra8 (VK_FORMAT_B8G8R8A8_UNORM)
// This causes validation warnings but hardware typically handles the format difference gracefully
layout(set = 0, binding = 0) uniform writeonly image2D outputImage;

// Binding 1: Camera data (uniform buffer)
layout(set = 0, binding = 1) uniform CameraData {
    mat4 invProjection;      // Inverse projection matrix
    mat4 invView;            // Inverse view matrix
    vec3 cameraPos;          // Camera world position
    uint gridResolution;     // Voxel grid resolution (32, 64, 128, 256, 512)
} camera;

// Binding 2: Octree nodes (SSBO, read-only)
// Each node is 40 bytes: childOffsets[8] + childMask + leafMask + padding + brickOffset
layout(std430, set = 0, binding = 2) readonly buffer OctreeNodesBuffer {
    uint data[];  // Packed OctreeNode data (40 bytes per node)
} octreeNodes;

// Binding 3: Voxel bricks (SSBO, read-only)
// Each brick is 512 bytes: 8x8x8 dense voxel array
layout(std430, set = 0, binding = 3) readonly buffer VoxelBricksBuffer {
    uint data[];  // Packed VoxelBrick data (128 uints per brick, 4 voxels per uint)
} voxelBricks;

// Binding 4: Material palette (SSBO, read-only)
// Each material is 32 bytes: vec3 albedo, float roughness, float metallic, float emissive, float[2] padding
layout(std430, set = 0, binding = 4) readonly buffer MaterialPaletteBuffer {
    vec4 data[];  // Packed VoxelMaterial data (2 vec4s per material)
} materialPalette;

// ============================================================================
// CONSTANTS
// ============================================================================

// Step/bounce controls
// Only strictly limit ray bounces; graph traversal should run to completion (bounded by root AABB intersection)
const int MAX_OCTREE_ITERS = 250;     // Generous cap for per-position octree descent
const int MAX_RAY_STEPS = 1000;        // Safety cap for main ray march loop iterations
const int RAY_MAX_BOUNCES = 1;        // Ray bounces (set >1 for future GI); current shader exits on first hit

const float EPSILON = 0.001;         // Small value for floating-point comparisons
const float SURFACE_EPS = 0.0005;    // Epsilon used to avoid re-hitting boundary planes
const vec3 BACKGROUND_COLOR = vec3(0.1, 0.1, 0.2);  // Dark blue-gray
const vec3 LIGHT_DIR = normalize(vec3(1.0, 1.0, 0.5));  // Directional light

// Optional debug: visualize brick boundaries (set to 1 to enable)
#ifndef VOXEL_RAY_DEBUG_BRICK_BOUNDARY
#define VOXEL_RAY_DEBUG_BRICK_BOUNDARY 0
#endif

// Optional debug: visualize spatial regions & traversal depth (set to 1 to enable)
#ifndef VOXEL_RAY_DEBUG_SPATIAL
#define VOXEL_RAY_DEBUG_SPATIAL 0
#endif

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Generate ray direction from screen-space pixel coordinates
// Maps pixel coords → NDC → clip space → world space
vec3 generateRayDirection(ivec2 pixelCoords, ivec2 screenSize) {
    // Convert pixel coords to NDC [-1, 1]
    // Flip Y to match Vulkan coordinate system (Y+ down in screen space, up in world space)
    vec2 ndc = (vec2(pixelCoords) + vec2(0.5)) / vec2(screenSize) * 2.0 - 1.0;
    ndc.y = -ndc.y;  // Flip Y-axis for correct orientation

    // Unproject near and far planes to clip space
    vec4 clipNear = vec4(ndc, -1.0, 1.0);  // Near plane (z = -1)
    vec4 clipFar = vec4(ndc, 1.0, 1.0);    // Far plane (z = 1)

    // Transform to view space
    vec4 viewNear = camera.invProjection * clipNear;
    vec4 viewFar = camera.invProjection * clipFar;

    // Perspective divide
    viewNear /= viewNear.w;
    viewFar /= viewFar.w;

    // Transform to world space
    vec4 worldNear = camera.invView * viewNear;
    vec4 worldFar = camera.invView * viewFar;

    // Calculate ray direction (from camera to far plane point)
    return normalize(worldFar.xyz - worldNear.xyz);
}

// Calculate voxel face normal from hit position
// Used for simple diffuse shading
vec3 calculateVoxelNormal(vec3 hitPos, ivec3 voxelPos) {
    // Local position within voxel [0, 1]
    vec3 localPos = hitPos - vec3(voxelPos);

    // Distance from each face (centered at 0.5)
    vec3 absLocalPos = abs(localPos - 0.5);

    // Find which face we hit (maximum component)
    float maxComponent = max(max(absLocalPos.x, absLocalPos.y), absLocalPos.z);

    // Return normal for the hit face
    if (absLocalPos.x == maxComponent) {
        return vec3(sign(localPos.x - 0.5), 0.0, 0.0);
    } else if (absLocalPos.y == maxComponent) {
        return vec3(0.0, sign(localPos.y - 0.5), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(localPos.z - 0.5));
    }
}

// Simple diffuse shading
vec3 shadeVoxel(vec3 normal, vec3 albedo) {
    float diffuse = max(dot(normal, LIGHT_DIR), 0.0);
    vec3 ambient = vec3(0.2);
    return albedo * (ambient + diffuse * 0.8);
}

// ============================================================================
// OCTREE DATA ACCESS
// ============================================================================

// OctreeNode accessor functions
// Memory layout: childOffsets[8] (32 bytes) + childMask (1 byte) + leafMask (1 byte) + padding (2 bytes) + brickOffset (4 bytes) = 40 bytes
// Packed as 10 uints per node

uint getChildOffset(uint nodeIndex, uint childIndex) {
    uint baseOffset = nodeIndex * 10;  // 10 uints per node (40 bytes)
    return octreeNodes.data[baseOffset + childIndex];
}

uint getChildMask(uint nodeIndex) {
    uint baseOffset = nodeIndex * 10;
    uint packed = octreeNodes.data[baseOffset + 8];  // childMask + leafMask + padding
    return packed & 0xFF;  // Extract childMask (byte 0)
}

uint getLeafMask(uint nodeIndex) {
    uint baseOffset = nodeIndex * 10;
    uint packed = octreeNodes.data[baseOffset + 8];
    return (packed >> 8) & 0xFF;  // Extract leafMask (byte 1)
}

uint getBrickOffset(uint nodeIndex) {
    uint baseOffset = nodeIndex * 10;
    return octreeNodes.data[baseOffset + 9];
}

bool hasChild(uint childMask, uint childIndex) {
    return (childMask & (1u << childIndex)) != 0u;
}

bool isLeaf(uint leafMask, uint childIndex) {
    return (leafMask & (1u << childIndex)) != 0u;
}

// VoxelBrick accessor
// Each brick is 8x8x8 = 512 bytes = 128 uints (4 voxels packed per uint)
uint getVoxelFromBrick(uint brickIndex, ivec3 localPos) {
    uint baseOffset = brickIndex * 128;  // 128 uints per brick
    uint voxelIndex = uint(localPos.z * 64 + localPos.y * 8 + localPos.x);  // 0-511
    uint uintIndex = voxelIndex / 4u;  // 4 voxels per uint
    uint byteIndex = voxelIndex % 4u;

    uint packed = voxelBricks.data[baseOffset + uintIndex];
    return (packed >> (byteIndex * 8u)) & 0xFFu;  // Extract byte
}

// Material accessor
// Each material is 32 bytes = 8 floats = 2 vec4s
// Layout: vec3 albedo + float roughness + float metallic + float emissive + float[2] padding
struct Material {
    vec3 albedo;
    float roughness;
    float metallic;
    float emissive;
};

Material getMaterial(uint materialID) {
    uint baseOffset = materialID * 2u;  // 2 vec4s per material
    vec4 data0 = materialPalette.data[baseOffset];
    vec4 data1 = materialPalette.data[baseOffset + 1u];

    Material mat;
    mat.albedo = data0.xyz;
    mat.roughness = data0.w;
    mat.metallic = data1.x;
    mat.emissive = data1.y;
    return mat;
}

// Compute child octant index from position within node bounds
// Returns 0-7 based on which octant the position falls into
uint getChildOctant(vec3 posInNode) {
    uvec3 octant = uvec3(greaterThanEqual(posInNode, vec3(0.5)));
    return octant.x + octant.y * 2u + octant.z * 4u;
}

// ============================================================================
// OCTREE TRAVERSAL
// ============================================================================

// Octree traversal & brick DDA
// Combines hierarchical descent (child masks) with precise voxel stepping in leaf bricks.
// Empty-space skipping implemented by advancing ray directly to node AABB exit.

// Ray-AABB intersection helper
// Returns (tEnter, tExit) for ray-box intersection, or (-1, -1) if no hit
vec2 rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 invDir = vec3(
        rayDir.x != 0.0 ? 1.0 / rayDir.x : 1e30,
        rayDir.y != 0.0 ? 1.0 / rayDir.y : 1e30,
        rayDir.z != 0.0 ? 1.0 / rayDir.z : 1e30);
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit = min(min(tmax.x, tmax.y), tmax.z);

    if (tExit < 0.0 || tEnter > tExit) {
        return vec2(-1.0, -1.0);  // No intersection
    }

    return vec2(max(tEnter, 0.0), tExit);
}

// ============================================================================
// REVELLES PARAMETRIC OCTREE TRAVERSAL (Iterative Implementation)
// Reference: "An Efficient Parametric Algorithm for Octree Traversal" (2000)
// Revelles, Urena, Lastra
// Note: GLSL doesn't support recursion, so this uses an explicit stack
// ============================================================================

// Forward declaration for brick DDA (defined below)
bool marchBrick(vec3 rayOrigin, vec3 rayDir, float tStart, vec3 brickMin, vec3 brickMax,
                uint brickOffset, out vec3 hitColor, out vec3 hitNormal);

// Stack entry for iterative octree traversal
struct TraversalState {
    uint nodeIndex;
    float tx0, ty0, tz0;
    float tx1, ty1, tz1;
    vec3 nodeMin, nodeMax;
    uint currentOctant;    // Which octant we're currently processing (0-8, 8=done)
};

// Compute octant index from which middle plane comparisons
// Returns 0-7 based on which octant to visit first
uint first_node(float tx0, float ty0, float tz0, float txm, float tym, float tzm) {
    uint octant = 0u;
    
    // Determine entry octant by comparing entry t-values with middle planes
    if (tx0 > ty0) {
        if (tx0 > tz0) {
            // X-plane entered first
            if (tym < tx0) octant |= 2u;
            if (tzm < tx0) octant |= 4u;
            return octant;
        }
    } else {
        if (ty0 > tz0) {
            // Y-plane entered first
            if (txm < ty0) octant |= 1u;
            if (tzm < ty0) octant |= 4u;
            return octant;
        }
    }
    
    // Z-plane entered first
    if (txm < tz0) octant |= 1u;
    if (tym < tz0) octant |= 2u;
    return octant;
}

// Compute next octant to visit after exiting current one
// Returns 8 if we exit the parent node entirely
uint new_node(float txm, float tym, float tzm, uint x, uint y, uint z) {
    if (txm < tym) {
        if (txm < tzm) { return x; }  // Exit through YZ-plane
    } else {
        if (tym < tzm) { return y; }  // Exit through XZ-plane
    }
    return z;  // Exit through XY-plane
}

// Iterative octree traversal using Revelles parametric method with explicit stack
// Returns true if leaf brick hit, fills hitColor/hitNormal/hitT
bool traverseOctree(uint rootNodeIndex, float tx0, float ty0, float tz0, 
                    float tx1, float ty1, float tz1,
                    vec3 rootMin, vec3 rootMax, uint octantMask,
                    vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                    out vec3 hitColor, out vec3 hitNormal, out float hitT) {
    
    const int MAX_STACK_DEPTH = 32;
    TraversalState stack[MAX_STACK_DEPTH];
    int stackPtr = 0;
    
    // Push root node
    stack[0].nodeIndex = rootNodeIndex;
    stack[0].tx0 = tx0;
    stack[0].ty0 = ty0;
    stack[0].tz0 = tz0;
    stack[0].tx1 = tx1;
    stack[0].ty1 = ty1;
    stack[0].tz1 = tz1;
    stack[0].nodeMin = rootMin;
    stack[0].nodeMax = rootMax;
    stack[0].currentOctant = 0u;  // Will be set by first_node below
    
    while (stackPtr >= 0) {
        TraversalState state = stack[stackPtr];
        
        // Check bounds
        if (state.tx1 < 0.0 || state.ty1 < 0.0 || state.tz1 < 0.0) {
            stackPtr--;  // Pop and continue
            continue;
        }
        
        // Read node data
        uint childMask = getChildMask(state.nodeIndex);
        uint leafMask = getLeafMask(state.nodeIndex);
        
        // Compute middle planes
        float txm = 0.5 * (state.tx0 + state.tx1);
        float tym = 0.5 * (state.ty0 + state.ty1);
        float tzm = 0.5 * (state.tz0 + state.tz1);
        
        // Initialize octant on first visit
        if (stack[stackPtr].currentOctant == 0u && stackPtr == 0) {
            stack[stackPtr].currentOctant = first_node(state.tx0, state.ty0, state.tz0, txm, tym, tzm);
        }
        
        uint currOctant = stack[stackPtr].currentOctant;
        
        // Check if we've processed all octants
        if (currOctant >= 8u) {
            stackPtr--;  // Pop and continue with parent
            continue;
        }
        
        // Advance to next octant for when we return to this node
        stack[stackPtr].currentOctant = new_node(txm, tym, tzm, 
                                                  currOctant | 1u,
                                                  currOctant | 2u,
                                                  currOctant | 4u);
        
        // Apply direction mask
        uint actualOctant = currOctant ^ octantMask;
        
        // Check if child exists
        if (!hasChild(childMask, actualOctant)) {
            continue;  // Skip empty child, loop will advance to next octant
        }
        
        // Compute child bounds
        vec3 nodeSize = state.nodeMax - state.nodeMin;
        vec3 childMin = state.nodeMin + vec3(
            (actualOctant & 1u) != 0u ? nodeSize.x * 0.5 : 0.0,
            ((actualOctant >> 1u) & 1u) != 0u ? nodeSize.y * 0.5 : 0.0,
            ((actualOctant >> 2u) & 1u) != 0u ? nodeSize.z * 0.5 : 0.0
        );
        vec3 childMax = childMin + nodeSize * 0.5;
        
        // Check if it's a leaf brick
        if (isLeaf(leafMask, actualOctant)) {
            // Hit leaf brick - invoke brick DDA
            uint brickOffset = getChildOffset(state.nodeIndex, actualOctant);
            
            // Transform to world space
            vec3 brickWorldMin = gridMin + childMin * (gridMax - gridMin);
            vec3 brickWorldMax = gridMin + childMax * (gridMax - gridMin);
            
            // March the brick
            if (marchBrick(rayOrigin, rayDir, state.tx0, brickWorldMin, brickWorldMax, 
                           brickOffset, hitColor, hitNormal)) {
                hitT = state.tx0;
                return true;
            }
            // Brick miss - continue to next octant
        } else {
            // Internal node - push onto stack and descend
            if (stackPtr + 1 < MAX_STACK_DEPTH) {
                uint childNodeIndex = getChildOffset(state.nodeIndex, actualOctant);
                
                // Compute child t-bounds
                float ctx0, cty0, ctz0, ctx1, cty1, ctz1;
                if ((currOctant & 1u) != 0u) { ctx0 = txm; ctx1 = state.tx1; } else { ctx0 = state.tx0; ctx1 = txm; }
                if ((currOctant & 2u) != 0u) { cty0 = tym; cty1 = state.ty1; } else { cty0 = state.ty0; cty1 = tym; }
                if ((currOctant & 4u) != 0u) { ctz0 = tzm; ctz1 = state.tz1; } else { ctz0 = state.tz0; ctz1 = tzm; }
                
                stackPtr++;
                stack[stackPtr].nodeIndex = childNodeIndex;
                stack[stackPtr].tx0 = ctx0;
                stack[stackPtr].ty0 = cty0;
                stack[stackPtr].tz0 = ctz0;
                stack[stackPtr].tx1 = ctx1;
                stack[stackPtr].ty1 = cty1;
                stack[stackPtr].tz1 = ctz1;
                stack[stackPtr].nodeMin = childMin;
                stack[stackPtr].nodeMax = childMax;
                stack[stackPtr].currentOctant = first_node(ctx0, cty0, ctz0,
                                                           0.5 * (ctx0 + ctx1),
                                                           0.5 * (cty0 + cty1),
                                                           0.5 * (ctz0 + ctz1));
            }
        }
    }
    
    return false;
}

// ============================================================================
// BRICK DDA (unchanged)
// ============================================================================

// DDA march through 8^3 brick using parametric voxel traversal.
// Returns true if hit solid voxel and fills hitColor/hitNormal.
bool marchBrick(vec3 rayOrigin, vec3 rayDir, float tStart, vec3 brickMin, vec3 brickMax,
                uint brickOffset, out vec3 hitColor, out vec3 hitNormal) {
    vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
    if (brickT.x < 0.0) return false; // Missed brick

    // Compute voxel size (uniform cube assumed)
    vec3 brickSize = brickMax - brickMin;
    float voxelSize = brickSize.x / 8.0;

    // Start position: from current ray t or brick entry, whichever is later
    // Don't add bias yet - compute clean entry point first
    float startT = max(tStart, brickT.x);
    vec3 cleanStartPos = rayOrigin + rayDir * startT;
    
    // Compute starting voxel from clean position
    vec3 relPos = cleanStartPos - brickMin;
    ivec3 voxelPos = ivec3(floor(relPos / voxelSize));
    voxelPos = clamp(voxelPos, ivec3(0), ivec3(7));
    
    // NOW apply bias to avoid re-hitting entry boundary
    startT += SURFACE_EPS;
    vec3 startPos = rayOrigin + rayDir * startT;

    // Step direction per axis
    ivec3 step = ivec3(sign(rayDir));
    // If rayDir component == 0, prevent division by zero by treating tDelta as huge
    vec3 tDelta = vec3(
        (rayDir.x != 0.0) ? abs(voxelSize / rayDir.x) : 1e30,
        (rayDir.y != 0.0) ? abs(voxelSize / rayDir.y) : 1e30,
        (rayDir.z != 0.0) ? abs(voxelSize / rayDir.z) : 1e30);

    // Distances to first voxel boundary along each axis
    // tMax must be absolute parametric distance from rayOrigin, not relative to startPos
    vec3 voxelMin = brickMin + vec3(voxelPos) * voxelSize;
    vec3 voxelMax = voxelMin + vec3(voxelSize);
    vec3 tMax;
    for (int axis = 0; axis < 3; ++axis) {
        if (rayDir[axis] > 0.0)
            tMax[axis] = (voxelMax[axis] - rayOrigin[axis]) / rayDir[axis];
        else if (rayDir[axis] < 0.0)
            tMax[axis] = (voxelMin[axis] - rayOrigin[axis]) / rayDir[axis];
        else
            tMax[axis] = 1e30; // Parallel axis
    }

    // Traverse up to reasonable limit (8^3 worst-case)
    // Track current parametric t within brick volume for exit test
    float currentT = startT;
    float brickExitT = brickT.y;

    // Use a generous iteration cap as a safety guard; in practice, at most ~512 steps for 8^3 voxels
    for (int iter = 0; iter < 2048; ++iter) {
        // Bounds check
        if (any(lessThan(voxelPos, ivec3(0))) || any(greaterThan(voxelPos, ivec3(7)))) {
            break; // Exited brick
        }

        // Early escape: if we've progressed beyond brick exit parametric distance
        if (currentT > brickExitT + SURFACE_EPS) {
            break;
        }

        // Sample voxel
        uint voxelValue = getVoxelFromBrick(brickOffset, voxelPos);
        if (voxelValue > 0u) {
            // Hit solid voxel
            Material mat = getMaterial(voxelValue);

            // Compute stable normal from dominant ray direction
            vec3 ad = abs(rayDir);
            if (ad.x >= ad.y && ad.x >= ad.z) {
                hitNormal = vec3(-sign(rayDir.x), 0.0, 0.0);
            } else if (ad.y >= ad.z) {
                hitNormal = vec3(0.0, -sign(rayDir.y), 0.0);
            } else {
                hitNormal = vec3(0.0, 0.0, -sign(rayDir.z));
            }

            hitColor = shadeVoxel(hitNormal, mat.albedo);
            return true;
        }

        // Determine which axis crosses its boundary first
        float nextT = min(min(tMax.x, tMax.y), tMax.z);

        // Step to next voxel along the axis with minimum tMax
        if (tMax.x <= tMax.y && tMax.x <= tMax.z) {
            voxelPos.x += step.x;
            tMax.x += tDelta.x;
        } else if (tMax.y <= tMax.z) {
            voxelPos.y += step.y;
            tMax.y += tDelta.y;
        } else {
            voxelPos.z += step.z;
            tMax.z += tDelta.z;
        }

        // Update current parametric position (nextT is absolute from ray origin)
        currentT = nextT;
    }
    return false; // No hit inside brick
}

vec4 traceRay(vec3 rayOrigin, vec3 rayDir) {
    // Grid positioning in world space
    float halfGrid = float(camera.gridResolution) * 0.5;
    vec3 gridWorldCenter = vec3(0.0, 0.0, -200.0);
    vec3 gridMin = gridWorldCenter - vec3(halfGrid);
    vec3 gridMax = gridWorldCenter + vec3(halfGrid);

    for (int bounce = 0; bounce < RAY_MAX_BOUNCES; ++bounce) {
        // Intersect ray with grid root AABB
        vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);
        if (gridT.x < 0.0) {
            return vec4(BACKGROUND_COLOR, 1.0);  // Ray missed grid
        }

        // Compute parametric t-bounds for Revelles algorithm
        // Transform grid intersection to normalized [0,1] space
        vec3 invDir = vec3(
            rayDir.x != 0.0 ? 1.0 / rayDir.x : 1e30,
            rayDir.y != 0.0 ? 1.0 / rayDir.y : 1e30,
            rayDir.z != 0.0 ? 1.0 / rayDir.z : 1e30
        );
        
        vec3 t0 = (gridMin - rayOrigin) * invDir;
        vec3 t1 = (gridMax - rayOrigin) * invDir;
        
        // Compute octant mask based on ray direction signs
        // This XOR mask will flip octant indices to handle negative directions
        uint octantMask = 0u;
        if (rayDir.x < 0.0) { octantMask |= 1u; float tmp = t0.x; t0.x = t1.x; t1.x = tmp; }
        if (rayDir.y < 0.0) { octantMask |= 2u; float tmp = t0.y; t0.y = t1.y; t1.y = tmp; }
        if (rayDir.z < 0.0) { octantMask |= 4u; float tmp = t0.z; t0.z = t1.z; t1.z = tmp; }
        
        vec3 hitColor;
        vec3 hitNormal;
        float hitT;
        
        // Invoke Revelles parametric octree traversal (iterative version)
        // Root node bounds are [0,1] in normalized space
        if (traverseOctree(0u, max(t0.x, 0.0), max(t0.y, 0.0), max(t0.z, 0.0), 
                          t1.x, t1.y, t1.z, 
                          vec3(0.0), vec3(1.0), octantMask,
                          rayOrigin, rayDir, gridMin, gridMax,
                          hitColor, hitNormal, hitT)) {
            // Hit found - shade and return
            #if VOXEL_RAY_DEBUG_BRICK_BOUNDARY
            return vec4(hitColor, 1.0);
            #else
            return vec4(shadeVoxel(hitNormal, hitColor), 1.0);
            #endif
        }

        // No hit this bounce
        break;
    }  // End bounce loop

    // No hit across bounces - return background
    return vec4(BACKGROUND_COLOR, 1.0);
}

// ============================================================================
// MAIN
// ============================================================================

void main() {
    // Get pixel coordinates from global invocation ID
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screenSize = imageSize(outputImage);

    // Boundary check (avoid out-of-bounds writes)
    if (pixelCoords.x >= screenSize.x || pixelCoords.y >= screenSize.y) {
        return;
    }

    // Generate ray direction for this pixel
    vec3 rayDir = generateRayDirection(pixelCoords, screenSize);

    // Trace ray through octree
    vec4 color = traceRay(camera.cameraPos, rayDir);

    // Write final color to output image
    imageStore(outputImage, pixelCoords, color);
}
