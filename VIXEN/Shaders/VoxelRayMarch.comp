// VoxelRayMarch.comp
// Hierarchical octree-based voxel ray marching with empty-space skipping and brick-local DDA
//
// Research References:
// - [1] Nousiainen: "Performance comparison on rendering methods for voxel data"
// - [5] Voetter: "Volumetric Ray Tracing with Vulkan"
// - [16] Derin et al.: "BlockWalk" (target for later block-level optimization)
//
// Notes:
// - Traversal: Ray-guided descent; if child octant empty, jump to exit plane (skipDistance)
// - Leaves: 8^3 bricks; inside-brick traversal uses parametric 3D DDA for exact face stepping
// - Debug: Optional overlays via VOXEL_RAY_DEBUG_* macros; default path returns shaded material
// - Background: Dark blue-gray; can be replaced with sky or GI later

#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

// ESVO traversal inlined below (lines 253-391)
// Full algorithm based on NVIDIA Laine & Karras 2010

// Workgroup size: 8x8 threads per group (64 threads total)
// Optimal for most GPUs, balances occupancy vs register pressure
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BINDINGS
// ============================================================================

// Binding 0: Output image (storage image, write-only)
// NOTE: Shader uses rgba8, swapchain is bgra8 (VK_FORMAT_B8G8R8A8_UNORM)
// This causes validation warnings but hardware typically handles the format difference gracefully
layout(set = 0, binding = 0) uniform writeonly image2D outputImage;

// Binding 1: Camera data (uniform buffer)
layout(set = 0, binding = 1) uniform CameraData {
    mat4 invProjection;      // Inverse projection matrix
    mat4 invView;            // Inverse view matrix
    vec3 cameraPos;          // Camera world position
    uint gridResolution;     // Voxel grid resolution (32, 64, 128, 256, 512)
    float lodBias;           // LOD bias (0.5 = finer, 1.0 = default, 2.0 = coarser)
    float padding[3];        // Align to 16 bytes
} camera;

// Binding 2: Octree nodes (SSBO, read-only)
// ESVO format: 8 bytes per node (descriptor0 + descriptor1)
layout(std430, set = 0, binding = 2) readonly buffer OctreeNodesBuffer {
    uint data[];  // Packed ESVONode data (2 uints per node = 8 bytes)
} octreeNodes;

// Binding 3: Voxel bricks (SSBO, read-only)
// Each brick is 512 bytes: 8x8x8 dense voxel array
layout(std430, set = 0, binding = 3) readonly buffer VoxelBricksBuffer {
    uint data[];  // Packed VoxelBrick data (128 uints per brick, 4 voxels per uint)
} voxelBricks;

// Binding 4: Material palette (SSBO, read-only)
// Each material is 32 bytes: vec3 albedo, float roughness, float metallic, float emissive, float[2] padding
layout(std430, set = 0, binding = 4) readonly buffer MaterialPaletteBuffer {
    vec4 data[];  // Packed VoxelMaterial data (2 vec4s per material)
} materialPalette;

// ============================================================================
// CONSTANTS
// ============================================================================

// Step/bounce controls
// Only strictly limit ray bounces; graph traversal should run to completion (bounded by root AABB intersection)
const int MAX_OCTREE_ITERS = 250;     // Generous cap for per-position octree descent
const int MAX_RAY_STEPS = 1000;        // Safety cap for main ray march loop iterations
const int RAY_MAX_BOUNCES = 1;        // Ray bounces (set >1 for future GI); current shader exits on first hit

const float EPSILON = 0.001;         // Small value for floating-point comparisons
const float SURFACE_EPS = 0.0005;    // Epsilon used to avoid re-hitting boundary planes
const vec3 BACKGROUND_COLOR = vec3(0.1, 0.1, 0.2);  // Dark blue-gray
const vec3 LIGHT_DIR = normalize(vec3(1.0, 1.0, 0.5));  // Directional light

// Optional debug: visualize brick boundaries (set to 1 to enable)
#ifndef VOXEL_RAY_DEBUG_BRICK_BOUNDARY
#define VOXEL_RAY_DEBUG_BRICK_BOUNDARY 0
#endif

// Optional debug: visualize spatial regions & traversal depth (set to 1 to enable)
#ifndef VOXEL_RAY_DEBUG_SPATIAL
#define VOXEL_RAY_DEBUG_SPATIAL 0
#endif

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Generate ray direction from screen-space pixel coordinates
// Use proper unprojection through inverse matrices
vec3 generateRayDirection(ivec2 pixelCoords, ivec2 screenSize) {
    // Convert pixel coords to NDC [-1, 1]
    vec2 ndc = (vec2(pixelCoords) + vec2(0.5)) / vec2(screenSize) * 2.0 - 1.0;
    ndc.y = -ndc.y;  // Flip Y for Vulkan

    // Extract camera basis vectors from invView matrix
    // invView transforms view space -> world space
    // Columns are: right (X), up (Y), forward (Z), position (W)
    vec3 right = camera.invView[0].xyz;
    vec3 up = camera.invView[1].xyz;
    vec3 forward = -camera.invView[2].xyz;  // Negate because +Z in view is backward

    // For inverse projection matrix, the diagonal elements ARE tan(fov/2)
    // invProjection[0][0] = aspect * tan(fov/2)
    // invProjection[1][1] = tan(fov/2)
    float tanHalfFov = camera.invProjection[1][1];
    float aspectTanHalfFov = camera.invProjection[0][0];

    // Construct ray direction in world space
    vec3 rayDir = normalize(forward + ndc.x * aspectTanHalfFov * right + ndc.y * tanHalfFov * up);

    return rayDir;
}

// Calculate voxel face normal from hit position
// Used for simple diffuse shading
vec3 calculateVoxelNormal(vec3 hitPos, ivec3 voxelPos) {
    // Local position within voxel [0, 1]
    vec3 localPos = hitPos - vec3(voxelPos);

    // Distance from each face (centered at 0.5)
    vec3 absLocalPos = abs(localPos - 0.5);

    // Find which face we hit (maximum component)
    float maxComponent = max(max(absLocalPos.x, absLocalPos.y), absLocalPos.z);

    // Return normal for the hit face
    if (absLocalPos.x == maxComponent) {
        return vec3(sign(localPos.x - 0.5), 0.0, 0.0);
    } else if (absLocalPos.y == maxComponent) {
        return vec3(0.0, sign(localPos.y - 0.5), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(localPos.z - 0.5));
    }
}

// Simple diffuse shading
vec3 shadeVoxel(vec3 normal, vec3 albedo) {
    float diffuse = max(dot(normal, LIGHT_DIR), 0.0);
    vec3 ambient = vec3(0.2);
    return albedo * (ambient + diffuse * 0.8);
}

// ============================================================================
// ESVO NODE DATA ACCESS
// ============================================================================

// ESVONode accessor functions
// Memory layout: descriptor0 (32 bits) + descriptor1 (32 bits) = 8 bytes total
// Packed as 2 uints per node

// Fetch ESVO node descriptor pair
uvec2 fetchESVONode(uint nodeIndex) {
    uint baseOffset = nodeIndex * 2u;  // 2 uints per node (8 bytes)
    return uvec2(
        octreeNodes.data[baseOffset],      // descriptor0
        octreeNodes.data[baseOffset + 1u]  // descriptor1
    );
}

// Extract child existence mask (8 bits from descriptor0)
uint getChildMask(uvec2 node) {
    return (node.x >> 8) & 0xFFu;
}

// Extract non-leaf mask (7 bits from descriptor0)
uint getNonLeafMask(uvec2 node) {
    return (node.x >> 1) & 0x7Fu;
}

// Check if child exists
bool hasChild(uvec2 node, uint childIndex) {
    uint mask = getChildMask(node);
    return (mask & (1u << childIndex)) != 0u;
}

// Check if child is leaf (brick)
bool isLeaf(uvec2 node, uint childIndex) {
    if (childIndex >= 7u) return true;  // Child 7 has no non-leaf bit
    uint mask = getNonLeafMask(node);
    return (mask & (1u << childIndex)) == 0u;
}

// Get child offset (15 bits from descriptor0)
uint getChildOffset(uvec2 node) {
    return (node.x >> 17) & 0x7FFFu;
}

// Check if using far pointer
bool isFarPointer(uvec2 node) {
    return (node.x & 0x10000u) != 0u;
}

// Get brick offset (31 bits from descriptor1)
uint getBrickOffset(uvec2 node) {
    return node.y & 0x7FFFFFFFu;
}

// Check if node is constant (homogeneous region)
bool isConstant(uvec2 node) {
    return (node.y & 0x80000000u) != 0u;
}

// Get combined child masks (for ESVO traversal)
int getCombinedMasks(uvec2 node, uint childIndex) {
    int child_shift = int(childIndex);
    return int(node.x) << child_shift;
}

// VoxelBrick accessor
// Each brick is 8x8x8 = 512 bytes = 128 uints (4 voxels packed per uint)
uint getVoxelFromBrick(uint brickIndex, ivec3 localPos) {
    uint baseOffset = brickIndex * 128;  // 128 uints per brick
    uint voxelIndex = uint(localPos.z * 64 + localPos.y * 8 + localPos.x);  // 0-511
    uint uintIndex = voxelIndex / 4u;  // 4 voxels per uint
    uint byteIndex = voxelIndex % 4u;

    uint packed = voxelBricks.data[baseOffset + uintIndex];
    return (packed >> (byteIndex * 8u)) & 0xFFu;  // Extract byte
}

// Material accessor
// Each material is 32 bytes = 8 floats = 2 vec4s
// Layout: vec3 albedo + float roughness + float metallic + float emissive + float[2] padding
struct Material {
    vec3 albedo;
    float roughness;
    float metallic;
    float emissive;
};

Material getMaterial(uint materialID) {
    uint baseOffset = materialID * 2u;  // 2 vec4s per material
    vec4 data0 = materialPalette.data[baseOffset];
    vec4 data1 = materialPalette.data[baseOffset + 1u];

    Material mat;
    mat.albedo = data0.xyz;
    mat.roughness = data0.w;
    mat.metallic = data1.x;
    mat.emissive = data1.y;
    return mat;
}

// Compute child octant index from position within node bounds
// Returns 0-7 based on which octant the position falls into
uint getChildOctant(vec3 posInNode) {
    uvec3 octant = uvec3(greaterThanEqual(posInNode, vec3(0.5)));
    return octant.x + octant.y * 2u + octant.z * 4u;
}

// ============================================================================
// OCTREE TRAVERSAL (ESVO Algorithm)
// ============================================================================

// Octree traversal using ESVO format + brick DDA
// Combines hierarchical descent (child masks) with precise voxel stepping in leaf bricks.
// Empty-space skipping implemented by advancing ray directly to node AABB exit.

// Ray-AABB intersection helper
// Returns (tEnter, tExit) for ray-box intersection, or (-1, -1) if no hit
// Optimized ray-AABB intersection (avoids division entirely)
// Uses sign-aware multiplication instead of division by rayDir
vec2 rayAABBIntersectionFast(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    float tmin = 0.0;
    float tmax = 1e30;

    for (int i = 0; i < 3; ++i) {
        float d = (i == 0) ? rayDir.x : (i == 1) ? rayDir.y : rayDir.z;
        float o = (i == 0) ? rayOrigin.x : (i == 1) ? rayOrigin.y : rayOrigin.z;
        float bmin = (i == 0) ? boxMin.x : (i == 1) ? boxMin.y : boxMin.z;
        float bmax = (i == 0) ? boxMax.x : (i == 1) ? boxMax.y : boxMax.z;

        if (abs(d) > 1e-8) {
            float t1 = (bmin - o) / d;
            float t2 = (bmax - o) / d;
            tmin = max(tmin, min(t1, t2));
            tmax = min(tmax, max(t1, t2));
        } else {
            // Ray parallel to slab - check if origin is inside
            if (o < bmin || o > bmax) {
                return vec2(-1.0, -1.0);
            }
        }
    }

    if (tmin > tmax || tmax < 0.0) {
        return vec2(-1.0, -1.0);
    }

    return vec2(max(tmin, 0.0), tmax);
}

// Slab method ray-AABB intersection
vec2 rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    // Safe inverse: avoid division by near-zero
    vec3 invDir = vec3(
        abs(rayDir.x) > 1e-8 ? 1.0 / rayDir.x : 1e8 * sign(rayDir.x),
        abs(rayDir.y) > 1e-8 ? 1.0 / rayDir.y : 1e8 * sign(rayDir.y),
        abs(rayDir.z) > 1e-8 ? 1.0 / rayDir.z : 1e8 * sign(rayDir.z)
    );

    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;

    vec3 tmin3 = min(t0, t1);
    vec3 tmax3 = max(t0, t1);

    float tmin = max(max(tmin3.x, tmin3.y), tmin3.z);
    float tmax = min(min(tmax3.x, tmax3.y), tmax3.z);

    if (tmin > tmax || tmax < 0.0) {
        return vec2(-1.0, -1.0);
    }

    return vec2(max(tmin, 0.0), tmax);
}

// Full ESVO octree traversal (production algorithm)
// Based on NVIDIA's Efficient Sparse Voxel Octree (Laine & Karras 2010)
bool traverseOctreeSimple(vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                          out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    // DEBUG: If we enter this function, show magenta
    hitColor = vec3(1.0, 0.0, 1.0);
    hitT = 0.0;
    return true;

    // ESVO traversal state
    const int S_MAX = 23;
    const float EPSILON_ESVO = exp2(-float(S_MAX));

    // LOD parameters (from camera uniform)
    float raySizeCoef = camera.lodBias;  // 1.0 = default, 2.0 = coarser LOD
    float raySizeBias = 0.0;

    // Transform ray to [1,2] octree space (ESVO convention)
    vec3 gridSize = gridMax - gridMin;
    vec3 p = ((rayOrigin - gridMin) / gridSize) + 1.0;  // [0,1] â†’ [1,2]
    vec3 d = rayDir;

    // Avoid division by zero
    if (abs(d.x) < EPSILON_ESVO) d.x = sign(d.x) * EPSILON_ESVO;
    if (abs(d.y) < EPSILON_ESVO) d.y = sign(d.y) * EPSILON_ESVO;
    if (abs(d.z) < EPSILON_ESVO) d.z = sign(d.z) * EPSILON_ESVO;

    // Parametric plane coefficients
    float tx_coef = 1.0 / -abs(d.x);
    float ty_coef = 1.0 / -abs(d.y);
    float tz_coef = 1.0 / -abs(d.z);
    float tx_bias = tx_coef * p.x;
    float ty_bias = ty_coef * p.y;
    float tz_bias = tz_coef * p.z;

    // Octant mirroring (unify ray direction to always negative)
    int octant_mask = 7;
    if (d.x > 0.0) { octant_mask ^= 1; tx_bias = 3.0 * tx_coef - tx_bias; }
    if (d.y > 0.0) { octant_mask ^= 2; ty_bias = 3.0 * ty_coef - ty_bias; }
    if (d.z > 0.0) { octant_mask ^= 4; tz_bias = 3.0 * tz_coef - tz_bias; }

    // Ray-octree intersection (active t-span)
    float t_min = max(max(2.0 * tx_coef - tx_bias, 2.0 * ty_coef - ty_bias), 2.0 * tz_coef - tz_bias);
    float t_max = min(min(tx_coef - tx_bias, ty_coef - ty_bias), tz_coef - tz_bias);
    t_min = max(t_min, 0.0);
    t_max = min(t_max, 1.0);

    if (t_min >= t_max) {
        return false;  // Ray missed octree
    }

    // Traversal state
    uint parentPtr = 0u;
    uvec2 child_descriptor = uvec2(0u, 0u);
    int idx = 0;
    vec3 pos = vec3(1.0);
    int scale = S_MAX - 1;
    float scale_exp2 = 0.5;

    // Select initial child octant
    if (1.5 * tx_coef - tx_bias > t_min) { idx ^= 1; pos.x = 1.5; }
    if (1.5 * ty_coef - ty_bias > t_min) { idx ^= 2; pos.y = 1.5; }
    if (1.5 * tz_coef - tz_bias > t_min) { idx ^= 4; pos.z = 1.5; }

    // Main traversal loop (PUSH/POP/ADVANCE)
    const int MAX_ITERS = 250;
    for (int iter = 0; iter < MAX_ITERS && scale < S_MAX; ++iter) {
        // FETCH: Load child descriptor if not cached
        if (child_descriptor.x == 0u) {
            child_descriptor = fetchESVONode(parentPtr);
        }

        // INTERSECT: Compute voxel boundaries
        float tx_corner = pos.x * tx_coef - tx_bias;
        float ty_corner = pos.y * ty_coef - ty_bias;
        float tz_corner = pos.z * tz_coef - tz_bias;
        float tc_max = min(min(tx_corner, ty_corner), tz_corner);

        // Check if child exists and t-span non-empty
        int child_shift = idx ^ octant_mask;
        int child_masks = int(child_descriptor.x) << child_shift;

        if ((child_masks & 0x8000) != 0 && t_min <= t_max) {
            // LOD TERMINATION: Stop if voxel small enough
            if (tc_max * raySizeCoef + raySizeBias >= scale_exp2) {
                // Hit! Found voxel at appropriate LOD
                // For Phase H, we just return a test color
                // Phase I will march bricks here
                hitColor = vec3(0.8, 0.3, 0.3);  // Test red
                hitNormal = vec3(0.0, 1.0, 0.0);
                hitT = t_min;
                return true;
            }

            // INTERSECT: Narrow t-span to voxel interior
            float tv_max = min(t_max, tc_max);
            float halfScale = scale_exp2 * 0.5;
            float tx_center = halfScale * tx_coef + tx_corner;
            float ty_center = halfScale * ty_coef + ty_corner;
            float tz_center = halfScale * tz_coef + tz_corner;

            // PUSH: Descend to child if non-empty t-span
            if (t_min <= tv_max) {
                // Check if node is non-leaf
                if ((child_masks & 0x0080) == 0) {
                    // Leaf node! This is a hit
                    hitColor = vec3(0.3, 0.8, 0.3);  // Test green
                    hitNormal = vec3(0.0, 1.0, 0.0);
                    hitT = t_min;
                    return true;
                }

                // Descend (simplified - no stack for Phase H baseline)
                // Full implementation would push to stack here
                scale--;
                scale_exp2 = halfScale;
                idx = 0;
                if (tx_center > t_min) { idx ^= 1; pos.x += scale_exp2; }
                if (ty_center > t_min) { idx ^= 2; pos.y += scale_exp2; }
                if (tz_center > t_min) { idx ^= 4; pos.z += scale_exp2; }
                t_max = tv_max;
                child_descriptor.x = 0u;
                continue;
            }
        }

        // ADVANCE: Step to next voxel
        int step_mask = 0;
        if (tx_corner <= tc_max) { step_mask ^= 1; pos.x -= scale_exp2; }
        if (ty_corner <= tc_max) { step_mask ^= 2; pos.y -= scale_exp2; }
        if (tz_corner <= tc_max) { step_mask ^= 4; pos.z -= scale_exp2; }
        t_min = tc_max;
        idx ^= step_mask;

        // Simplified POP (no explicit stack - limits depth for Phase H)
        if ((idx & step_mask) != 0) {
            // Would pop from stack here in full implementation
            break;  // For now, exit traversal
        }
    }

    return false;  // No hit
}

// ============================================================================
// OLD REVELLES TRAVERSAL (DEPRECATED - Replaced by ESVO)
// ============================================================================
// Commented out - ESVO format uses different traversal
// See OctreeTraversal-ESVO.glsl for full NVIDIA algorithm
// Phase H uses simple baseline, Phase I will integrate full ESVO

/*
// Forward declaration for brick DDA (defined below)
bool marchBrick(vec3 rayOrigin, vec3 rayDir, float tStart, vec3 brickMin, vec3 brickMax,
                uint brickOffset, out vec3 hitColor, out vec3 hitNormal);

// Stack entry for iterative octree traversal
struct TraversalState {
    uint nodeIndex;
    float tx0, ty0, tz0;
    float tx1, ty1, tz1;
    vec3 nodeMin, nodeMax;
    uint currentOctant;    // Which octant we're currently processing (0-8, 8=done)
};

// Compute octant index from which middle plane comparisons
// Returns 0-7 based on which octant to visit first
uint first_node(float tx0, float ty0, float tz0, float txm, float tym, float tzm) {
    uint octant = 0u;
    
    // Determine entry octant by comparing entry t-values with middle planes
    if (tx0 > ty0) {
        if (tx0 > tz0) {
            // X-plane entered first
            if (tym < tx0) octant |= 2u;
            if (tzm < tx0) octant |= 4u;
            return octant;
        }
    } else {
        if (ty0 > tz0) {
            // Y-plane entered first
            if (txm < ty0) octant |= 1u;
            if (tzm < ty0) octant |= 4u;
            return octant;
        }
    }
    
    // Z-plane entered first
    if (txm < tz0) octant |= 1u;
    if (tym < tz0) octant |= 2u;
    return octant;
}

// Compute next octant to visit after exiting current one
// Returns 8 if we exit the parent node entirely
uint new_node(float txm, float tym, float tzm, uint x, uint y, uint z) {
    if (txm < tym) {
        if (txm < tzm) { return x; }  // Exit through YZ-plane
    } else {
        if (tym < tzm) { return y; }  // Exit through XZ-plane
    }
    return z;  // Exit through XY-plane
}

// Iterative octree traversal using Revelles parametric method with explicit stack
// Returns true if leaf brick hit, fills hitColor/hitNormal/hitT
bool traverseOctree(uint rootNodeIndex, float tx0, float ty0, float tz0, 
                    float tx1, float ty1, float tz1,
                    vec3 rootMin, vec3 rootMax, uint octantMask,
                    vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                    out vec3 hitColor, out vec3 hitNormal, out float hitT) {
    
    const int MAX_STACK_DEPTH = 32;
    TraversalState stack[MAX_STACK_DEPTH];
    int stackPtr = 0;
    
    // Push root node
    stack[0].nodeIndex = rootNodeIndex;
    stack[0].tx0 = tx0;
    stack[0].ty0 = ty0;
    stack[0].tz0 = tz0;
    stack[0].tx1 = tx1;
    stack[0].ty1 = ty1;
    stack[0].tz1 = tz1;
    stack[0].nodeMin = rootMin;
    stack[0].nodeMax = rootMax;
    stack[0].currentOctant = 0u;  // Will be set by first_node below
    
    while (stackPtr >= 0) {
        TraversalState state = stack[stackPtr];
        
        // Check bounds
        if (state.tx1 < 0.0 || state.ty1 < 0.0 || state.tz1 < 0.0) {
            stackPtr--;  // Pop and continue
            continue;
        }
        
        // Read node data
        uint childMask = getChildMask(state.nodeIndex);
        uint leafMask = getLeafMask(state.nodeIndex);
        
        // Compute middle planes
        float txm = 0.5 * (state.tx0 + state.tx1);
        float tym = 0.5 * (state.ty0 + state.ty1);
        float tzm = 0.5 * (state.tz0 + state.tz1);
        
        // Initialize octant on first visit
        if (stack[stackPtr].currentOctant == 0u && stackPtr == 0) {
            stack[stackPtr].currentOctant = first_node(state.tx0, state.ty0, state.tz0, txm, tym, tzm);
        }
        
        uint currOctant = stack[stackPtr].currentOctant;
        
        // Check if we've processed all octants
        if (currOctant >= 8u) {
            stackPtr--;  // Pop and continue with parent
            continue;
        }
        
        // Advance to next octant for when we return to this node
        stack[stackPtr].currentOctant = new_node(txm, tym, tzm, 
                                                  currOctant | 1u,
                                                  currOctant | 2u,
                                                  currOctant | 4u);
        
        // Apply direction mask
        uint actualOctant = currOctant ^ octantMask;
        
        // Check if child exists
        if (!hasChild(childMask, actualOctant)) {
            continue;  // Skip empty child, loop will advance to next octant
        }
        
        // Compute child bounds
        vec3 nodeSize = state.nodeMax - state.nodeMin;
        vec3 childMin = state.nodeMin + vec3(
            (actualOctant & 1u) != 0u ? nodeSize.x * 0.5 : 0.0,
            ((actualOctant >> 1u) & 1u) != 0u ? nodeSize.y * 0.5 : 0.0,
            ((actualOctant >> 2u) & 1u) != 0u ? nodeSize.z * 0.5 : 0.0
        );
        vec3 childMax = childMin + nodeSize * 0.5;
        
        // Check if it's a leaf brick
        if (isLeaf(leafMask, actualOctant)) {
            // Hit leaf brick - invoke brick DDA
            uint brickOffset = getChildOffset(state.nodeIndex, actualOctant);
            
            // Transform to world space
            vec3 brickWorldMin = gridMin + childMin * (gridMax - gridMin);
            vec3 brickWorldMax = gridMin + childMax * (gridMax - gridMin);
            
            // March the brick
            if (marchBrick(rayOrigin, rayDir, state.tx0, brickWorldMin, brickWorldMax, 
                           brickOffset, hitColor, hitNormal)) {
                hitT = state.tx0;
                return true;
            }
            // Brick miss - continue to next octant
        } else {
            // Internal node - push onto stack and descend
            if (stackPtr + 1 < MAX_STACK_DEPTH) {
                uint childNodeIndex = getChildOffset(state.nodeIndex, actualOctant);
                
                // Compute child t-bounds
                float ctx0, cty0, ctz0, ctx1, cty1, ctz1;
                if ((currOctant & 1u) != 0u) { ctx0 = txm; ctx1 = state.tx1; } else { ctx0 = state.tx0; ctx1 = txm; }
                if ((currOctant & 2u) != 0u) { cty0 = tym; cty1 = state.ty1; } else { cty0 = state.ty0; cty1 = tym; }
                if ((currOctant & 4u) != 0u) { ctz0 = tzm; ctz1 = state.tz1; } else { ctz0 = state.tz0; ctz1 = tzm; }
                
                stackPtr++;
                stack[stackPtr].nodeIndex = childNodeIndex;
                stack[stackPtr].tx0 = ctx0;
                stack[stackPtr].ty0 = cty0;
                stack[stackPtr].tz0 = ctz0;
                stack[stackPtr].tx1 = ctx1;
                stack[stackPtr].ty1 = cty1;
                stack[stackPtr].tz1 = ctz1;
                stack[stackPtr].nodeMin = childMin;
                stack[stackPtr].nodeMax = childMax;
                stack[stackPtr].currentOctant = first_node(ctx0, cty0, ctz0,
                                                           0.5 * (ctx0 + ctx1),
                                                           0.5 * (cty0 + cty1),
                                                           0.5 * (ctz0 + ctz1));
            }
        }
    }
    
    return false;
}

*/
// End of deprecated Revelles code

// ============================================================================
// BRICK DDA (unchanged - works with ESVO)
// ============================================================================

// DDA march through 8^3 brick using parametric voxel traversal.
// Returns true if hit solid voxel and fills hitColor/hitNormal.
bool marchBrick(vec3 rayOrigin, vec3 rayDir, float tStart, vec3 brickMin, vec3 brickMax,
                uint brickOffset, out vec3 hitColor, out vec3 hitNormal) {
    vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
    if (brickT.x < 0.0) return false; // Missed brick

    // Compute voxel size (uniform cube assumed)
    vec3 brickSize = brickMax - brickMin;
    float voxelSize = brickSize.x / 8.0;

    // Start position: from current ray t or brick entry, whichever is later
    // Don't add bias yet - compute clean entry point first
    float startT = max(tStart, brickT.x);
    vec3 cleanStartPos = rayOrigin + rayDir * startT;
    
    // Compute starting voxel from clean position
    vec3 relPos = cleanStartPos - brickMin;
    ivec3 voxelPos = ivec3(floor(relPos / voxelSize));
    voxelPos = clamp(voxelPos, ivec3(0), ivec3(7));
    
    // NOW apply bias to avoid re-hitting entry boundary
    startT += SURFACE_EPS;
    vec3 startPos = rayOrigin + rayDir * startT;

    // Step direction per axis
    ivec3 step = ivec3(sign(rayDir));
    // If rayDir component == 0, prevent division by zero by treating tDelta as huge
    vec3 tDelta = vec3(
        (rayDir.x != 0.0) ? abs(voxelSize / rayDir.x) : 1e30,
        (rayDir.y != 0.0) ? abs(voxelSize / rayDir.y) : 1e30,
        (rayDir.z != 0.0) ? abs(voxelSize / rayDir.z) : 1e30);

    // Distances to first voxel boundary along each axis
    // tMax must be absolute parametric distance from rayOrigin, not relative to startPos
    vec3 voxelMin = brickMin + vec3(voxelPos) * voxelSize;
    vec3 voxelMax = voxelMin + vec3(voxelSize);
    vec3 tMax;
    for (int axis = 0; axis < 3; ++axis) {
        if (rayDir[axis] > 0.0)
            tMax[axis] = (voxelMax[axis] - rayOrigin[axis]) / rayDir[axis];
        else if (rayDir[axis] < 0.0)
            tMax[axis] = (voxelMin[axis] - rayOrigin[axis]) / rayDir[axis];
        else
            tMax[axis] = 1e30; // Parallel axis
    }

    // Traverse up to reasonable limit (8^3 worst-case)
    // Track current parametric t within brick volume for exit test
    float currentT = startT;
    float brickExitT = brickT.y;

    // Use a generous iteration cap as a safety guard; in practice, at most ~512 steps for 8^3 voxels
    for (int iter = 0; iter < 2048; ++iter) {
        // Bounds check
        if (any(lessThan(voxelPos, ivec3(0))) || any(greaterThan(voxelPos, ivec3(7)))) {
            break; // Exited brick
        }

        // Early escape: if we've progressed beyond brick exit parametric distance
        if (currentT > brickExitT + SURFACE_EPS) {
            break;
        }

        // Sample voxel
        uint voxelValue = getVoxelFromBrick(brickOffset, voxelPos);
        if (voxelValue > 0u) {
            // Hit solid voxel
            Material mat = getMaterial(voxelValue);

            // Compute stable normal from dominant ray direction
            vec3 ad = abs(rayDir);
            if (ad.x >= ad.y && ad.x >= ad.z) {
                hitNormal = vec3(-sign(rayDir.x), 0.0, 0.0);
            } else if (ad.y >= ad.z) {
                hitNormal = vec3(0.0, -sign(rayDir.y), 0.0);
            } else {
                hitNormal = vec3(0.0, 0.0, -sign(rayDir.z));
            }

            hitColor = shadeVoxel(hitNormal, mat.albedo);
            return true;
        }

        // Determine which axis crosses its boundary first
        float nextT = min(min(tMax.x, tMax.y), tMax.z);

        // Step to next voxel along the axis with minimum tMax
        if (tMax.x <= tMax.y && tMax.x <= tMax.z) {
            voxelPos.x += step.x;
            tMax.x += tDelta.x;
        } else if (tMax.y <= tMax.z) {
            voxelPos.y += step.y;
            tMax.y += tDelta.y;
        } else {
            voxelPos.z += step.z;
            tMax.z += tDelta.z;
        }

        // Update current parametric position (nextT is absolute from ray origin)
        currentT = nextT;
    }
    return false; // No hit inside brick
}

vec4 traceRay(vec3 rayOrigin, vec3 rayDir) {
    // Grid positioning in world space
    // Camera at (0,0,3) looking toward -Z
    // Grid: 10x10x10 world units, centered, 20 units from camera
    const float gridWorldSize = 10.0;
    float halfGrid = gridWorldSize * 0.5;  // 5
    vec3 gridCenter = vec3(0.0, 0.0, -20.0);  // Centered, pushed back
    vec3 gridMin = gridCenter - vec3(halfGrid);  // (-5, -5, -25)
    vec3 gridMax = gridCenter + vec3(halfGrid);  // (5, 5, -15)

    // Ray bounce loop (currently single bounce)
    for (int bounce = 0; bounce < RAY_MAX_BOUNCES; ++bounce) {
        // Intersect ray with grid root AABB
        vec2 gridT = rayAABBIntersectionFast(rayOrigin, rayDir, gridMin, gridMax);

        if (gridT.y < 0.0) {
            break;  // Miss - exit to background
        }

        // Compute octant mask for Revelles traversal
        uint octantMask = 0u;
        if (rayDir.x < 0.0) octantMask |= 1u;
        if (rayDir.y < 0.0) octantMask |= 2u;
        if (rayDir.z < 0.0) octantMask |= 4u;

        vec3 hitColor;
        vec3 hitNormal;
        float hitT;

        // Invoke ESVO octree traversal
        if (traverseOctreeSimple(rayOrigin, rayDir, gridMin, gridMax,
                                  hitColor, hitNormal, hitT)) {
            // Hit found - shade and return
            #if VOXEL_RAY_DEBUG_BRICK_BOUNDARY
            return vec4(hitColor, 1.0);
            #else
            return vec4(shadeVoxel(hitNormal, hitColor), 1.0);
            #endif
        }

        // No hit this bounce
        break;
    }

    // No hit - return background
    return vec4(BACKGROUND_COLOR, 1.0);
}

// ============================================================================
// MAIN
// ============================================================================

void main() {
    // Get pixel coordinates from global invocation ID
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screenSize = imageSize(outputImage);

    // Boundary check (avoid out-of-bounds writes)
    if (pixelCoords.x >= screenSize.x || pixelCoords.y >= screenSize.y) {
        return;
    }

    // Generate ray direction for this pixel
    vec3 rayDir = generateRayDirection(pixelCoords, screenSize);

    // Trace ray through octree
    vec4 color = traceRay(camera.cameraPos, rayDir);

    // Write final color to output image
    imageStore(outputImage, pixelCoords, color);
}
