#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Output image (no format specified - uses shaderStorageImageWriteWithoutFormat feature)
layout(binding = 0) uniform writeonly image2D outputImage;

// ESVO octree buffer (uvec2 per node - 64 bits)
layout(std430, binding = 1) readonly buffer ESVOBuffer {
    uvec2 esvoNodes[];
};

// Brick buffer (8x8x8 voxels per brick)
layout(std430, binding = 2) readonly buffer BrickBuffer {
    uint brickData[];
};

// Material buffer
struct Material {
    vec3 albedo;
    float metalness;
    float roughness;
    float emissive;
    vec2 padding;
};

layout(std430, binding = 3) readonly buffer MaterialBuffer {
    Material materials[];
};

// Push constants for camera
layout(push_constant) uniform PushConstants {
    vec3 cameraPos;
    float time;
    vec3 cameraDir;
    float fov;
    vec3 cameraUp;
    float aspect;
    vec3 cameraRight;
    float pad;
} pc;

// ESVO node fetch
uvec2 fetchESVONode(uint nodeIndex) {
    return esvoNodes[nodeIndex];
}

// ESVO descriptor bit layout helpers
// C++ layout: bits 1-7: nonLeafMask, bits 8-15: childMask (reversed), bits 17-31: childOffset
uint getChildMask(uvec2 descriptor) {
    // Child mask is stored REVERSED at bits 8-15
    // child[0] at bit 15, child[7] at bit 8
    return (descriptor.x >> 8) & 0xFFu;
}

uint getNonLeafMask(uvec2 descriptor) {
    // Non-leaf mask at bits 1-7 (7 bits for children 0-6)
    return (descriptor.x >> 1) & 0x7Fu;
}

uint getChildOffset(uvec2 descriptor) {
    // Child offset at bits 17-31 (15 bits)
    return (descriptor.x >> 17) & 0x7FFFu;
}

// Helper function to check if a child exists
// Takes care of the reversed bit ordering in childMask
bool childExists(uint childMask, int childIndex) {
    // childMask has child[0] at bit 7, child[7] at bit 0 (REVERSED order)
    int bit_pos = 7 - childIndex;
    return ((childMask >> bit_pos) & 1u) != 0u;
}

// Helper function to check if a child is a leaf node
bool childIsLeaf(uint nonLeafMask, int childIndex) {
    // Child 7 is always a leaf (no bit in nonLeafMask)
    // For children 0-6, check if the bit is 0 (leaf) or 1 (internal)
    return (childIndex >= 7) || ((nonLeafMask >> childIndex) & 1u) == 0u;
}

// Brick node helpers
bool isConstant(uvec2 node) {
    return (node.x & 0x80000000u) != 0u; // Bit 31
}

uint getConstantMaterialID(uvec2 node) {
    return node.x & 0xFFu; // Bits 0-7
}

uint getBrickOffset(uvec2 node) {
    return node.y; // Full 32 bits for brick index
}

Material getMaterial(uint matID) {
    if (matID >= 256u) matID = 0u;
    return materials[matID];
}

// Ray-AABB intersection
vec2 rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 invDir = 1.0 / rayDir;
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;
    vec3 tMin = min(t0, t1);
    vec3 tMax = max(t0, t1);
    float tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar = min(min(tMax.x, tMax.y), tMax.z);
    return vec2(tNear, tFar);
}

// Brick marching function
const float EPSILON = 0.001;

bool marchBrick(vec3 rayOrigin, vec3 rayDir, float startT,
                vec3 brickMin, vec3 brickMax, uint brickIndex,
                out vec3 hitColor, out vec3 hitNormal, out uint axisMask) {

    // Ray-AABB test for brick bounds
    vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
    if (brickT.y < 0.0) return false;

    float t = max(brickT.x, startT);
    if (t > brickT.y) return false;

    vec3 brickSize = brickMax - brickMin;
    vec3 voxelSize = brickSize / 8.0;

    // Start position in world space
    vec3 pos = rayOrigin + rayDir * (t + EPSILON);

    // DDA setup
    vec3 invDir = 1.0 / max(abs(rayDir), vec3(EPSILON));
    ivec3 step = ivec3(sign(rayDir));
    vec3 deltaDist = voxelSize * invDir;

    const int MAX_STEPS = 64;
    for (int i = 0; i < MAX_STEPS; i++) {
        // Convert world position to voxel indices
        vec3 localPos = (pos - brickMin) / voxelSize;
        ivec3 voxelIdx = ivec3(floor(localPos));

        // Check bounds
        if (any(lessThan(voxelIdx, ivec3(0))) || any(greaterThanEqual(voxelIdx, ivec3(8)))) {
            break;
        }

        // Sample brick voxel
        uint voxelLinearIdx = uint(voxelIdx.z * 64 + voxelIdx.y * 8 + voxelIdx.x);
        uint voxelData = brickData[brickIndex * 512u + voxelLinearIdx];

        if (voxelData != 0u) {
            // Hit! Extract material
            uint matID = voxelData & 0xFFu;
            Material mat = getMaterial(matID);
            hitColor = mat.albedo;

            // Compute normal from ray direction (simple for now)
            vec3 normal = vec3(0.0);
            vec3 voxelCenter = brickMin + (vec3(voxelIdx) + 0.5) * voxelSize;
            vec3 toCenter = pos - voxelCenter;
            vec3 absToCenter = abs(toCenter);

            if (absToCenter.x > absToCenter.y && absToCenter.x > absToCenter.z) {
                normal.x = sign(toCenter.x);
            } else if (absToCenter.y > absToCenter.z) {
                normal.y = sign(toCenter.y);
            } else {
                normal.z = sign(toCenter.z);
            }

            hitNormal = normalize(normal);
            return true;
        }

        // DDA step to next voxel
        vec3 nextBounds = brickMin + vec3(voxelIdx + (step + 1) / 2) * voxelSize;
        vec3 tMax = (nextBounds - pos) * invDir;

        if (tMax.x < tMax.y && tMax.x < tMax.z) {
            pos += rayDir * tMax.x;
            axisMask = 1u;
        } else if (tMax.y < tMax.z) {
            pos += rayDir * tMax.y;
            axisMask = 2u;
        } else {
            pos += rayDir * tMax.z;
            axisMask = 4u;
        }

        pos += rayDir * EPSILON;
    }

    return false;
}

// Simple ray generation
vec3 getRayDir(vec2 uv) {
    float tanHalfFov = tan(radians(pc.fov * 0.5));
    vec2 ndc = uv * 2.0 - 1.0;
    vec3 rayDir = pc.cameraDir +
                  pc.cameraRight * ndc.x * tanHalfFov * pc.aspect +
                  pc.cameraUp * ndc.y * tanHalfFov;
    return normalize(rayDir);
}

// Simple traversal for individual bricks (no octree)
bool traverseSingleBrick(vec3 rayOrigin, vec3 rayDir,
                         vec3 brickMin, vec3 brickMax, uint brickIndex,
                         out vec3 hitColor, out vec3 hitNormal) {
    uint axisMask;
    return marchBrick(rayOrigin, rayDir, 0.0, brickMin, brickMax, brickIndex,
                      hitColor, hitNormal, axisMask);
}

// Test pattern: Wall of bricks
bool traverseWallOfBricks(vec3 rayOrigin, vec3 rayDir,
                          out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    const int WALL_SIZE = 4;
    const float BRICK_SIZE = 2.0;
    const float WALL_Z = 5.0;

    float closestT = 1e10;
    bool hitAnything = false;
    vec3 bestColor;
    vec3 bestNormal;

    for (int y = 0; y < WALL_SIZE; y++) {
        for (int x = 0; x < WALL_SIZE; x++) {
            vec3 brickMin = vec3(
                float(x - WALL_SIZE/2) * BRICK_SIZE,
                float(y - WALL_SIZE/2) * BRICK_SIZE,
                WALL_Z
            );
            vec3 brickMax = brickMin + vec3(BRICK_SIZE);

            uint brickIndex = uint(y * WALL_SIZE + x);

            vec3 tempColor, tempNormal;
            uint axisMask;
            if (marchBrick(rayOrigin, rayDir, 0.0, brickMin, brickMax,
                           brickIndex, tempColor, tempNormal, axisMask)) {

                vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
                if (brickT.x < closestT) {
                    closestT = brickT.x;
                    bestColor = tempColor;
                    bestNormal = tempNormal;
                    hitAnything = true;
                }
            }
        }
    }

    if (hitAnything) {
        hitColor = bestColor;
        hitNormal = bestNormal;
        hitT = closestT;
        return true;
    }

    return false;
}

// Debug visualization for octree structure
vec3 debugOctreeLevel(uint nodeIndex, int targetLevel) {
    uvec2 descriptor = fetchESVONode(nodeIndex);
    uint childMask = getChildMask(descriptor);
    uint nonLeafMask = getNonLeafMask(descriptor);

    // Color based on node properties
    vec3 color = vec3(0.0);

    // Red channel: child occupancy
    float occupancy = float(bitCount(childMask)) / 8.0;
    color.r = occupancy;

    // Green channel: leaf vs internal
    float leafRatio = float(bitCount(childMask & ~nonLeafMask)) / max(1.0, float(bitCount(childMask)));
    color.g = leafRatio;

    // Blue channel: node depth (estimated)
    color.b = float(targetLevel) / 5.0;

    return color;
}

// Main ESVO octree traversal
bool traverseOctreeSimple(vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                          out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    const int S_MAX = 7;  // For 128^3 grid (2^7 = 128)
    const float EPSILON_ESVO = exp2(-float(S_MAX));

    // World-space AABB test
    vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);
    if (gridT.y < 0.0) return false;

    vec3 gridSize = gridMax - gridMin;
    vec3 rayStartWorld = (gridT.x > 0.0) ? (rayOrigin + rayDir * (gridT.x + EPSILON)) : rayOrigin;

    // Transform to octree space [1,2] - ESVO standard space
    vec3 p = ((rayStartWorld - gridMin) / gridSize) + 1.0;
    vec3 d = normalize(rayDir);

    // Avoid division by zero
    if(abs(d.x) < EPSILON_ESVO) d.x = sign(d.x) * EPSILON_ESVO;
    if(abs(d.y) < EPSILON_ESVO) d.y = sign(d.y) * EPSILON_ESVO;
    if(abs(d.z) < EPSILON_ESVO) d.z = sign(d.z) * EPSILON_ESVO;

    // Parametric coefficients for ray equation: p + t*d
    float tx_coef = 1.0 / -abs(d.x);
    float ty_coef = 1.0 / -abs(d.y);
    float tz_coef = 1.0 / -abs(d.z);
    float tx_bias = tx_coef * p.x;
    float ty_bias = ty_coef * p.y;
    float tz_bias = tz_coef * p.z;

    // Octant mirroring to handle all ray directions
    int octant_mask = 7;
    if (d.x > 0.0) { octant_mask ^= 1; tx_bias = 3.0 * tx_coef - tx_bias; }
    if (d.y > 0.0) { octant_mask ^= 2; ty_bias = 3.0 * ty_coef - ty_bias; }
    if (d.z > 0.0) { octant_mask ^= 4; tz_bias = 3.0 * tz_coef - tz_bias; }

    // Root node t-span
    float t_min = max(max(2.0 * tx_coef - tx_bias, 2.0 * ty_coef - ty_bias), 2.0 * tz_coef - tz_bias);
    float t_max = min(min(tx_coef - tx_bias, ty_coef - ty_bias), tz_coef - tz_bias);
    float h = t_max;
    t_min = max(t_min, 0.0);

    if (t_min >= t_max) return false;

    // Stack for DFS traversal
    struct StackEntry {
        uint parentPtr;
        float t_max;
    };

    const int STACK_SIZE = 23;
    StackEntry stack[STACK_SIZE];
    int stackPtr = 0;

    // Initialize traversal at root
    uint parentPtr = 0u;
    int scale = S_MAX - 1;
    float scale_exp2 = exp2(-float(scale));

    // Position in mirrored octree space
    vec3 pos = vec3(1.0);

    // Select initial child octant based on ray entry point (1.5 is center of [1,2])
    int idx = 0;
    if (1.5 * tx_coef - tx_bias > t_min) { idx ^= 1; pos.x = 1.5; }
    if (1.5 * ty_coef - ty_bias > t_min) { idx ^= 2; pos.y = 1.5; }
    if (1.5 * tz_coef - tz_bias > t_min) { idx ^= 4; pos.z = 1.5; }

    const int MAX_ITERS = 500;
    for (int iter = 0; iter < MAX_ITERS && scale < S_MAX; ++iter) {

        // Early termination check
        if (t_min >= h) {
            // No hit in current subtree, try popping
            if (stackPtr == 0) break;
            stackPtr--;
            parentPtr = stack[stackPtr].parentPtr;
            t_max = stack[stackPtr].t_max;
            scale = int(findMSB(parentPtr)) >> 1;
            scale_exp2 = exp2(-float(scale));

            // Reconstruct position from parent pointer
            int ofs = int(parentPtr) >> (scale * 3);
            pos.x = 1.0 + scale_exp2 * float((ofs & 1) != 0 ? 1.0 : 0.0);
            pos.y = 1.0 + scale_exp2 * float((ofs & 2) != 0 ? 1.0 : 0.0);
            pos.z = 1.0 + scale_exp2 * float((ofs & 4) != 0 ? 1.0 : 0.0);

            // Update idx for current position
            idx = ((pos.x > 1.0) ? 1 : 0) |
                  ((pos.y > 1.0) ? 2 : 0) |
                  ((pos.z > 1.0) ? 4 : 0);

            h = 0.0;
            continue;
        }

        // Fetch current parent node
        uvec2 parent_descriptor = fetchESVONode(parentPtr);
        uint childMask = getChildMask(parent_descriptor);
        uint childOffset = getChildOffset(parent_descriptor);

        // Compute current voxel exit planes
        float tx_corner = pos.x * tx_coef - tx_bias;
        float ty_corner = pos.y * ty_coef - ty_bias;
        float tz_corner = pos.z * tz_coef - tz_bias;
        float tc_max = min(min(tx_corner, ty_corner), tz_corner);

        // Check if current child exists in octree
        int childIndex = idx ^ octant_mask;

        if (childExists(childMask, childIndex) && t_min <= t_max) {
            float tv_max = min(t_max, tc_max);
            float halfScale = scale_exp2 * 0.5;

            if (tc_max * halfScale >= scale_exp2 * t_min) {  // Overlap test

                // Check if this is a leaf
                uint nonLeafMask = getNonLeafMask(parent_descriptor);
                bool isLeaf = childIsLeaf(nonLeafMask, childIndex);

                if (isLeaf) {
                    // Process leaf voxel/brick
                    // Child nodes are stored consecutively, use childIndex to offset
                    uint childPtr = childOffset + uint(childIndex);
                    uvec2 childNode = fetchESVONode(childPtr);

                    // Check for constant material
                    if (isConstant(childNode)) {
                        uint matID = getConstantMaterialID(childNode);
                        Material m = getMaterial(matID);
                        hitColor = m.albedo;

                        // Compute normal based on exit plane
                        vec3 normal = vec3(0.0);
                        if (tx_corner <= tc_max) normal.x = (idx & 1) != 0 ? 1.0 : -1.0;
                        if (ty_corner <= tc_max) normal.y = (idx & 2) != 0 ? 1.0 : -1.0;
                        if (tz_corner <= tc_max) normal.z = (idx & 4) != 0 ? 1.0 : -1.0;
                        hitNormal = normalize(normal);
                        hitT = t_min;
                        return true;
                    }

                    // Process brick
                    uint brickIndex = getBrickOffset(childNode);
                    vec3 leafMin = pos - vec3(scale_exp2);
                    vec3 leafMax = pos;
                    vec3 brickMin = gridMin + (leafMin - 1.0) * gridSize;
                    vec3 brickMax = gridMin + (leafMax - 1.0) * gridSize;

                    uint axisMask;
                    if (marchBrick(rayOrigin, rayDir, t_min * length(gridSize) * 0.5,
                                   brickMin, brickMax, brickIndex, hitColor, hitNormal, axisMask)) {
                        hitT = t_min;
                        return true;
                    }

                    // Skip past empty brick
                    t_min = tv_max;

                } else {
                    // Internal node - PUSH & DESCEND

                    // Compute child center for subdivision
                    float tx_center = halfScale * tx_coef + tx_corner;
                    float ty_center = halfScale * ty_coef + ty_corner;
                    float tz_center = halfScale * tz_coef + tz_corner;

                    // Push far children to stack if they exist
                    if (t_min < tc_max && stackPtr < STACK_SIZE) {
                        // Check all 8 potential children
                        for (int i = 0; i < 8; i++) {
                            if (i == (idx ^ octant_mask)) continue; // Skip current

                            // Check if child exists
                            int child_idx = i ^ octant_mask;
                            if (!childExists(childMask, child_idx)) continue;

                            // Compute child's t-span
                            vec3 child_pos = pos - vec3(scale_exp2);
                            if ((i & 1) != 0) child_pos.x += halfScale;
                            if ((i & 2) != 0) child_pos.y += halfScale;
                            if ((i & 4) != 0) child_pos.z += halfScale;

                            float ctx = (child_pos.x + halfScale) * tx_coef - tx_bias;
                            float cty = (child_pos.y + halfScale) * ty_coef - ty_bias;
                            float ctz = (child_pos.z + halfScale) * tz_coef - tz_bias;
                            float ct_max = min(min(ctx, cty), ctz);

                            // If ray will intersect this child, push it
                            if (ct_max > t_min) {
                                uint push_ptr = childOffset + uint(child_idx);
                                stack[stackPtr].parentPtr = push_ptr;
                                stack[stackPtr].t_max = min(ct_max, t_max);
                                stackPtr++;
                                if (stackPtr >= STACK_SIZE) break;
                            }
                        }
                    }

                    // Descend to near child
                    parentPtr = childOffset + uint(childIndex);

                    // Update position for child level
                    idx = 0;
                    scale--;
                    scale_exp2 = halfScale;

                    if (tx_center > t_min) { idx ^= 1; pos.x += scale_exp2; }
                    else                   { pos.x -= scale_exp2; }
                    if (ty_center > t_min) { idx ^= 2; pos.y += scale_exp2; }
                    else                   { pos.y -= scale_exp2; }
                    if (tz_center > t_min) { idx ^= 4; pos.z += scale_exp2; }
                    else                   { pos.z -= scale_exp2; }

                    t_max = tv_max;
                    h = tc_max;
                    continue;
                }
            }
        }

        // ADVANCE - Move to next sibling voxel
        int step_mask = 0;
        if (tx_corner <= tc_max) { step_mask ^= 1; pos.x -= scale_exp2; }
        if (ty_corner <= tc_max) { step_mask ^= 2; pos.y -= scale_exp2; }
        if (tz_corner <= tc_max) { step_mask ^= 4; pos.z -= scale_exp2; }

        t_min = tc_max;
        idx ^= step_mask;

        // Check if we've exited the parent voxel
        if ((idx & step_mask) != 0) {
            // POP - We need to go back up
            if (stackPtr == 0) break;  // Nothing left to traverse

            stackPtr--;
            parentPtr = stack[stackPtr].parentPtr;
            t_max = stack[stackPtr].t_max;
            scale = int(findMSB(parentPtr)) >> 1;
            scale_exp2 = exp2(-float(scale));

            // Reconstruct position
            int ofs = int(parentPtr) >> (scale * 3);
            pos.x = 1.0 + scale_exp2 * float((ofs & 1) != 0 ? 1.0 : 0.0);
            pos.y = 1.0 + scale_exp2 * float((ofs & 2) != 0 ? 1.0 : 0.0);
            pos.z = 1.0 + scale_exp2 * float((ofs & 4) != 0 ? 1.0 : 0.0);

            idx = ((pos.x > 1.0) ? 1 : 0) |
                  ((pos.y > 1.0) ? 2 : 0) |
                  ((pos.z > 1.0) ? 4 : 0);

            h = 0.0;
        }
    }

    return false;
}

// Basic shading
vec3 shade(vec3 hitColor, vec3 hitNormal, vec3 rayDir) {
    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
    float NdotL = max(dot(hitNormal, lightDir), 0.0);
    vec3 ambient = hitColor * 0.2;
    vec3 diffuse = hitColor * NdotL * 0.8;
    return ambient + diffuse;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(imageSize);
    vec3 rayOrigin = pc.cameraPos;
    vec3 rayDir = getRayDir(uv);

    vec3 color = vec3(0.0);
    vec3 hitColor, hitNormal;
    float hitT;

    // Grid bounds for octree
    vec3 gridMin = vec3(-8.0, -8.0, -8.0);
    vec3 gridMax = vec3(8.0, 8.0, 8.0);

    // Test modes (uncomment one):

    // 1. ESVO octree traversal
    if (traverseOctreeSimple(rayOrigin, rayDir, gridMin, gridMax, hitColor, hitNormal, hitT)) {
        color = shade(hitColor, hitNormal, rayDir);
    }

    // 2. Wall of bricks (fallback test)
    //if (traverseWallOfBricks(rayOrigin, rayDir, hitColor, hitNormal, hitT)) {
    //    color = shade(hitColor, hitNormal, rayDir);
    //}

    // 3. Single brick test
    //vec3 brickMin = vec3(-1.0, -1.0, 2.0);
    //vec3 brickMax = vec3(1.0, 1.0, 4.0);
    //if (traverseSingleBrick(rayOrigin, rayDir, brickMin, brickMax, 0u, hitColor, hitNormal)) {
    //    color = shade(hitColor, hitNormal, rayDir);
    //}

    // Background gradient
    if (all(equal(color, vec3(0.0)))) {
        float t = uv.y;
        color = mix(vec3(0.1, 0.15, 0.3), vec3(0.4, 0.6, 0.8), t);
    }

    imageStore(outputImage, pixelCoords, vec4(color, 1.0));
}