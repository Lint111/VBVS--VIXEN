// VoxelRayMarch.comp
// Compute shader for voxel ray marching (baseline implementation)
//
// Research References:
// - [1] Nousiainen: "Performance comparison on rendering methods for voxel data"
// - [5] Voetter: "Volumetric Ray Tracing with Vulkan"
// - [16] Derin et al.: "BlockWalk" (target for Phase L optimization)
//
// Algorithm: Naive DDA (Digital Differential Analyzer) voxel traversal
// Future: BlockWalk optimization in Phase L for coherent block traversal

#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

// Workgroup size: 8x8 threads per group (64 threads total)
// Optimal for most GPUs, balances occupancy vs register pressure
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BINDINGS
// ============================================================================

// Binding 0: Output image (storage image, write-only)
// NOTE: Shader uses rgba8, swapchain is bgra8 (VK_FORMAT_B8G8R8A8_UNORM)
// This causes validation warnings but hardware typically handles the format difference gracefully
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outputImage;

// Binding 1: Camera data (uniform buffer)
layout(set = 0, binding = 1) uniform CameraData {
    mat4 invProjection;      // Inverse projection matrix
    mat4 invView;            // Inverse view matrix
    vec3 cameraPos;          // Camera world position
    uint gridResolution;     // Voxel grid resolution (32, 64, 128, 256, 512)
} camera;

// Binding 2: Voxel data (3D texture, r8 format)
// NOTE: Phase H will add SSBO-based octree traversal as alternative
layout(set = 0, binding = 2) uniform sampler3D voxelGrid;

// ============================================================================
// CONSTANTS
// ============================================================================

const int MAX_STEPS = 512;           // Maximum ray marching steps
const float EPSILON = 0.001;         // Small value for floating-point comparisons
const vec3 BACKGROUND_COLOR = vec3(0.1, 0.1, 0.2);  // Dark blue-gray
const vec3 LIGHT_DIR = normalize(vec3(1.0, 1.0, 0.5));  // Directional light

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Generate ray direction from screen-space pixel coordinates
// Maps pixel coords → NDC → clip space → world space
vec3 generateRayDirection(ivec2 pixelCoords, ivec2 screenSize) {
    // Convert pixel coords to NDC [-1, 1]
    vec2 ndc = (vec2(pixelCoords) + vec2(0.5)) / vec2(screenSize) * 2.0 - 1.0;

    // Unproject near and far planes to clip space
    vec4 clipNear = vec4(ndc, -1.0, 1.0);  // Near plane (z = -1)
    vec4 clipFar = vec4(ndc, 1.0, 1.0);    // Far plane (z = 1)

    // Transform to view space
    vec4 viewNear = camera.invProjection * clipNear;
    vec4 viewFar = camera.invProjection * clipFar;

    // Perspective divide
    viewNear /= viewNear.w;
    viewFar /= viewFar.w;

    // Transform to world space
    vec4 worldNear = camera.invView * viewNear;
    vec4 worldFar = camera.invView * viewFar;

    // Calculate ray direction (from camera to far plane point)
    return normalize(worldFar.xyz - worldNear.xyz);
}

// Calculate voxel face normal from hit position
// Used for simple diffuse shading
vec3 calculateVoxelNormal(vec3 hitPos, ivec3 voxelPos) {
    // Local position within voxel [0, 1]
    vec3 localPos = hitPos - vec3(voxelPos);

    // Distance from each face (centered at 0.5)
    vec3 absLocalPos = abs(localPos - 0.5);

    // Find which face we hit (maximum component)
    float maxComponent = max(max(absLocalPos.x, absLocalPos.y), absLocalPos.z);

    // Return normal for the hit face
    if (absLocalPos.x == maxComponent) {
        return vec3(sign(localPos.x - 0.5), 0.0, 0.0);
    } else if (absLocalPos.y == maxComponent) {
        return vec3(0.0, sign(localPos.y - 0.5), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(localPos.z - 0.5));
    }
}

// Simple diffuse shading
vec3 shadeVoxel(vec3 normal, vec3 albedo) {
    float diffuse = max(dot(normal, LIGHT_DIR), 0.0);
    vec3 ambient = vec3(0.2);
    return albedo * (ambient + diffuse * 0.8);
}

// ============================================================================
// DDA VOXEL TRAVERSAL
// ============================================================================

// DDA (Digital Differential Analyzer) algorithm
// Based on: "A Fast Voxel Traversal Algorithm" (Amanatides & Woo, 1987)
//
// Efficiently steps through voxels along a ray by tracking the parametric
// distance to the next voxel boundary on each axis (tMax), then advancing
// along the axis with the smallest tMax value.
//
// Variables:
// - tMax: Distance to next voxel boundary per axis
// - tDelta: Distance between voxel boundaries per axis
// - step: Direction to step (+1 or -1 per axis)

vec4 traceRay(vec3 rayOrigin, vec3 rayDir) {
    // Transform ray from world space to grid space
    // Grid is centered at origin in world space, spans [-gridRes/2, gridRes/2]
    // In grid space, coordinates are [0, gridRes]
    float halfGrid = float(camera.gridResolution) * 0.5;
    vec3 gridSpaceOrigin = rayOrigin + vec3(halfGrid);  // Shift to [0, gridRes]

    // If ray starts outside grid, compute intersection with grid bounds
    vec3 gridMin = vec3(0.0);
    vec3 gridMax = vec3(float(camera.gridResolution));

    // Ray-box intersection (AABB)
    vec3 invDir = 1.0 / (rayDir + vec3(EPSILON));
    vec3 t0 = (gridMin - gridSpaceOrigin) * invDir;
    vec3 t1 = (gridMax - gridSpaceOrigin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit = min(min(tmax.x, tmax.y), tmax.z);

    // Check if ray intersects grid at all
    if (tExit < 0.0 || tEnter > tExit) {
        // Ray misses grid entirely (show red for debug)
        return vec4(1.0, 0.0, 0.0, 1.0);  // DEBUG: Red = ray missed grid
    }

    // Start ray at grid entry point (or current position if inside)
    if (tEnter > 0.0) {
        gridSpaceOrigin += rayDir * (tEnter + EPSILON);  // Move to entry point
    }

    // Ray direction signs and inverse
    vec3 raySign = sign(rayDir);
    vec3 rayInvDir = 1.0 / (rayDir + vec3(EPSILON));  // Avoid division by zero

    // Starting voxel (integer coordinates in grid space)
    ivec3 voxelPos = ivec3(floor(gridSpaceOrigin));

    // Step direction per axis (+1 or -1)
    ivec3 step = ivec3(raySign);

    // tMax: parametric distance along ray to next voxel boundary per axis
    vec3 voxelBoundary = vec3(voxelPos) + max(vec3(step), vec3(0.0));
    vec3 tMax = (voxelBoundary - gridSpaceOrigin) * rayInvDir;

    // tDelta: distance along ray between voxel boundaries per axis
    vec3 tDelta = abs(rayInvDir);

    // Ray marching loop
    bool hit = false;
    vec3 hitColor = vec3(0.0);
    vec3 hitNormal = vec3(0.0, 1.0, 0.0);  // Default up vector
    float maxVoxelSeen = 0.0;  // DEBUG: Track max voxel value we sample

    for (int i = 0; i < MAX_STEPS; i++) {
        // Check if current voxel is within grid bounds
        if (all(greaterThanEqual(voxelPos, ivec3(0))) &&
            all(lessThan(voxelPos, ivec3(camera.gridResolution)))) {

            // Convert voxel coords to texture UVW [0, 1]
            vec3 uvw = (vec3(voxelPos) + 0.5) / float(camera.gridResolution);

            // Sample voxel data (r8 format: 0.0 = empty, 1.0 = solid)
            float voxelValue = texture(voxelGrid, uvw).r;
            maxVoxelSeen = max(maxVoxelSeen, voxelValue);  // DEBUG: Track samples

            // Check if voxel is solid (threshold at 0.5)
            if (voxelValue > 0.5) {
                hit = true;

                // Calculate hit position in grid space for normal computation
                // tMax values tell us the parametric distance along the ray to the next boundary
                // We want the smallest tMax (the boundary we just crossed)
                float tHit = min(min(tMax.x - tDelta.x, tMax.y - tDelta.y), tMax.z - tDelta.z);
                vec3 hitPosGridSpace = gridSpaceOrigin + rayDir * tHit;
                hitNormal = calculateVoxelNormal(hitPosGridSpace, voxelPos);

                // Use voxel value as grayscale color (can extend to RGB in Phase H)
                hitColor = vec3(voxelValue);

                break;  // Early termination on first hit
            }
        } else {
            // Ray exited grid bounds - return background
            break;
        }

        // Step to next voxel along the axis with smallest tMax
        // This ensures we always move to the next voxel boundary closest to us
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                // Step along X axis
                voxelPos.x += step.x;
                tMax.x += tDelta.x;
            } else {
                // Step along Z axis
                voxelPos.z += step.z;
                tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                // Step along Y axis
                voxelPos.y += step.y;
                tMax.y += tDelta.y;
            } else {
                // Step along Z axis
                voxelPos.z += step.z;
                tMax.z += tDelta.z;
            }
        }
    }

    // Apply shading if we hit something
    if (hit) {
        vec3 shadedColor = shadeVoxel(hitNormal, hitColor);
        return vec4(shadedColor, 1.0);
    } else {
        // DEBUG: Show if we sampled any non-zero voxels
        if (maxVoxelSeen > 0.01) {
            // We saw some voxels but didn't hit threshold (show cyan)
            return vec4(0.0, 1.0, 1.0, 1.0);  // Cyan = saw voxels but < 0.5 threshold
        }
        // Ray entered grid but all voxels were zero (show green)
        return vec4(0.0, 1.0, 0.0, 1.0);  // Green = entered grid, all voxels zero
    }
}

// ============================================================================
// MAIN
// ============================================================================

void main() {
    // Get pixel coordinates from global invocation ID
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screenSize = imageSize(outputImage);

    // Boundary check (avoid out-of-bounds writes)
    if (pixelCoords.x >= screenSize.x || pixelCoords.y >= screenSize.y) {
        return;
    }

    // DEBUG: Test voxel texture at screen center
    if (pixelCoords.x == screenSize.x / 2 && pixelCoords.y == screenSize.y / 2) {
        // Sample exact center of voxel grid (should be inside sphere)
        vec3 centerUVW = vec3(0.5, 0.5, 0.5);
        float centerVoxel = texture(voxelGrid, centerUVW).r;

        // Show result: white if solid (>0.5), blue if present but weak, black if empty
        if (centerVoxel > 0.5) {
            imageStore(outputImage, pixelCoords, vec4(1.0, 1.0, 1.0, 1.0));  // White = center is solid
        } else if (centerVoxel > 0.01) {
            imageStore(outputImage, pixelCoords, vec4(0.0, 0.0, 1.0, 1.0));  // Blue = weak value
        } else {
            imageStore(outputImage, pixelCoords, vec4(0.0, 0.0, 0.0, 1.0));  // Black = empty
        }
        return;
    }

    // Generate ray direction for this pixel
    vec3 rayDir = generateRayDirection(pixelCoords, screenSize);

    // Trace ray through voxel grid
    vec4 color = traceRay(camera.cameraPos, rayDir);

    // Write final color to output image
    imageStore(outputImage, pixelCoords, color);
}
