// VoxelRayMarch.comp
// Compute shader for voxel ray marching (baseline implementation)
//
// Research References:
// - [1] Nousiainen: "Performance comparison on rendering methods for voxel data"
// - [5] Voetter: "Volumetric Ray Tracing with Vulkan"
// - [16] Derin et al.: "BlockWalk" (target for Phase L optimization)
//
// Algorithm: Naive DDA (Digital Differential Analyzer) voxel traversal
// Future: BlockWalk optimization in Phase L for coherent block traversal

#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

// Workgroup size: 8x8 threads per group (64 threads total)
// Optimal for most GPUs, balances occupancy vs register pressure
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BINDINGS
// ============================================================================

// Binding 0: Output image (storage image, write-only)
// NOTE: Shader uses rgba8, swapchain is bgra8 (VK_FORMAT_B8G8R8A8_UNORM)
// This causes validation warnings but hardware typically handles the format difference gracefully
layout(set = 0, binding = 0) uniform writeonly image2D outputImage;

// Binding 1: Camera data (uniform buffer)
layout(set = 0, binding = 1) uniform CameraData {
    mat4 invProjection;      // Inverse projection matrix
    mat4 invView;            // Inverse view matrix
    vec3 cameraPos;          // Camera world position
    uint gridResolution;     // Voxel grid resolution (32, 64, 128, 256, 512)
} camera;

// Binding 2: Octree nodes (SSBO, read-only)
// Each node is 40 bytes: childOffsets[8] + childMask + leafMask + padding + brickOffset
layout(std430, set = 0, binding = 2) readonly buffer OctreeNodesBuffer {
    uint data[];  // Packed OctreeNode data (40 bytes per node)
} octreeNodes;

// Binding 3: Voxel bricks (SSBO, read-only)
// Each brick is 512 bytes: 8x8x8 dense voxel array
layout(std430, set = 0, binding = 3) readonly buffer VoxelBricksBuffer {
    uint data[];  // Packed VoxelBrick data (128 uints per brick, 4 voxels per uint)
} voxelBricks;

// Binding 4: Material palette (SSBO, read-only)
// Each material is 32 bytes: vec3 albedo, float roughness, float metallic, float emissive, float[2] padding
layout(std430, set = 0, binding = 4) readonly buffer MaterialPaletteBuffer {
    vec4 data[];  // Packed VoxelMaterial data (2 vec4s per material)
} materialPalette;

// ============================================================================
// CONSTANTS
// ============================================================================

const int MAX_STEPS = 512;           // Maximum ray marching steps
const float EPSILON = 0.001;         // Small value for floating-point comparisons
const vec3 BACKGROUND_COLOR = vec3(0.1, 0.1, 0.2);  // Dark blue-gray
const vec3 LIGHT_DIR = normalize(vec3(1.0, 1.0, 0.5));  // Directional light

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Generate ray direction from screen-space pixel coordinates
// Maps pixel coords → NDC → clip space → world space
vec3 generateRayDirection(ivec2 pixelCoords, ivec2 screenSize) {
    // Convert pixel coords to NDC [-1, 1]
    vec2 ndc = (vec2(pixelCoords) + vec2(0.5)) / vec2(screenSize) * 2.0 - 1.0;

    // Unproject near and far planes to clip space
    vec4 clipNear = vec4(ndc, -1.0, 1.0);  // Near plane (z = -1)
    vec4 clipFar = vec4(ndc, 1.0, 1.0);    // Far plane (z = 1)

    // Transform to view space
    vec4 viewNear = camera.invProjection * clipNear;
    vec4 viewFar = camera.invProjection * clipFar;

    // Perspective divide
    viewNear /= viewNear.w;
    viewFar /= viewFar.w;

    // Transform to world space
    vec4 worldNear = camera.invView * viewNear;
    vec4 worldFar = camera.invView * viewFar;

    // Calculate ray direction (from camera to far plane point)
    return normalize(worldFar.xyz - worldNear.xyz);
}

// Calculate voxel face normal from hit position
// Used for simple diffuse shading
vec3 calculateVoxelNormal(vec3 hitPos, ivec3 voxelPos) {
    // Local position within voxel [0, 1]
    vec3 localPos = hitPos - vec3(voxelPos);

    // Distance from each face (centered at 0.5)
    vec3 absLocalPos = abs(localPos - 0.5);

    // Find which face we hit (maximum component)
    float maxComponent = max(max(absLocalPos.x, absLocalPos.y), absLocalPos.z);

    // Return normal for the hit face
    if (absLocalPos.x == maxComponent) {
        return vec3(sign(localPos.x - 0.5), 0.0, 0.0);
    } else if (absLocalPos.y == maxComponent) {
        return vec3(0.0, sign(localPos.y - 0.5), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(localPos.z - 0.5));
    }
}

// Simple diffuse shading
vec3 shadeVoxel(vec3 normal, vec3 albedo) {
    float diffuse = max(dot(normal, LIGHT_DIR), 0.0);
    vec3 ambient = vec3(0.2);
    return albedo * (ambient + diffuse * 0.8);
}

// ============================================================================
// OCTREE DATA ACCESS
// ============================================================================

// OctreeNode accessor functions
// Memory layout: childOffsets[8] (32 bytes) + childMask (1 byte) + leafMask (1 byte) + padding (2 bytes) + brickOffset (4 bytes) = 40 bytes
// Packed as 10 uints per node

uint getChildOffset(uint nodeIndex, uint childIndex) {
    uint baseOffset = nodeIndex * 10;  // 10 uints per node (40 bytes)
    return octreeNodes.data[baseOffset + childIndex];
}

uint getChildMask(uint nodeIndex) {
    uint baseOffset = nodeIndex * 10;
    uint packed = octreeNodes.data[baseOffset + 8];  // childMask + leafMask + padding
    return packed & 0xFF;  // Extract childMask (byte 0)
}

uint getLeafMask(uint nodeIndex) {
    uint baseOffset = nodeIndex * 10;
    uint packed = octreeNodes.data[baseOffset + 8];
    return (packed >> 8) & 0xFF;  // Extract leafMask (byte 1)
}

uint getBrickOffset(uint nodeIndex) {
    uint baseOffset = nodeIndex * 10;
    return octreeNodes.data[baseOffset + 9];
}

bool hasChild(uint childMask, uint childIndex) {
    return (childMask & (1u << childIndex)) != 0u;
}

bool isLeaf(uint leafMask, uint childIndex) {
    return (leafMask & (1u << childIndex)) != 0u;
}

// VoxelBrick accessor
// Each brick is 8x8x8 = 512 bytes = 128 uints (4 voxels packed per uint)
uint getVoxelFromBrick(uint brickIndex, ivec3 localPos) {
    uint baseOffset = brickIndex * 128;  // 128 uints per brick
    uint voxelIndex = uint(localPos.z * 64 + localPos.y * 8 + localPos.x);  // 0-511
    uint uintIndex = voxelIndex / 4u;  // 4 voxels per uint
    uint byteIndex = voxelIndex % 4u;

    uint packed = voxelBricks.data[baseOffset + uintIndex];
    return (packed >> (byteIndex * 8u)) & 0xFFu;  // Extract byte
}

// Material accessor
// Each material is 32 bytes = 8 floats = 2 vec4s
// Layout: vec3 albedo + float roughness + float metallic + float emissive + float[2] padding
struct Material {
    vec3 albedo;
    float roughness;
    float metallic;
    float emissive;
};

Material getMaterial(uint materialID) {
    uint baseOffset = materialID * 2u;  // 2 vec4s per material
    vec4 data0 = materialPalette.data[baseOffset];
    vec4 data1 = materialPalette.data[baseOffset + 1u];

    Material mat;
    mat.albedo = data0.xyz;
    mat.roughness = data0.w;
    mat.metallic = data1.x;
    mat.emissive = data1.y;
    return mat;
}

// Compute child octant index from position within node bounds
// Returns 0-7 based on which octant the position falls into
uint getChildOctant(vec3 posInNode) {
    uvec3 octant = uvec3(greaterThanEqual(posInNode, vec3(0.5)));
    return octant.x + octant.y * 2u + octant.z * 4u;
}

// ============================================================================
// OCTREE TRAVERSAL
// ============================================================================

// Octree-based ray traversal with DDA optimization
// Combines hierarchical octree descent with empty-space skipping (childMask)
// Based on [16] Derin et al. BlockWalk algorithm

vec4 traceRay(vec3 rayOrigin, vec3 rayDir) {
    // Transform ray from world space to grid space
    // Grid is centered at origin in world space, spans [-gridRes/2, gridRes/2]
    // In grid space, coordinates are [0, gridRes]
    float halfGrid = float(camera.gridResolution) * 0.5;
    vec3 gridSpaceOrigin = rayOrigin + vec3(halfGrid);  // Shift to [0, gridRes]

    // Ray-box intersection with grid bounds
    vec3 gridMin = vec3(0.0);
    vec3 gridMax = vec3(float(camera.gridResolution));

    vec3 invDir = 1.0 / (rayDir + vec3(EPSILON));
    vec3 t0 = (gridMin - gridSpaceOrigin) * invDir;
    vec3 t1 = (gridMax - gridSpaceOrigin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit = min(min(tmax.x, tmax.y), tmax.z);

    // Check if ray intersects grid at all
    if (tExit < 0.0 || tEnter > tExit) {
        return vec4(BACKGROUND_COLOR, 1.0);  // Ray missed grid
    }

    // Start ray at grid entry point (or current position if inside)
    vec3 rayPos = gridSpaceOrigin;
    if (tEnter > 0.0) {
        rayPos += rayDir * (tEnter + EPSILON);
    }

    // Normalize position to [0, 1] for octree traversal
    vec3 normalizedPos = rayPos / float(camera.gridResolution);

    // Traversal stack: stores (nodeIndex, nodeMin, nodeSize) for each depth level
    // Maximum depth = 8 (256³ grid = 2^8), so we need 8+1 = 9 stack levels (depth 0-8)
    const int MAX_DEPTH = 9;
    uint nodeStack[MAX_DEPTH];
    vec3 minStack[MAX_DEPTH];
    float sizeStack[MAX_DEPTH];
    int stackPtr = 0;

    // Push root node (depth 0, full grid)
    nodeStack[0] = 0u;  // Root node index
    minStack[0] = vec3(0.0);
    sizeStack[0] = 1.0;

    // Ray marching loop
    bool hit = false;
    vec3 hitColor = vec3(1.0, 0.0, 1.0);  // Magenta debug color
    vec3 hitNormal = vec3(0.0, 1.0, 0.0);

    for (int iter = 0; iter < MAX_STEPS && stackPtr >= 0; iter++) {
        // Pop current node from stack
        uint nodeIndex = nodeStack[stackPtr];
        vec3 nodeMin = minStack[stackPtr];
        float nodeSize = sizeStack[stackPtr];
        stackPtr--;

        // Check if ray still inside current node bounds
        vec3 nodeMax = nodeMin + vec3(nodeSize);
        if (any(lessThan(normalizedPos, nodeMin)) || any(greaterThanEqual(normalizedPos, nodeMax))) {
            continue;  // Ray exited this node, skip it
        }

        // Read node data
        uint childMask = getChildMask(nodeIndex);
        uint leafMask = getLeafMask(nodeIndex);

        // Compute which child octant we're in
        vec3 posInNode = (normalizedPos - nodeMin) / nodeSize;  // [0, 1] within node
        uint octantIndex = getChildOctant(posInNode);

        // Check if child exists (empty-space skipping via childMask)
        if (!hasChild(childMask, octantIndex)) {
            continue;  // Empty child, skip
        }

        // Compute child bounds
        vec3 octantMin = nodeMin + vec3(uvec3(octantIndex & 1u, (octantIndex >> 1u) & 1u, (octantIndex >> 2u) & 1u)) * (nodeSize * 0.5);
        float childSize = nodeSize * 0.5;

        // Check if child is a leaf brick
        if (isLeaf(leafMask, octantIndex)) {
            // Leaf brick - sample voxel data
            uint brickOffset = getBrickOffset(nodeIndex);
            if (brickOffset == 0u) continue;  // Invalid brick

            // Convert normalized position to brick-local coordinates [0, 8)
            vec3 posInBrick = (normalizedPos - octantMin) / childSize * 8.0;
            ivec3 voxelPos = ivec3(floor(posInBrick));

            // Bounds check within brick
            if (all(greaterThanEqual(voxelPos, ivec3(0))) && all(lessThan(voxelPos, ivec3(8)))) {
                uint voxelValue = getVoxelFromBrick(brickOffset, voxelPos);

                // Check if voxel is solid (non-zero = solid)
                if (voxelValue > 0u) {
                    hit = true;

                    // Get material and apply shading
                    Material mat = getMaterial(voxelValue);

                    // Calculate voxel normal (approximate - use face we entered)
                    vec3 localPos = posInBrick - vec3(voxelPos);
                    hitNormal = calculateVoxelNormal(localPos, ivec3(0));

                    hitColor = shadeVoxel(hitNormal, mat.albedo);
                    break;
                }
            }
        } else {
            // Internal node - descend into child
            uint childOffset = getChildOffset(nodeIndex, octantIndex);
            if (childOffset == 0u) continue;  // Invalid child

            // Push child onto stack
            stackPtr++;
            if (stackPtr >= MAX_DEPTH) break;  // Stack overflow protection

            nodeStack[stackPtr] = childOffset;
            minStack[stackPtr] = octantMin;
            sizeStack[stackPtr] = childSize;
        }

        // Advance ray position slightly to avoid re-hitting same voxel
        normalizedPos += rayDir * (EPSILON / float(camera.gridResolution));

        // Exit if we left the grid
        if (any(lessThan(normalizedPos, vec3(0.0))) || any(greaterThanEqual(normalizedPos, vec3(1.0)))) {
            break;
        }
    }

    if (hit) {
        return vec4(hitColor, 1.0);
    } else {
        return vec4(BACKGROUND_COLOR, 1.0);
    }
}

// ============================================================================
// MAIN
// ============================================================================

void main() {
    // Get pixel coordinates from global invocation ID
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screenSize = imageSize(outputImage);

    // Boundary check (avoid out-of-bounds writes)
    if (pixelCoords.x >= screenSize.x || pixelCoords.y >= screenSize.y) {
        return;
    }

    // Generate ray direction for this pixel
    vec3 rayDir = generateRayDirection(pixelCoords, screenSize);

    // Trace ray through octree
    vec4 color = traceRay(camera.cameraPos, rayDir);

    // Write final color to output image
    imageStore(outputImage, pixelCoords, color);
}
