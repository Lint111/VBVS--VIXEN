// VoxelRayMarch.comp
// Hierarchical octree-based voxel ray marching with empty-space skipping and brick-local DDA
//
// Research References:
// - [1] Nousiainen: "Performance comparison on rendering methods for voxel data"
// - [5] Voetter: "Volumetric Ray Tracing with Vulkan"
// - [16] Derin et al.: "BlockWalk" (target for later block-level optimization)
//
// Notes:
// - Traversal: Ray-guided descent; if child octant empty, jump to exit plane (skipDistance)
// - Leaves: 8^3 bricks; inside-brick traversal uses parametric 3D DDA for exact face stepping
// - Debug: Optional overlays via VOXEL_RAY_DEBUG_* macros; default path returns shaded material
// - Background: Dark blue-gray; can be replaced with sky or GI later
//
// BUGFIXES (Session 011CV1brWkQo6n5aK7nTUKFg):
// - Fixed division-by-zero handling in ray-AABB intersection (use large value, not direction modification)
// - ESVO traversal maintains proper coordinate system consistency via [1,2] space transform

#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

// ESVO traversal inlined below (lines 253-391)
// Full algorithm based on NVIDIA Laine & Karras 2010

// Workgroup size: 8x8 threads per group (64 threads total)
// Optimal for most GPUs, balances occupancy vs register pressure
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BINDINGS
// ============================================================================

// Binding 0: Output image (storage image, write-only)
// NOTE: Shader uses rgba8, swapchain is bgra8 (VK_FORMAT_B8G8R8A8_UNORM)
// This causes validation warnings but hardware typically handles the format difference gracefully
layout(set = 0, binding = 0) uniform writeonly image2D outputImage;

// Binding 1: Camera data (uniform buffer)
layout(set = 0, binding = 1) uniform CameraData {
    mat4 invProjection;      // Inverse projection matrix
    mat4 invView;            // Inverse view matrix
    vec3 cameraPos;          // Camera world position
    uint gridResolution;     // Voxel grid resolution (32, 64, 128, 256, 512)
    float lodBias;           // LOD bias (0.5 = finer, 1.0 = default, 2.0 = coarser)
    float padding[3];        // Align to 16 bytes
} camera;

// Binding 2: Octree nodes (SSBO, read-only)
// ESVO format: 8 bytes per node (descriptor0 + descriptor1)
layout(std430, set = 0, binding = 2) readonly buffer OctreeNodesBuffer {
    uint data[];  // Packed ESVONode data (2 uints per node = 8 bytes)
} octreeNodes;

// Binding 3: Voxel bricks (SSBO, read-only)
// Each brick is 512 bytes: 8x8x8 dense voxel array
layout(std430, set = 0, binding = 3) readonly buffer VoxelBricksBuffer {
    uint data[];  // Packed VoxelBrick data (128 uints per brick, 4 voxels per uint)
} voxelBricks;

// Binding 4: Material palette (SSBO, read-only)
// Each material is 32 bytes: vec3 albedo, float roughness, float metallic, float emissive, float[2] padding
layout(std430, set = 0, binding = 4) readonly buffer MaterialPaletteBuffer {
    vec4 data[];  // Packed VoxelMaterial data (2 vec4s per material)
} materialPalette;

// ============================================================================
// CONSTANTS
// ============================================================================

// Step/bounce controls
// Only strictly limit ray bounces; graph traversal should run to completion (bounded by root AABB intersection)
const int MAX_OCTREE_ITERS = 250;     // Generous cap for per-position octree descent
const int MAX_RAY_STEPS = 1000;        // Safety cap for main ray march loop iterations
const int RAY_MAX_BOUNCES = 1;        // Ray bounces (set >1 for future GI); current shader exits on first hit

const float EPSILON = 0.001;         // Small value for floating-point comparisons
const float SURFACE_EPS = 0.0005;    // Epsilon used to avoid re-hitting boundary planes
const vec3 BACKGROUND_COLOR = vec3(0.1, 0.1, 0.2);  // Dark blue-gray
const vec3 LIGHT_DIR = normalize(vec3(1.0, 1.0, 0.5));  // Directional light

// Optional debug: visualize brick boundaries (set to 1 to enable)
#ifndef VOXEL_RAY_DEBUG_BRICK_BOUNDARY
#define VOXEL_RAY_DEBUG_BRICK_BOUNDARY 0
#endif

// Optional debug: visualize spatial regions & traversal depth (set to 1 to enable)
#ifndef VOXEL_RAY_DEBUG_SPATIAL
#define VOXEL_RAY_DEBUG_SPATIAL 0
#endif

// Optional debug: visualize material IDs and voxel coordinates (set to 1 to enable)
#ifndef VOXEL_RAY_DEBUG_MATERIAL_ID
#define VOXEL_RAY_DEBUG_MATERIAL_ID 0
#endif

// Optional debug: visualize local voxel coordinates in brick as RGB
#ifndef VOXEL_RAY_DEBUG_LOCAL_COORD
#define VOXEL_RAY_DEBUG_LOCAL_COORD 0
#endif

// Optional debug: visualize coordinate clamping (set to 1 to enable)
#ifndef VOXEL_RAY_DEBUG_CLAMP
#define VOXEL_RAY_DEBUG_CLAMP 0
#endif

// Debug: color final hit (or diagnostic) by which axis (or axes) were last advanced in brick DDA
#ifndef VOXEL_RAY_DEBUG_AXIS_STEP
#define VOXEL_RAY_DEBUG_AXIS_STEP 0
#endif

// Debug: color entire brick by its occupancy ratio (expensive 512-voxel scan) for sparsity diagnosis
#ifndef VOXEL_RAY_DEBUG_BRICK_OCCUPANCY
#define VOXEL_RAY_DEBUG_BRICK_OCCUPANCY 0
#endif

// Optional: use alternative half-open interval mapping for initial voxel index with tiny inward bias
#ifndef VOXEL_RAY_ALT_INITIAL_VOXEL
#define VOXEL_RAY_ALT_INITIAL_VOXEL 1
#endif

// Enable multi-axis advancement when tMax ties occur (prevents checker/X patterns at axis-aligned junctions)
#ifndef VOXEL_RAY_USE_MULTI_AXIS_TIES
#define VOXEL_RAY_USE_MULTI_AXIS_TIES 1
#endif

// Enable 3D supercover processing: when multiple voxel boundaries are crossed simultaneously,
// advance one axis at a time and test after each sub-step to avoid skipping thin features and
// diagonal 'X' seam artifacts at wall junctions.
#ifndef VOXEL_RAY_SUPERCOVER_TIES
#define VOXEL_RAY_SUPERCOVER_TIES 1
#endif

// Debug: exhaustively test all 8 children at each node to detect missed siblings (expensive)
#ifndef VOXEL_RAY_DEBUG_EXHAUSTIVE_CHILDREN
#define VOXEL_RAY_DEBUG_EXHAUSTIVE_CHILDREN 0
#endif

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Generate ray direction from screen-space pixel coordinates
// Simpler direct approach using view space ray construction
vec3 generateRayDirection(ivec2 pixelCoords, ivec2 screenSize) {
    // Convert pixel coords to NDC [-1, 1]
    vec2 uv = (vec2(pixelCoords) + vec2(0.5)) / vec2(screenSize);
    vec2 ndc = uv * 2.0 - 1.0;
    ndc.y = -ndc.y;  // Flip Y for Vulkan

    // Create view-space ray direction
    // For a perspective projection, the view-space ray goes from origin to a point on the near plane
    // The xy coordinates on the near plane are determined by the NDC and the projection matrix

    // Method: Transform NDC through invProjection to get view-space direction
    vec4 target = camera.invProjection * vec4(ndc.x, ndc.y, 1.0, 1.0);
    vec3 viewDir = normalize(target.xyz / target.w);

    // Transform view-space direction to world space using rotation part of invView
    vec3 rayDir = normalize(mat3(camera.invView) * viewDir);

    return rayDir;
}

// Calculate voxel face normal from hit position
// Used for simple diffuse shading
vec3 calculateVoxelNormal(vec3 hitPos, ivec3 voxelPos) {
    // Local position within voxel [0, 1]
    vec3 localPos = hitPos - vec3(voxelPos);

    // Distance from each face (centered at 0.5)
    vec3 absLocalPos = abs(localPos - 0.5);

    // Find which face we hit (maximum component)
    float maxComponent = max(max(absLocalPos.x, absLocalPos.y), absLocalPos.z);

    // Return normal for the hit face
    if (absLocalPos.x == maxComponent) {
        return vec3(sign(localPos.x - 0.5), 0.0, 0.0);
    } else if (absLocalPos.y == maxComponent) {
        return vec3(0.0, sign(localPos.y - 0.5), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(localPos.z - 0.5));
    }
}

// Simple diffuse shading
vec3 shadeVoxel(vec3 normal, vec3 albedo) {
    float diffuse = max(dot(normal, LIGHT_DIR), 0.0);
    vec3 ambient = vec3(0.2);
    return albedo * (ambient + diffuse * 0.8);
}

// ============================================================================
// ESVO NODE DATA ACCESS
// ============================================================================

// ESVONode accessor functions
// Memory layout: descriptor0 (32 bits) + descriptor1 (32 bits) = 8 bytes total
// Packed as 2 uints per node

// Fetch ESVO node descriptor pair
uvec2 fetchESVONode(uint nodeIndex) {
    uint baseOffset = nodeIndex * 2u;  // 2 uints per node (8 bytes)
    return uvec2(
        octreeNodes.data[baseOffset],      // descriptor0
        octreeNodes.data[baseOffset + 1u]  // descriptor1
    );
}

// Extract child existence mask (8 bits from descriptor0)
// ChildMask is at bits 8-15 in FORWARD order:
// child[0] at bit 8, child[1] at bit 9, ..., child[7] at bit 15
uint getChildMask(uvec2 node) {
    return (node.x >> 8) & 0xFFu;  // Bits 8-15
}

// Extract non-leaf mask (7 bits from descriptor0)
uint getNonLeafMask(uvec2 node) {
    return (node.x >> 1) & 0x7Fu;
}

// Check if child exists
bool hasChild(uvec2 node, uint childIndex) {
    uint mask = getChildMask(node);
    return (mask & (1u << childIndex)) != 0u;
}

// Check if child is leaf (brick)
bool isLeaf(uvec2 node, uint childIndex) {
    if (childIndex >= 7u) return true;  // Child 7 has no non-leaf bit
    uint mask = getNonLeafMask(node);
    return (mask & (1u << childIndex)) == 0u;
}

// Get child offset (15 bits from descriptor0)
uint getChildOffset(uvec2 node) {
    return (node.x >> 17) & 0x7FFFu;
}

// Check if using far pointer
bool isFarPointer(uvec2 node) {
    return (node.x & 0x10000u) != 0u;
}

// Get brick offset (31 bits from descriptor1)
uint getBrickOffset(uvec2 node) {
    return node.y & 0x7FFFFFFFu;
}

// Check if node is constant (homogeneous region)
bool isConstant(uvec2 node) {
    return (node.y & 0x80000000u) != 0u;
}

// Extract constant material ID from descriptor1 (low 8 bits) when constant flag set
uint getConstantMaterialID(uvec2 node) {
    return node.y & 0xFFu; // Low 8 bits store material ID
}

// Get combined child masks (for ESVO traversal)
int getCombinedMasks(uvec2 node, uint childIndex) {
    int child_shift = int(childIndex);
    return int(node.x) << child_shift;
}

// VoxelBrick accessor
// Each brick is 8x8x8 = 512 bytes (unpacked, 1 byte per voxel)
// Uploaded as flat uint8 array, accessed as uint array (4 voxels per uint read)
uint getVoxelFromBrick(uint brickIndex, ivec3 localPos) {
    uint baseOffset = brickIndex * 128;  // 128 uints per brick (512 bytes / 4)
    uint voxelIndex = uint(localPos.z * 64 + localPos.y * 8 + localPos.x);  // 0-511
    uint byteIndex = voxelIndex % 4u;  // Which byte within the uint (0-3)

    // Read the uint containing this voxel
    uint packed = voxelBricks.data[baseOffset + (voxelIndex / 4u)];
    return (packed >> (byteIndex * 8u)) & 0xFFu;  // Extract byte
}

// Material accessor
// Each material is 32 bytes = 8 floats = 2 vec4s
// Layout: vec3 albedo + float roughness + float metallic + float emissive + float[2] padding
struct Material {
    vec3 albedo;
    float roughness;
    float metallic;
    float emissive;
};

Material getMaterial(uint materialID) {
    uint baseOffset = materialID * 2u;  // 2 vec4s per material
    vec4 data0 = materialPalette.data[baseOffset];
    vec4 data1 = materialPalette.data[baseOffset + 1u];

    Material mat;
    mat.albedo = data0.xyz;
    mat.roughness = data0.w;
    mat.metallic = data1.x;
    mat.emissive = data1.y;
    return mat;
}

// Compute child octant index from position within node bounds
// Returns 0-7 based on which octant the position falls into
uint getChildOctant(vec3 posInNode) {
    uvec3 octant = uvec3(greaterThanEqual(posInNode, vec3(0.5)));
    return octant.x + octant.y * 2u + octant.z * 4u;
}

// ============================================================================
// OCTREE TRAVERSAL (ESVO Algorithm)
// ============================================================================

// Forward declaration for brick DDA used by traversal
bool marchBrick(vec3 rayOrigin, vec3 rayDir, float tStart, vec3 brickMin, vec3 brickMax,
                uint brickOffset, out vec3 hitColor, out vec3 hitNormal, out uint axisMaskOut);

// Octree traversal using ESVO format + brick DDA
// Combines hierarchical descent (child masks) with precise voxel stepping in leaf bricks.
// Empty-space skipping implemented by advancing ray directly to node AABB exit.

// Ray-AABB intersection helper
// Returns (tEnter, tExit) for ray-box intersection, or (-1, -1) if no hit
// FIXED (Session 011CV1brWkQo6n5aK7nTUKFg): Safe division handling
// Uses large value for near-zero components to avoid direction modification
vec2 rayAABBIntersectionFast(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    float tmin = 0.0;
    float tmax = 1e30;

    for (int i = 0; i < 3; ++i) {
        float d = (i == 0) ? rayDir.x : (i == 1) ? rayDir.y : rayDir.z;
        float o = (i == 0) ? rayOrigin.x : (i == 1) ? rayOrigin.y : rayOrigin.z;
        float bmin = (i == 0) ? boxMin.x : (i == 1) ? boxMin.y : boxMin.z;
        float bmax = (i == 0) ? boxMax.x : (i == 1) ? boxMax.y : boxMax.z;

        if (abs(d) > 1e-8) {
            float t1 = (bmin - o) / d;
            float t2 = (bmax - o) / d;
            tmin = max(tmin, min(t1, t2));
            tmax = min(tmax, max(t1, t2));
        } else {
            // Ray parallel to slab - check if origin is inside
            if (o < bmin || o > bmax) {
                return vec2(-1.0, -1.0);
            }
        }
    }

    if (tmin > tmax || tmax < 0.0) {
        return vec2(-1.0, -1.0);
    }

    return vec2(max(tmin, 0.0), tmax);
}

// Slab method ray-AABB intersection
// FIXED (Session 011CV1brWkQo6n5aK7nTUKFg): Use infinity for near-zero components
// Division by zero yields infinity in IEEE 754, which is correct for AABB tests
// Avoids modifying rayDir which caused far-distance intersection failures
vec2 rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    // Safe inverse: return large value for near-zero components
    // Changed from sign-based approximation to avoid direction modification
    vec3 invDir = vec3(
        abs(rayDir.x) < 1e-8 ? 1e10 : 1.0 / rayDir.x,
        abs(rayDir.y) < 1e-8 ? 1e10 : 1.0 / rayDir.y,
        abs(rayDir.z) < 1e-8 ? 1e10 : 1.0 / rayDir.z
    );

    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;

    vec3 tmin3 = min(t0, t1);
    vec3 tmax3 = max(t0, t1);

    float tmin = max(max(tmin3.x, tmin3.y), tmin3.z);
    float tmax = min(min(tmax3.x, tmax3.y), tmax3.z);

    if (tmin > tmax || tmax < 0.0) {
        return vec2(-1.0, -1.0);
    }

    return vec2(max(tmin, 0.0), tmax);
}

// Full ESVO octree traversal (production algorithm)
// Based on NVIDIA's Efficient Sparse Voxel Octree (Laine & Karras 2010)
bool traverseOctreeSimple(vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                          out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    // ESVO traversal state
    // IMPORTANT: Our host-side BFS builder currently produces a maximum depth of 5
    // (root depth=0, leaves at depth=4 with 8x8x8 bricks). The reference ESVO
    // algorithm uses S_MAX=23 for deep production trees, but keeping that value here
    // makes scale_exp2 vastly smaller than our actual leaf size, collapsing bricks
    // to a thin slice in world reconstruction. We therefore match S_MAX to the
    // actual tree depth (5) so that leafMin/leafMax mapping (pos - scale_exp2, pos)
    // spans the correct region. TODO: Parameterize S_MAX via a uniform when deeper
    // trees are introduced.
    const int S_MAX = 5;
    const float EPSILON_ESVO = exp2(-float(S_MAX));
    // TEMP SCALE PATCH: double leaf extent (see Phase H note)
    // LEAF_SCALE_FACTOR was temporarily set to 2.0 which doubled leaf AABB size, causing
    // overlapping bricks and visible X/diagonal artifacts at wall junctions. Reverting
    // to 1.0 so leaf extent = scale_exp2 (canonical ESVO half/open interval mapping).
    const float LEAF_SCALE_FACTOR = 1.0;

    // LOD parameters (from camera uniform)
    // Disable LOD termination for Phase H - show full detail everywhere
    float raySizeCoef = 0.0;  // Disabled: was camera.lodBias
    float raySizeBias = 0.0;

    // World-space AABB test first
    vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);
    if (gridT.y < 0.0) {
        return false;  // Ray missed grid
    }

    // Transform ray to [1,2] octree space (ESVO convention)
    vec3 gridSize = gridMax - gridMin;

    // CRITICAL: If camera is outside grid, advance ray to grid entry point
    // This ensures we start ESVO traversal at the grid boundary, not from far outside
    vec3 rayStartWorld = rayOrigin;
    if (gridT.x > 0.0) {
        // Camera outside grid - start ray at entry point
        rayStartWorld = rayOrigin + rayDir * max(gridT.x, 0.0);
    }

    // Transform ray origin to [0,1] normalized grid space, then shift to [1,2]
    vec3 p = ((rayStartWorld - gridMin) / gridSize) + 1.0;

    // ESVO requires normalized direction in the [1,2] cube space
    vec3 d = normalize(rayDir);

    // Avoid division by zero
    if (abs(d.x) < EPSILON_ESVO) d.x = sign(d.x) * EPSILON_ESVO;
    if (abs(d.y) < EPSILON_ESVO) d.y = sign(d.y) * EPSILON_ESVO;
    if (abs(d.z) < EPSILON_ESVO) d.z = sign(d.z) * EPSILON_ESVO;

    // Parametric plane coefficients
    float tx_coef = 1.0 / -abs(d.x);
    float ty_coef = 1.0 / -abs(d.y);
    float tz_coef = 1.0 / -abs(d.z);
    float tx_bias = tx_coef * p.x;
    float ty_bias = ty_coef * p.y;
    float tz_bias = tz_coef * p.z;

    // Octant mirroring (unify ray direction to always negative)
    int octant_mask = 7;
    if (d.x > 0.0) { octant_mask ^= 1; tx_bias = 3.0 * tx_coef - tx_bias; }
    if (d.y > 0.0) { octant_mask ^= 2; ty_bias = 3.0 * ty_coef - ty_bias; }
    if (d.z > 0.0) { octant_mask ^= 4; tz_bias = 3.0 * tz_coef - tz_bias; }

    // Ray-octree intersection (active t-span)
    // Note: t values are in ESVO [1,2] space, not world space
    float t_min = max(max(2.0 * tx_coef - tx_bias, 2.0 * ty_coef - ty_bias), 2.0 * tz_coef - tz_bias);
    float t_max = min(min(tx_coef - tx_bias, ty_coef - ty_bias), tz_coef - tz_bias);
    t_min = max(t_min, 0.0);
    t_max = min(t_max, 1.0);

    if (t_min >= t_max) {
        return false;  // Ray missed octree in [1,2] space
    }

    // Traversal state
    uint parentPtr = 0u;                 // Current node index at this scale
    uvec2 child_descriptor = uvec2(0u, 0u);
    // Minimal parent pointer stack for ascending (Phase H baseline)
    const int PTR_STACK_MAX = 48;
    uint parentPtrStack[PTR_STACK_MAX];
    int ptrTop = -1;
    int idx = 0;
    vec3 pos = vec3(1.0);
    int scale = S_MAX - 1;
    float scale_exp2 = 0.5;

    // Select initial child octant
    if (1.5 * tx_coef - tx_bias > t_min) { idx ^= 1; pos.x = 1.5; }
    if (1.5 * ty_coef - ty_bias > t_min) { idx ^= 2; pos.y = 1.5; }
    if (1.5 * tz_coef - tz_bias > t_min) { idx ^= 4; pos.z = 1.5; }

    // Main traversal loop (PUSH/POP/ADVANCE)
    const int MAX_ITERS = 250;
    for (int iter = 0; iter < MAX_ITERS && scale < S_MAX; ++iter) {
        // Early exit if ray has left the grid entirely
        // Check if t_min exceeds the grid exit point
        if (t_min > t_max) {
            break;  // Ray exited grid
        }

        // FETCH: Load child descriptor if not cached
        if (child_descriptor.x == 0u) {
            child_descriptor = fetchESVONode(parentPtr);
        }

        // INTERSECT: Compute voxel boundaries
        float tx_corner = pos.x * tx_coef - tx_bias;
        float ty_corner = pos.y * ty_coef - ty_bias;
        float tz_corner = pos.z * tz_coef - tz_bias;
        float tc_max = min(min(tx_corner, ty_corner), tz_corner);

    // Check if child exists and t-span non-empty using ESVO combined-mask logic
    int child_shift = idx ^ octant_mask;
    int child_masks = int(child_descriptor.x) << child_shift;
    bool childExists = (child_masks & 0x8000) != 0; // Bit 15 after shift = valid_mask for this child

    if (childExists && t_min <= t_max) {
            // LOD TERMINATION: Stop if voxel small enough
            if (tc_max * raySizeCoef + raySizeBias >= scale_exp2) {
                // LOD termination: sample the actual CHILD node's brick
                uint childIdx = uint(idx ^ octant_mask);
                uint childNodeOffset = getChildOffset(child_descriptor);
                uint childPtr = childNodeOffset + childIdx;
                uvec2 childNode = fetchESVONode(childPtr);

                // If constant region, shade directly without brick traversal
                if (isConstant(childNode)) {
                    uint matID = getConstantMaterialID(childNode);
                    Material m = getMaterial(matID);
                    vec3 leafMin = vec3(pos) - vec3(scale_exp2 * LEAF_SCALE_FACTOR);
                    vec3 leafMax = vec3(pos);
                    // Basic face normal approximation from ray direction
                    vec3 approxNormal = normalize(-rayDir);
                    hitNormal = approxNormal;
                    hitColor = m.albedo;
                    hitT = t_min;
                    return true;
                } else {
                    uint brickIndex = getBrickOffset(childNode);
                    vec3 leafMin = vec3(pos) - vec3(scale_exp2 * LEAF_SCALE_FACTOR);
                    vec3 leafMax = vec3(pos);
                    vec3 brickMin = gridMin + (leafMin - 1.0) * gridSize;
                    vec3 brickMax = gridMin + (leafMax - 1.0) * gridSize;
                    uint axisMaskDummy;
                    if (marchBrick(rayOrigin, rayDir, 0.0, brickMin, brickMax, brickIndex, hitColor, hitNormal, axisMaskDummy)) {
                        hitT = t_min;
                        return true;
                    }
#if defined(VOXEL_RAY_DEBUG_BRICK_AABB)
                    else {
                        // Visualize empty brick bounds: encode (leafMin.xy, scale) into color (normalized)
                        vec3 debugColor = vec3(leafMin.x - 1.0, leafMin.y - 1.0, scale_exp2);
                        // Normalize to safe display range
                        debugColor = abs(normalize(debugColor + vec3(1e-6)));
                        hitColor = debugColor;
                        hitNormal = normalize(-rayDir);
                        hitT = t_min;
                        return true;
                    }
#endif
                }
                // Miss within brick or constant region -> continue traversal
            }

            // INTERSECT: Narrow t-span to voxel interior
            float tv_max = min(t_max, tc_max);
            float halfScale = scale_exp2 * 0.5;
            float tx_center = halfScale * tx_coef + tx_corner;
            float ty_center = halfScale * ty_coef + ty_corner;
            float tz_center = halfScale * tz_coef + tz_corner;

            // PUSH: Descend to child if non-empty t-span
            if (t_min <= tv_max) {
                // Check if child is a leaf using explicit non-leaf mask.
                // Combined-mask shifting aligns the valid bit to 15, but non-leaf bits
                // live in descriptor0 bits 1..7 (for children 0..6). Shifting by child index
                // does not align them to a fixed position, so test directly from the mask.
                uint childIdxPush = uint(idx ^ octant_mask);
                uint nonLeafMask = getNonLeafMask(child_descriptor);
                bool isLeaf = (childIdxPush >= 7u) ? true : ((nonLeafMask & (1u << childIdxPush)) == 0u);

                if (isLeaf) {
                    // Leaf node: sample brick from the CHILD node descriptor
                    uint childNodeOffset = getChildOffset(child_descriptor);
                    uint childPtr = childNodeOffset + childIdxPush;
                    uvec2 childNode = fetchESVONode(childPtr);
                    if (isConstant(childNode)) {
                        uint matID = getConstantMaterialID(childNode);
                        Material m = getMaterial(matID);
                        vec3 approxNormal = normalize(-rayDir);
                        hitColor = m.albedo;
                        hitNormal = approxNormal;
                        hitT = t_min;
                        return true;
                    } else {
                        uint brickIndex = getBrickOffset(childNode);
                        vec3 leafMin = vec3(pos) - vec3(scale_exp2 * LEAF_SCALE_FACTOR);
                        vec3 leafMax = vec3(pos);
                        vec3 brickMin = gridMin + (leafMin - 1.0) * gridSize;
                        vec3 brickMax = gridMin + (leafMax - 1.0) * gridSize;
                        uint axisMaskDummy;
                        if (marchBrick(rayOrigin, rayDir, 0.0, brickMin, brickMax, brickIndex, hitColor, hitNormal, axisMaskDummy)) {
                            hitT = t_min;
                            return true;
                        }
#if defined(VOXEL_RAY_DEBUG_BRICK_AABB)
                        else {
                            vec3 debugColor = vec3(leafMin.x - 1.0, leafMin.y - 1.0, scale_exp2);
                            debugColor = abs(normalize(debugColor + vec3(1e-6)));
                            hitColor = debugColor;
                            hitNormal = normalize(-rayDir);
                            hitT = t_min;
                            return true;
                        }
#endif
                    }
                    // No solid voxel along ray inside this brick; advance to voxel exit and continue at SAME scale
                    // WORKAROUND (Phase H): Test sibling leaf bricks using proper ESVO coordinate mapping
                    // The issue: 'pos' is in ESVO [1,2] mirrored space for the PRIMARY child we just tested.
                    // For siblings, we need to compute THEIR 'pos' in the same coordinate system.
                    uint fallbackChildOffset = getChildOffset(child_descriptor);
                    uint fallbackNonLeafMask = getNonLeafMask(child_descriptor);
                    
                    // Current 'pos' encodes the primary child's position after mirroring.
                    // To get sibling positions, we need to compute their idx values and derive pos from scratch.
                    // Parent's scale is scale_exp2; we're at the parent level testing all its children.
                    
                    for (int sibIdx = 0; sibIdx < 8; ++sibIdx) {
                        uint unmappedSibIdx = uint(sibIdx);
                        if (unmappedSibIdx == childIdxPush) continue; // Already tested primary child
                        
                        bool sibIsLeaf = (unmappedSibIdx >= 7u) ? true : ((fallbackNonLeafMask & (1u << unmappedSibIdx)) == 0u);
                        if (sibIsLeaf) {
                            uint sibPtr = fallbackChildOffset + unmappedSibIdx;
                            uvec2 sibNode = fetchESVONode(sibPtr);
                            if (!isConstant(sibNode)) {
                                uint sibBrickIdx = getBrickOffset(sibNode);
                                
                                // Compute sibling's 'pos' in ESVO [1,2] space by remapping idx bits through octant_mask
                                // The primary child's pos was computed as the parent corner + offsets based on (idx ^ octant_mask)
                                // For sibling: remap its index through octant_mask to get mirrored coordinates
                                uint mappedSibIdx = unmappedSibIdx ^ octant_mask;
                                
                                // Reconstruct parent corner (before any child offset)
                                vec3 parentCorner = pos;
                                if ((childIdxPush & 1u) != 0u) parentCorner.x -= scale_exp2;
                                if ((childIdxPush & 2u) != 0u) parentCorner.y -= scale_exp2;
                                if ((childIdxPush & 4u) != 0u) parentCorner.z -= scale_exp2;
                                
                                // Compute sibling pos from parent corner using MAPPED index
                                vec3 sibPos = parentCorner;
                                if ((mappedSibIdx & 1u) != 0u) sibPos.x += scale_exp2;
                                if ((mappedSibIdx & 2u) != 0u) sibPos.y += scale_exp2;
                                if ((mappedSibIdx & 4u) != 0u) sibPos.z += scale_exp2;
                                
                                // Use EXACT same world-space mapping as primary child
                                vec3 sibLeafMin = sibPos - vec3(scale_exp2 * LEAF_SCALE_FACTOR);
                                vec3 sibLeafMax = sibPos;
                                vec3 sibBrickMin = gridMin + (sibLeafMin - 1.0) * gridSize;
                                vec3 sibBrickMax = gridMin + (sibLeafMax - 1.0) * gridSize;
                                
                                // Ray-AABB test before marching
                                vec2 sibT = rayAABBIntersection(rayOrigin, rayDir, sibBrickMin, sibBrickMax);
                                if (sibT.x >= 0.0 && sibT.x < sibT.y) {
                                    uint axisMaskDummy;
                                    if (marchBrick(rayOrigin, rayDir, sibT.x, sibBrickMin, sibBrickMax, sibBrickIdx, hitColor, hitNormal, axisMaskDummy)) {
                                        hitT = sibT.x;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    t_min = tv_max;
                    // Skip descent for leaf; proceed to ADVANCE phase
                    
                    #if VOXEL_RAY_DEBUG_EXHAUSTIVE_CHILDREN
                    // DIAGNOSTIC: Check if ANY sibling child at this node has geometry
                    // (expensive; only for debugging missing traversal paths)
                    uint debugChildOffset = getChildOffset(child_descriptor);
                    uint debugNonLeafMask = getNonLeafMask(child_descriptor);
                    for (int sibIdx = 0; sibIdx < 8; ++sibIdx) {
                        bool sibIsLeaf = (uint(sibIdx) >= 7u) ? true : ((debugNonLeafMask & (1u << uint(sibIdx))) == 0u);
                        if (sibIsLeaf) {
                            uint sibPtr = debugChildOffset + uint(sibIdx);
                            uvec2 sibNode = fetchESVONode(sibPtr);
                            uint sibBrickIdx = getBrickOffset(sibNode);
                            // Quick brick non-empty test (sample center voxel)
                            if (getVoxelFromBrick(sibBrickIdx, ivec3(4,4,4)) > 0u) {
                                // Found populated sibling that traversal may have skipped
                                hitColor = vec3(1.0, 0.0, 1.0); // Magenta = missed sibling
                                hitNormal = vec3(0,1,0);
                                hitT = t_min;
                                return true;
                            }
                        }
                    }
                    #endif
                } else {
                    // Internal child: perform descent
                    uint childIdx = idx ^ octant_mask;
                    uint childNodeOffset = getChildOffset(child_descriptor);
                    // Push current parent pointer onto stack, then move to child
                    if (ptrTop + 1 < PTR_STACK_MAX) {
                        parentPtrStack[++ptrTop] = parentPtr;
                    }
                    parentPtr = childNodeOffset + childIdx;
                    child_descriptor = uvec2(0u, 0u); // Invalidate cached descriptor for new parentPtr

                    scale--;
                    scale_exp2 = halfScale;
                    idx = 0;
                    if (tx_center > t_min) { idx ^= 1; pos.x += scale_exp2; }
                    if (ty_center > t_min) { idx ^= 2; pos.y += scale_exp2; }
                    if (tz_center > t_min) { idx ^= 4; pos.z += scale_exp2; }
                    t_max = tv_max;
                    continue;
                }
            }
        }

        // ADVANCE: Step to next voxel
        int step_mask = 0;
        if (tx_corner <= tc_max) { step_mask ^= 1; pos.x -= scale_exp2; }
        if (ty_corner <= tc_max) { step_mask ^= 2; pos.y -= scale_exp2; }
        if (tz_corner <= tc_max) { step_mask ^= 4; pos.z -= scale_exp2; }
        t_min = tc_max;
        idx ^= step_mask;

        // POP: Ascend if we exited current parent node
        // Check if we've moved outside parent bounds (would need stack in full ESVO)
        // For Phase H baseline: if step takes us out of bounds, ascend one level
        if ((idx & step_mask) != 0) {
            // Moved outside parent - ascend
            scale++;
            scale_exp2 *= 2.0;

            // If we've popped back to root level, exit
            if (scale >= S_MAX) {
                break;
            }

            // Update position to parent level
            pos.x = floor(pos.x / 2.0) * 2.0;
            pos.y = floor(pos.y / 2.0) * 2.0;
            pos.z = floor(pos.z / 2.0) * 2.0;

            // Recompute index at parent level
            idx = 0;
            if (pos.x >= 1.5) idx ^= 1;
            if (pos.y >= 1.5) idx ^= 2;
            if (pos.z >= 1.5) idx ^= 4;

            // Restore parent pointer from stack
            if (ptrTop >= 0) {
                parentPtr = parentPtrStack[ptrTop--];
            }
            child_descriptor = uvec2(0u, 0u);  // Invalidate cache
        }
    }

    return false;  // No hit
}

// ============================================================================
// OLD REVELLES TRAVERSAL (DEPRECATED - Replaced by ESVO)
// ============================================================================
// Commented out - ESVO format uses different traversal
// See OctreeTraversal-ESVO.glsl for full NVIDIA algorithm
// Phase H uses simple baseline, Phase I will integrate full ESVO

/*
// Forward declaration for brick DDA (defined below)
bool marchBrick(vec3 rayOrigin, vec3 rayDir, float tStart, vec3 brickMin, vec3 brickMax,
                uint brickOffset, out vec3 hitColor, out vec3 hitNormal);

// Stack entry for iterative octree traversal
struct TraversalState {
    uint nodeIndex;
    float tx0, ty0, tz0;
    float tx1, ty1, tz1;
    vec3 nodeMin, nodeMax;
    uint currentOctant;    // Which octant we're currently processing (0-8, 8=done)
};

// Compute octant index from which middle plane comparisons
// Returns 0-7 based on which octant to visit first
uint first_node(float tx0, float ty0, float tz0, float txm, float tym, float tzm) {
    uint octant = 0u;
    
    // Determine entry octant by comparing entry t-values with middle planes
    if (tx0 > ty0) {
        if (tx0 > tz0) {
            // X-plane entered first
            if (tym < tx0) octant |= 2u;
            if (tzm < tx0) octant |= 4u;
            return octant;
        }
    } else {
        if (ty0 > tz0) {
            // Y-plane entered first
            if (txm < ty0) octant |= 1u;
            if (tzm < ty0) octant |= 4u;
            return octant;
        }
    }
    
    // Z-plane entered first
    if (txm < tz0) octant |= 1u;
    if (tym < tz0) octant |= 2u;
    return octant;
}

// Compute next octant to visit after exiting current one
// Returns 8 if we exit the parent node entirely
uint new_node(float txm, float tym, float tzm, uint x, uint y, uint z) {
    if (txm < tym) {
        if (txm < tzm) { return x; }  // Exit through YZ-plane
    } else {
        if (tym < tzm) { return y; }  // Exit through XZ-plane
    }
    return z;  // Exit through XY-plane
}

// Iterative octree traversal using Revelles parametric method with explicit stack
// Returns true if leaf brick hit, fills hitColor/hitNormal/hitT
bool traverseOctree(uint rootNodeIndex, float tx0, float ty0, float tz0, 
                    float tx1, float ty1, float tz1,
                    vec3 rootMin, vec3 rootMax, uint octantMask,
                    vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                    out vec3 hitColor, out vec3 hitNormal, out float hitT) {
    
    const int MAX_STACK_DEPTH = 32;
    TraversalState stack[MAX_STACK_DEPTH];
    int stackPtr = 0;
    
    // Push root node
    stack[0].nodeIndex = rootNodeIndex;
    stack[0].tx0 = tx0;
    stack[0].ty0 = ty0;
    stack[0].tz0 = tz0;
    stack[0].tx1 = tx1;
    stack[0].ty1 = ty1;
    stack[0].tz1 = tz1;
    stack[0].nodeMin = rootMin;
    stack[0].nodeMax = rootMax;
    stack[0].currentOctant = 0u;  // Will be set by first_node below
    
    while (stackPtr >= 0) {
        TraversalState state = stack[stackPtr];
        
        // Check bounds
        if (state.tx1 < 0.0 || state.ty1 < 0.0 || state.tz1 < 0.0) {
            stackPtr--;  // Pop and continue
            continue;
        }
        
        // Read node data
        uint childMask = getChildMask(state.nodeIndex);
        uint leafMask = getLeafMask(state.nodeIndex);
        
        // Compute middle planes
        float txm = 0.5 * (state.tx0 + state.tx1);
        float tym = 0.5 * (state.ty0 + state.ty1);
        float tzm = 0.5 * (state.tz0 + state.tz1);
        
        // Initialize octant on first visit
        if (stack[stackPtr].currentOctant == 0u && stackPtr == 0) {
            stack[stackPtr].currentOctant = first_node(state.tx0, state.ty0, state.tz0, txm, tym, tzm);
        }
        
        uint currOctant = stack[stackPtr].currentOctant;
        
        // Check if we've processed all octants
        if (currOctant >= 8u) {
            stackPtr--;  // Pop and continue with parent
            continue;
        }
        
        // Advance to next octant for when we return to this node
        stack[stackPtr].currentOctant = new_node(txm, tym, tzm, 
                                                  currOctant | 1u,
                                                  currOctant | 2u,
                                                  currOctant | 4u);
        
        // Apply direction mask
        uint actualOctant = currOctant ^ octantMask;
        
        // Check if child exists
        if (!hasChild(childMask, actualOctant)) {
            continue;  // Skip empty child, loop will advance to next octant
        }
        
        // Compute child bounds
        vec3 nodeSize = state.nodeMax - state.nodeMin;
        vec3 childMin = state.nodeMin + vec3(
            (actualOctant & 1u) != 0u ? nodeSize.x * 0.5 : 0.0,
            ((actualOctant >> 1u) & 1u) != 0u ? nodeSize.y * 0.5 : 0.0,
            ((actualOctant >> 2u) & 1u) != 0u ? nodeSize.z * 0.5 : 0.0
        );
        vec3 childMax = childMin + nodeSize * 0.5;
        
        // Check if it's a leaf brick
        if (isLeaf(leafMask, actualOctant)) {
            // Hit leaf brick - invoke brick DDA
            uint brickOffset = getChildOffset(state.nodeIndex, actualOctant);
            
            // Transform to world space
            vec3 brickWorldMin = gridMin + childMin * (gridMax - gridMin);
            vec3 brickWorldMax = gridMin + childMax * (gridMax - gridMin);
            
            // March the brick
            if (marchBrick(rayOrigin, rayDir, state.tx0, brickWorldMin, brickWorldMax, 
                           brickOffset, hitColor, hitNormal)) {
                hitT = state.tx0;
                return true;
            }
            // Brick miss - continue to next octant
        } else {
            // Internal node - push onto stack and descend
            if (stackPtr + 1 < MAX_STACK_DEPTH) {
                uint childNodeIndex = getChildOffset(state.nodeIndex, actualOctant);
                
                // Compute child t-bounds
                float ctx0, cty0, ctz0, ctx1, cty1, ctz1;
                if ((currOctant & 1u) != 0u) { ctx0 = txm; ctx1 = state.tx1; } else { ctx0 = state.tx0; ctx1 = txm; }
                if ((currOctant & 2u) != 0u) { cty0 = tym; cty1 = state.ty1; } else { cty0 = state.ty0; cty1 = tym; }
                if ((currOctant & 4u) != 0u) { ctz0 = tzm; ctz1 = state.tz1; } else { ctz0 = state.tz0; ctz1 = tzm; }
                
                stackPtr++;
                stack[stackPtr].nodeIndex = childNodeIndex;
                stack[stackPtr].tx0 = ctx0;
                stack[stackPtr].ty0 = cty0;
                stack[stackPtr].tz0 = ctz0;
                stack[stackPtr].tx1 = ctx1;
                stack[stackPtr].ty1 = cty1;
                stack[stackPtr].tz1 = ctz1;
                stack[stackPtr].nodeMin = childMin;
                stack[stackPtr].nodeMax = childMax;
                stack[stackPtr].currentOctant = first_node(ctx0, cty0, ctz0,
                                                           0.5 * (ctx0 + ctx1),
                                                           0.5 * (cty0 + cty1),
                                                           0.5 * (ctz0 + ctz1));
            }
        }
    }
    
    return false;
}

*/
// End of deprecated Revelles code

// ============================================================================
// BRICK DDA (unchanged - works with ESVO)
// ============================================================================

// DDA march through 8^3 brick using parametric voxel traversal.
// Returns true if hit solid voxel and fills hitColor/hitNormal.
bool marchBrick(vec3 rayOrigin, vec3 rayDir, float tStart, vec3 brickMin, vec3 brickMax,
                uint brickOffset, out vec3 hitColor, out vec3 hitNormal, out uint axisMaskOut) {
    vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
    if (brickT.x < 0.0) return false; // Missed brick

    // Compute voxel size (uniform cube assumed)
    vec3 brickSize = brickMax - brickMin;
    float voxelSize = brickSize.x / 8.0;

    // Start position: from current ray t or brick entry, whichever is later
    // Don't add bias yet - compute clean entry point first
    float startT = max(tStart, brickT.x);
    vec3 cleanStartPos = rayOrigin + rayDir * startT;
    
    // Compute starting voxel from clean position
    vec3 relPos = cleanStartPos - brickMin;
    ivec3 voxelPos;
    #if VOXEL_RAY_ALT_INITIAL_VOXEL
        // Half-open interval mapping [0,1) per axis; apply tiny inward bias to avoid sampling past max
        vec3 scaled = relPos / voxelSize; // range ideally [0,8)
        const float inward = 1e-5;
        for (int a = 0; a < 3; ++a) {
            float s = clamp(scaled[a], 0.0, 8.0 - inward);
            int idx = int(floor(s));
            voxelPos[a] = clamp(idx, 0, 7);
        }
    #else
        // Original direction-aware boundary epsilon approach
        const float boundaryEps = 1e-6;
        vec3 scaled = relPos / voxelSize;
        for (int a = 0; a < 3; ++a) {
            float s = scaled[a];
            int base = int(floor(s));
            float fracPart = s - float(base);
            if (fracPart < boundaryEps) {
                if (rayDir[a] < 0.0 && base > 0) base -= 1;
            } else if (1.0 - fracPart < boundaryEps) {
                if (rayDir[a] > 0.0 && base < 7) base += 1;
            }
            voxelPos[a] = clamp(base, 0, 7);
        }
    #endif
    voxelPos = clamp(voxelPos, ivec3(0), ivec3(7));
    
    // NOW apply bias to avoid re-hitting entry boundary
    // Use dynamic epsilon scaled to voxel size to avoid skipping very small voxels when close
    float dynamicSurfaceEps = min(SURFACE_EPS, 0.1 * voxelSize);
    startT += dynamicSurfaceEps;
    vec3 startPos = rayOrigin + rayDir * startT;

    // Step direction per axis
    ivec3 step = ivec3(sign(rayDir));
    // If rayDir component == 0, prevent division by zero by treating tDelta as huge
    vec3 tDelta = vec3(
        (rayDir.x != 0.0) ? abs(voxelSize / rayDir.x) : 1e30,
        (rayDir.y != 0.0) ? abs(voxelSize / rayDir.y) : 1e30,
        (rayDir.z != 0.0) ? abs(voxelSize / rayDir.z) : 1e30);

    // Distances to first voxel boundary along each axis
    // tMax must be absolute parametric distance from rayOrigin, not relative to startPos
    vec3 voxelMin = brickMin + vec3(voxelPos) * voxelSize;
    vec3 voxelMax = voxelMin + vec3(voxelSize);
    vec3 tMax;
    for (int axis = 0; axis < 3; ++axis) {
        if (rayDir[axis] > 0.0)
            tMax[axis] = (voxelMax[axis] - rayOrigin[axis]) / rayDir[axis];
        else if (rayDir[axis] < 0.0)
            tMax[axis] = (voxelMin[axis] - rayOrigin[axis]) / rayDir[axis];
        else
            tMax[axis] = 1e30; // Parallel axis
    }

    // Traverse up to reasonable limit (8^3 worst-case)
    // Track current parametric t within brick volume for exit test
    float currentT = startT;
    float brickExitT = brickT.y;

    // Use a generous iteration cap as a safety guard; in practice, at most ~512 steps for 8^3 voxels
    int lastAxisMask = 0; // Bitmask: 1=X,2=Y,4=Z (can combine for multi-axis tie)
    for (int iter = 0; iter < 2048; ++iter) {
        // Bounds check
        if (any(lessThan(voxelPos, ivec3(0))) || any(greaterThan(voxelPos, ivec3(7)))) {
            break; // Exited brick
        }

        // Early escape: if we've progressed beyond brick exit parametric distance
        if (currentT > brickExitT + SURFACE_EPS) {
            break;
        }

        // Sample voxel
    uint voxelValue = getVoxelFromBrick(brickOffset, voxelPos);
        if (voxelValue > 0u) {
            // Hit solid voxel
            Material mat = getMaterial(voxelValue);

            // Compute stable normal from dominant ray direction
            vec3 ad = abs(rayDir);
            if (ad.x >= ad.y && ad.x >= ad.z) {
                hitNormal = vec3(-sign(rayDir.x), 0.0, 0.0);
            } else if (ad.y >= ad.z) {
                hitNormal = vec3(0.0, -sign(rayDir.y), 0.0);
            } else {
                hitNormal = vec3(0.0, 0.0, -sign(rayDir.z));
            }

            #if VOXEL_RAY_DEBUG_BRICK_OCCUPANCY
            // Brick occupancy visualization overrides axis/local debug: compute once lazily.
            // (Expensive) 512-voxel scan.
            int filled = 0;
            for (int z = 0; z < 8; ++z)
            for (int y = 0; y < 8; ++y)
            for (int x = 0; x < 8; ++x) {
                if (getVoxelFromBrick(brickOffset, ivec3(x,y,z)) > 0u) filled++;
            }
            float occ = float(filled) / 512.0;
            hitColor = vec3(occ, 1.0 - occ, 0.3);
            #elif VOXEL_RAY_DEBUG_AXIS_STEP
            // Axis-step debug coloring
            int m = lastAxisMask;
            vec3 axisColor;
            switch (m) {
                case 1: axisColor = vec3(1,0,0); break;            // X
                case 2: axisColor = vec3(0,1,0); break;            // Y
                case 4: axisColor = vec3(0,0,1); break;            // Z
                case 3: axisColor = vec3(1,1,0); break;            // X+Y
                case 5: axisColor = vec3(1,0,1); break;            // X+Z
                case 6: axisColor = vec3(0,1,1); break;            // Y+Z
                case 7: axisColor = vec3(1,1,1); break;            // X+Y+Z
                default: axisColor = vec3(0.2,0.2,0.2); break;     // None (first voxel)
            }
            hitColor = axisColor;
            #elif VOXEL_RAY_DEBUG_LOCAL_COORD
            // Encode local voxel coordinates to color for axis/mirroring debug
            hitColor = vec3(voxelPos.x, voxelPos.y, voxelPos.z) / 7.0;
            #else
            // Return albedo; caller applies shading once
            hitColor = mat.albedo;
            #endif
            axisMaskOut = uint(lastAxisMask);
            return true;
        }

        // Axis advancement strategy
        #if VOXEL_RAY_USE_MULTI_AXIS_TIES
            // Advance along ALL axes whose boundary is the minimal tMax within an epsilon.
            float nextT = min(min(tMax.x, tMax.y), tMax.z);
            const float tieEps = 1e-8; // Tight epsilon; scene scale modest
            bool advX = (tMax.x - nextT) <= tieEps;
            bool advY = (tMax.y - nextT) <= tieEps;
            bool advZ = (tMax.z - nextT) <= tieEps;
            lastAxisMask = (advX ? 1 : 0) | (advY ? 2 : 0) | (advZ ? 4 : 0);
            #if VOXEL_RAY_SUPERCOVER_TIES
                // Supercover: perform per-axis sub-steps when multiple axes tie to ensure we don't skip voxels.
                // We reuse nextT as the parametric distance for all tied axes (same plane intersection t).
                // After each axis increment, test the new voxel immediately (early return if hit).
                // Order of axis processing is deterministic (X,Y,Z) for stability.
                if (advX) {
                    voxelPos.x += step.x; tMax.x += tDelta.x; currentT = nextT;
                    if (!advY && !advZ) {
                        // Single-axis tie falls through to outer loop's next voxel test
                    } else {
                        // Multi-axis: perform intermediate test
                        if (!(any(lessThan(voxelPos, ivec3(0))) || any(greaterThan(voxelPos, ivec3(7))))) {
                            uint voxelValueX = getVoxelFromBrick(brickOffset, voxelPos);
                            if (voxelValueX > 0u) {
                                Material matX = getMaterial(voxelValueX);
                                vec3 ad = abs(rayDir);
                                if (ad.x >= ad.y && ad.x >= ad.z) { hitNormal = vec3(-sign(rayDir.x),0,0);} else if (ad.y >= ad.z) { hitNormal = vec3(0,-sign(rayDir.y),0);} else { hitNormal = vec3(0,0,-sign(rayDir.z)); }
                                #if VOXEL_RAY_DEBUG_AXIS_STEP
                                hitColor = vec3(1,0,0);
                                #elif VOXEL_RAY_DEBUG_LOCAL_COORD
                                hitColor = vec3(voxelPos)/7.0;
                                #else
                                hitColor = matX.albedo;
                                #endif
                                axisMaskOut = uint(lastAxisMask);
                                return true;
                            }
                        }
                    }
                }
                if (advY) {
                    voxelPos.y += step.y; tMax.y += tDelta.y; currentT = nextT;
                    if (advX || advZ) {
                        if (!(any(lessThan(voxelPos, ivec3(0))) || any(greaterThan(voxelPos, ivec3(7))))) {
                            uint voxelValueY = getVoxelFromBrick(brickOffset, voxelPos);
                            if (voxelValueY > 0u) {
                                Material matY = getMaterial(voxelValueY);
                                vec3 ad = abs(rayDir);
                                if (ad.x >= ad.y && ad.x >= ad.z) { hitNormal = vec3(-sign(rayDir.x),0,0);} else if (ad.y >= ad.z) { hitNormal = vec3(0,-sign(rayDir.y),0);} else { hitNormal = vec3(0,0,-sign(rayDir.z)); }
                                #if VOXEL_RAY_DEBUG_AXIS_STEP
                                hitColor = vec3(0,1,0);
                                #elif VOXEL_RAY_DEBUG_LOCAL_COORD
                                hitColor = vec3(voxelPos)/7.0;
                                #else
                                hitColor = matY.albedo;
                                #endif
                                axisMaskOut = uint(lastAxisMask);
                                return true;
                            }
                        }
                    }
                }
                if (advZ) {
                    voxelPos.z += step.z; tMax.z += tDelta.z; currentT = nextT;
                    if (advX || advY) {
                        if (!(any(lessThan(voxelPos, ivec3(0))) || any(greaterThan(voxelPos, ivec3(7))))) {
                            uint voxelValueZ = getVoxelFromBrick(brickOffset, voxelPos);
                            if (voxelValueZ > 0u) {
                                Material matZ = getMaterial(voxelValueZ);
                                vec3 ad = abs(rayDir);
                                if (ad.x >= ad.y && ad.x >= ad.z) { hitNormal = vec3(-sign(rayDir.x),0,0);} else if (ad.y >= ad.z) { hitNormal = vec3(0,-sign(rayDir.y),0);} else { hitNormal = vec3(0,0,-sign(rayDir.z)); }
                                #if VOXEL_RAY_DEBUG_AXIS_STEP
                                hitColor = vec3(0,0,1);
                                #elif VOXEL_RAY_DEBUG_LOCAL_COORD
                                hitColor = vec3(voxelPos)/7.0;
                                #else
                                hitColor = matZ.albedo;
                                #endif
                                axisMaskOut = uint(lastAxisMask);
                                return true;
                            }
                        }
                    }
                }
            #else
                if (advX) { voxelPos.x += step.x; tMax.x += tDelta.x; }
                if (advY) { voxelPos.y += step.y; tMax.y += tDelta.y; }
                if (advZ) { voxelPos.z += step.z; tMax.z += tDelta.z; }
                currentT = nextT;
            #endif
        #else
            // Original deterministic single-axis tie-break with ordered bias (X < Y < Z)
            vec3 biased = tMax + vec3(1e-7, 2e-7, 3e-7);
            float nextT = min(min(biased.x, biased.y), biased.z);
            if (biased.x <= biased.y && biased.x <= biased.z) {
                voxelPos.x += step.x; tMax.x += tDelta.x; lastAxisMask = 1;
            } else if (biased.y <= biased.z) {
                voxelPos.y += step.y; tMax.y += tDelta.y; lastAxisMask = 2;
            } else {
                voxelPos.z += step.z; tMax.z += tDelta.z; lastAxisMask = 4;
            }
            currentT = nextT;
        #endif
    }
    axisMaskOut = 0u;
    return false; // No hit inside brick
}

vec4 traceRay(vec3 rayOrigin, vec3 rayDir) {
    // Grid positioning in world space
    const float gridWorldSize = 50.0;  // 505050 world units (manageable size)
    float halfGrid = gridWorldSize * 0.5;  // 25.0
    vec3 gridCenter = vec3(0.0, 0.0, -22.0);  // Center 25 units from initial camera (z=3)
    vec3 gridMin = gridCenter - vec3(halfGrid);  // (-25, -25, -47)
    vec3 gridMax = gridCenter + vec3(halfGrid);  // (25, 25, 3)

    // Ray bounce loop (currently single bounce)
    for (int bounce = 0; bounce < RAY_MAX_BOUNCES; ++bounce) {
        // Intersect ray with grid root AABB
        vec2 gridT = rayAABBIntersectionFast(rayOrigin, rayDir, gridMin, gridMax);

        if (gridT.y < 0.0) {
            break;  // Miss - exit to background
        }

        // Compute octant mask for Revelles traversal
        uint octantMask = 0u;
        if (rayDir.x < 0.0) octantMask |= 1u;
        if (rayDir.y < 0.0) octantMask |= 2u;
        if (rayDir.z < 0.0) octantMask |= 4u;

        // Initialize hit data (prevents uninitialized variable noise)
        vec3 hitColor = vec3(0.0);
        vec3 hitNormal = vec3(0.0);
        float hitT = 0.0;

        // Invoke ESVO octree traversal
        if (traverseOctreeSimple(rayOrigin, rayDir, gridMin, gridMax,
                                  hitColor, hitNormal, hitT)) {
            // Hit found - shade and return
            #if VOXEL_RAY_DEBUG_AXIS_STEP || VOXEL_RAY_DEBUG_BRICK_BOUNDARY || VOXEL_RAY_DEBUG_LOCAL_COORD
                return vec4(hitColor, 1.0);
            #else
                return vec4(shadeVoxel(hitNormal, hitColor), 1.0);
            #endif
        }

        // No hit this bounce
        break;
    }

    // No hit - return background
    return vec4(BACKGROUND_COLOR, 1.0);
}

// ============================================================================
// MAIN
// ============================================================================

void main() {
    // Get pixel coordinates from global invocation ID
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screenSize = imageSize(outputImage);

    // Boundary check (avoid out-of-bounds writes)
    if (pixelCoords.x >= screenSize.x || pixelCoords.y >= screenSize.y) {
        return;
    }

    // Generate ray direction for this pixel
    vec3 rayDir = generateRayDirection(pixelCoords, screenSize);

    // Trace ray through octree
    vec4 color = traceRay(camera.cameraPos, rayDir);

    // Write final color to output image
    imageStore(outputImage, pixelCoords, color);
}
