// Proper hierarchical octree ray traversal (replacement for lines 212-375)
// Uses ray-guided traversal with empty-space skipping via ray-AABB exit boundaries

// Ray-AABB intersection helper
// Returns (tEnter, tExit) for ray-box intersection, or (-1, -1) if no hit
vec2 rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 invDir = 1.0 / (rayDir + vec3(EPSILON));
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit = min(min(tmax.x, tmax.y), tmax.z);

    if (tExit < 0.0 || tEnter > tExit) {
        return vec2(-1.0, -1.0);  // No intersection
    }

    return vec2(max(tEnter, 0.0), tExit);
}

// DDA march through 8³ brick voxels
// Returns true if hit solid voxel, fills hitColor and hitNormal
bool marchBrick(vec3 rayOrigin, vec3 rayDir, vec3 brickMin, vec3 brickMax,
                uint brickOffset, out vec3 hitColor, out vec3 hitNormal) {
    // Intersect ray with brick AABB
    vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
    if (brickT.x < 0.0) return false;  // Ray missed brick

    // Start marching from brick entry point
    vec3 rayPos = rayOrigin + rayDir * brickT.x;
    vec3 brickSize = brickMax - brickMin;
    float voxelSize = brickSize.x / 8.0;  // Brick is 8³ voxels
    float stepSize = voxelSize * 0.5;  // Half-voxel steps for safety

    int maxSteps = int(length(brickSize) / stepSize) + 1;

    for (int step = 0; step < maxSteps && step < 64; step++) {
        // Check if exited brick
        if (any(lessThan(rayPos, brickMin)) || any(greaterThanEqual(rayPos, brickMax))) {
            break;
        }

        // Convert to brick-local voxel coordinates [0, 8)
        vec3 posInBrick = (rayPos - brickMin) / brickSize * 8.0;
        ivec3 voxelPos = ivec3(floor(clamp(posInBrick, vec3(0.0), vec3(7.999))));

        // Sample voxel
        if (all(greaterThanEqual(voxelPos, ivec3(0))) && all(lessThan(voxelPos, ivec3(8)))) {
            uint voxelValue = getVoxelFromBrick(brickOffset, voxelPos);

            if (voxelValue > 0u) {
                // Hit solid voxel
                Material mat = getMaterial(voxelValue);
                vec3 localPos = posInBrick - vec3(voxelPos);
                hitNormal = calculateVoxelNormal(localPos, ivec3(0));
                hitColor = shadeVoxel(hitNormal, mat.albedo);
                return true;
            }
        }

        rayPos += rayDir * stepSize;
    }

    return false;  // No hit in brick
}

// Hierarchical octree descent using DDA ray marching with node-aware stepping
// Key insight: March ray through space, but use octree to skip empty nodes at node boundaries
vec4 traceRay(vec3 rayOrigin, vec3 rayDir) {
    // Grid positioning in world space
    float halfGrid = float(camera.gridResolution) * 0.5;
    vec3 gridWorldCenter = vec3(0.0, 0.0, -200.0);
    vec3 gridMin = gridWorldCenter - vec3(halfGrid);
    vec3 gridMax = gridWorldCenter + vec3(halfGrid);

    // Intersect ray with grid root AABB
    vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);
    if (gridT.x < 0.0) {
        return vec4(BACKGROUND_COLOR, 1.0);  // Ray missed grid
    }

    // Start ray at grid entry point
    float t = gridT.x;
    float tMax = gridT.y;

    const int MAX_RAY_STEPS = 1024;

    for (int rayStep = 0; rayStep < MAX_RAY_STEPS && t < tMax; rayStep++) {
        vec3 rayPos = rayOrigin + rayDir * t;

        // Transform to grid-local space [0, gridRes]
        vec3 gridLocalPos = rayPos - (gridWorldCenter - vec3(halfGrid));
        // Normalize to [0, 1] for octree traversal
        vec3 normalizedPos = gridLocalPos / float(camera.gridResolution);

        // Ensure we're still within grid bounds
        if (any(lessThan(normalizedPos, vec3(0.0))) || any(greaterThanEqual(normalizedPos, vec3(1.0)))) {
            break;
        }

        // Hierarchical octree descent at this ray position
        const int MAX_DEPTH = 9;
        uint nodeStack[MAX_DEPTH];
        vec3 minStack[MAX_DEPTH];
        vec3 maxStack[MAX_DEPTH];
        int stackPtr = 0;

        // Push root node (normalized space [0, 1])
        nodeStack[0] = 0u;
        minStack[0] = vec3(0.0);
        maxStack[0] = vec3(1.0);

        vec3 hitColor;
        vec3 hitNormal;
        bool hitVoxel = false;
        float skipDistance = 0.0;

        // Traverse octree to find node containing this ray position
        for (int iter = 0; iter < 64 && stackPtr >= 0; iter++) {
            // Pop node from stack
            uint nodeIndex = nodeStack[stackPtr];
            vec3 nodeMin = minStack[stackPtr];
            vec3 nodeMax = maxStack[stackPtr];
            stackPtr--;

            // Check if position is inside this node
            if (any(lessThan(normalizedPos, nodeMin)) || any(greaterThanEqual(normalizedPos, nodeMax))) {
                continue;  // Position outside node
            }

            // Read node data
            uint childMask = getChildMask(nodeIndex);
            uint leafMask = getLeafMask(nodeIndex);

            // Determine which child octant contains the ray position
            vec3 posInNode = (normalizedPos - nodeMin) / (nodeMax - nodeMin);  // [0, 1] within node
            uint octantIndex = getChildOctant(posInNode);

            // Check if child exists
            if (!hasChild(childMask, octantIndex)) {
                // Empty child - compute distance to exit this node and skip
                vec3 nodeWorldMin = gridMin + nodeMin * (gridMax - gridMin);
                vec3 nodeWorldMax = gridMin + nodeMax * (gridMax - gridMin);
                vec2 nodeT = rayAABBIntersection(rayOrigin, rayDir, nodeWorldMin, nodeWorldMax);
                if (nodeT.y > t) {
                    skipDistance = nodeT.y - t + EPSILON;  // Jump to node exit
                }
                break;  // Exit octree descent for this position
            }

            // Compute child bounds in normalized space
            vec3 childMin = nodeMin + vec3(uvec3(octantIndex & 1u, (octantIndex >> 1u) & 1u, (octantIndex >> 2u) & 1u)) * (nodeMax - nodeMin) * 0.5;
            vec3 childMax = childMin + (nodeMax - nodeMin) * 0.5;

            // Check if child is a leaf brick
            if (isLeaf(leafMask, octantIndex)) {
                // Leaf brick - DDA march through voxels
                uint brickOffset = getChildOffset(nodeIndex, octantIndex);
                if (brickOffset == 0u) {
                    // Invalid brick - treat as empty, skip this node
                    vec3 nodeWorldMin = gridMin + childMin * (gridMax - gridMin);
                    vec3 nodeWorldMax = gridMin + childMax * (gridMax - gridMin);
                    vec2 nodeT = rayAABBIntersection(rayOrigin, rayDir, nodeWorldMin, nodeWorldMax);
                    if (nodeT.y > t) {
                        skipDistance = nodeT.y - t + EPSILON;
                    }
                    break;
                }

                // Convert normalized bounds to world space
                vec3 brickWorldMin = gridMin + childMin * (gridMax - gridMin);
                vec3 brickWorldMax = gridMin + childMax * (gridMax - gridMin);

                if (marchBrick(rayOrigin, rayDir, brickWorldMin, brickWorldMax,
                              brickOffset, hitColor, hitNormal)) {
                    return vec4(hitColor, 1.0);  // Hit!
                }

                // No hit in brick - skip to brick exit
                vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickWorldMin, brickWorldMax);
                if (brickT.y > t) {
                    skipDistance = brickT.y - t + EPSILON;
                }
                break;  // Exit octree descent
            } else {
                // Internal node - descend into child
                uint childOffset = getChildOffset(nodeIndex, octantIndex);
                if (childOffset == 0u) {
                    // Invalid child - skip this node
                    vec3 nodeWorldMin = gridMin + childMin * (gridMax - gridMin);
                    vec3 nodeWorldMax = gridMin + childMax * (gridMax - gridMin);
                    vec2 nodeT = rayAABBIntersection(rayOrigin, rayDir, nodeWorldMin, nodeWorldMax);
                    if (nodeT.y > t) {
                        skipDistance = nodeT.y - t + EPSILON;
                    }
                    break;
                }

                // Push child onto stack
                stackPtr++;
                if (stackPtr >= MAX_DEPTH) break;

                nodeStack[stackPtr] = childOffset;
                minStack[stackPtr] = childMin;
                maxStack[stackPtr] = childMax;
            }
        }  // End octree descent

        // Advance ray
        if (skipDistance > 0.0) {
            t += skipDistance;  // Skip to node boundary
        } else {
            t += 0.25;  // Conservative step if no skip computed
        }
    }  // End ray march loop

    // No hit
    return vec4(BACKGROUND_COLOR, 1.0);
}
