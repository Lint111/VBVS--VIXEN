#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Output image (no format specified - uses shaderStorageImageWriteWithoutFormat feature)
layout(binding = 0) uniform writeonly image2D outputImage;

// ESVO octree buffer (uvec2 per node - 64 bits)
layout(std430, binding = 1) readonly buffer ESVOBuffer {
    uvec2 esvoNodes[];
};

// Brick buffer (8x8x8 voxels per brick)
layout(std430, binding = 2) readonly buffer BrickBuffer {
    uint brickData[];
};

// Material buffer
struct Material {
    vec3 albedo;
    float metalness;
    float roughness;
    float emissive;
    vec2 padding;
};

layout(std430, binding = 3) readonly buffer MaterialBuffer {
    Material materials[];
};

// ESVO traversal depth (2^7 = 128 voxel resolution)
const int S_MAX = 7;

// Push constants for camera
layout(push_constant) uniform PushConstants {
    vec3 cameraPos;
    float time;
    vec3 cameraDir;
    float fov;
    vec3 cameraUp;
    float aspect;
    vec3 cameraRight;
    float pad;
} pc;

// ESVO node fetch
uvec2 fetchESVONode(uint nodeIndex) {
    return esvoNodes[nodeIndex];
}

// ESVO descriptor bit layout helpers
// C++ layout: bits 1-7: nonLeafMask, bits 8-15: childMask (reversed), bits 17-31: childOffset
uint getChildMask(uvec2 descriptor) {
    // Child mask is stored REVERSED at bits 8-15
    // child[0] at bit 15, child[7] at bit 8
    return (descriptor.x >> 8) & 0xFFu;
}

uint getNonLeafMask(uvec2 descriptor) {
    // Non-leaf mask at bits 1-7 (7 bits for children 0-6)
    return (descriptor.x >> 1) & 0x7Fu;
}

uint getChildOffset(uvec2 descriptor) {
    // Child offset at bits 17-31 (15 bits)
    return (descriptor.x >> 17) & 0x7FFFu;
}

// Helper function to check if a child exists
// Takes care of the reversed bit ordering in childMask
bool childExists(uint childMask, int childIndex) {
    // childMask has child[0] at bit 7, child[7] at bit 0 (REVERSED order)
    int bit_pos = 7 - childIndex;
    return ((childMask >> bit_pos) & 1u) != 0u;
}

// Helper function to check if a child is a leaf node
bool childIsLeaf(uint nonLeafMask, int childIndex) {
    // Child 7 is always a leaf (no bit in nonLeafMask)
    // For children 0-6, check if the bit is 0 (leaf) or 1 (internal)
    return (childIndex >= 7) || ((nonLeafMask >> childIndex) & 1u) == 0u;
}

// Count how many set bits (existing children) come before childIndex in childMask
// childMask has child[0] at bit 7, child[7] at bit 0 (REVERSED order)
// This gives the local storage index for accessing packed child array
uint countChildrenBefore(uint childMask, int childIndex) {
    // Create mask for all children with index < childIndex
    // In reversed bit order: child[0] at bit 7, child[1] at bit 6, etc.
    // Children before index N are at bit positions (7-0) to (7-(N-1)) = (7) to (8-N)
    // Mask = bits from (8-childIndex) to 7
    if (childIndex <= 0) return 0u;
    uint mask = ((1u << childIndex) - 1u) << (8 - childIndex);
    return uint(bitCount(childMask & mask));
}


// Brick node helpers
bool isConstant(uvec2 node) {
    return (node.x & 0x80000000u) != 0u; // Bit 31
}

uint getConstantMaterialID(uvec2 node) {
    return node.x & 0xFFu; // Bits 0-7
}

uint getBrickOffset(uvec2 node) {
    return node.y; // Full 32 bits for brick index
}

Material getMaterial(uint matID) {
    if (matID >= 256u) matID = 0u;
    return materials[matID];
}

// Ray-AABB intersection
vec2 rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 invDir = 1.0 / rayDir;
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;
    vec3 tMin = min(t0, t1);
    vec3 tMax = max(t0, t1);
    float tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar = min(min(tMax.x, tMax.y), tMax.z);
    return vec2(tNear, tFar);
}

// Brick marching function
const float EPSILON = 0.001;

bool marchBrick(vec3 rayOrigin, vec3 rayDir, float startT,
                vec3 brickMin, vec3 brickMax, uint brickIndex,
                out vec3 hitColor, out vec3 hitNormal, out uint axisMask) {

    // Ray-AABB test for brick bounds
    vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
    if (brickT.y < 0.0) return false;

    float t = max(brickT.x, startT);
    if (t > brickT.y) return false;

    vec3 brickSize = brickMax - brickMin;
    vec3 voxelSize = brickSize / 8.0;

    // Start position in world space
    vec3 pos = rayOrigin + rayDir * (t + EPSILON);

    // DDA setup
    vec3 invDir = 1.0 / max(abs(rayDir), vec3(EPSILON));
    ivec3 step = ivec3(sign(rayDir));
    vec3 deltaDist = voxelSize * invDir;

    const int MAX_STEPS = 64;
    for (int i = 0; i < MAX_STEPS; i++) {
        // Convert world position to voxel indices
        vec3 localPos = (pos - brickMin) / voxelSize;
        ivec3 voxelIdx = ivec3(floor(localPos));

        // Check bounds
        if (any(lessThan(voxelIdx, ivec3(0))) || any(greaterThanEqual(voxelIdx, ivec3(8)))) {
            break;
        }

        // Sample brick voxel
        uint voxelLinearIdx = uint(voxelIdx.z * 64 + voxelIdx.y * 8 + voxelIdx.x);
        uint voxelData = brickData[brickIndex * 512u + voxelLinearIdx];

        if (voxelData != 0u) {
            // Hit! Extract material
            uint matID = voxelData & 0xFFu;
            Material mat = getMaterial(matID);
            hitColor = mat.albedo;

            // Compute normal from ray direction (simple for now)
            vec3 normal = vec3(0.0);
            vec3 voxelCenter = brickMin + (vec3(voxelIdx) + 0.5) * voxelSize;
            vec3 toCenter = pos - voxelCenter;
            vec3 absToCenter = abs(toCenter);

            if (absToCenter.x > absToCenter.y && absToCenter.x > absToCenter.z) {
                normal.x = sign(toCenter.x);
            } else if (absToCenter.y > absToCenter.z) {
                normal.y = sign(toCenter.y);
            } else {
                normal.z = sign(toCenter.z);
            }

            hitNormal = normalize(normal);
            return true;
        }

        // DDA step to next voxel
        vec3 nextBounds = brickMin + vec3(voxelIdx + (step + 1) / 2) * voxelSize;
        vec3 tMax = (nextBounds - pos) * invDir;

        if (tMax.x < tMax.y && tMax.x < tMax.z) {
            pos += rayDir * tMax.x;
            axisMask = 1u;
        } else if (tMax.y < tMax.z) {
            pos += rayDir * tMax.y;
            axisMask = 2u;
        } else {
            pos += rayDir * tMax.z;
            axisMask = 4u;
        }

        pos += rayDir * EPSILON;
    }

    return false;
}

// Simple ray generation
vec3 getRayDir(vec2 uv) {
    float tanHalfFov = tan(radians(pc.fov * 0.5));
    vec2 ndc = uv * 2.0 - 1.0;
    vec3 rayDir = pc.cameraDir +
                  pc.cameraRight * ndc.x * tanHalfFov * pc.aspect +
                  pc.cameraUp * ndc.y * tanHalfFov;
    return normalize(rayDir);
}

// Simple traversal for individual bricks (no octree)
bool traverseSingleBrick(vec3 rayOrigin, vec3 rayDir,
                         vec3 brickMin, vec3 brickMax, uint brickIndex,
                         out vec3 hitColor, out vec3 hitNormal) {
    uint axisMask;
    return marchBrick(rayOrigin, rayDir, 0.0, brickMin, brickMax, brickIndex,
                      hitColor, hitNormal, axisMask);
}

// Test pattern: Wall of bricks
bool traverseWallOfBricks(vec3 rayOrigin, vec3 rayDir,
                          out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    const int WALL_SIZE = 4;
    const float BRICK_SIZE = 2.0;
    const float WALL_Z = 5.0;

    float closestT = 1e10;
    bool hitAnything = false;
    vec3 bestColor;
    vec3 bestNormal;

    for (int y = 0; y < WALL_SIZE; y++) {
        for (int x = 0; x < WALL_SIZE; x++) {
            vec3 brickMin = vec3(
                float(x - WALL_SIZE/2) * BRICK_SIZE,
                float(y - WALL_SIZE/2) * BRICK_SIZE,
                WALL_Z
            );
            vec3 brickMax = brickMin + vec3(BRICK_SIZE);

            uint brickIndex = uint(y * WALL_SIZE + x);

            vec3 tempColor, tempNormal;
            uint axisMask;
            if (marchBrick(rayOrigin, rayDir, 0.0, brickMin, brickMax,
                           brickIndex, tempColor, tempNormal, axisMask)) {

                vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
                if (brickT.x < closestT) {
                    closestT = brickT.x;
                    bestColor = tempColor;
                    bestNormal = tempNormal;
                    hitAnything = true;
                }
            }
        }
    }

    if (hitAnything) {
        hitColor = bestColor;
        hitNormal = bestNormal;
        hitT = closestT;
        return true;
    }

    return false;
}

// Debug visualization for octree structure
vec3 debugOctreeLevel(uint nodeIndex, int targetLevel) {
    uvec2 descriptor = fetchESVONode(nodeIndex);
    uint childMask = getChildMask(descriptor);
    uint nonLeafMask = getNonLeafMask(descriptor);

    // Color based on node properties
    vec3 color = vec3(0.0);

    // Red channel: child occupancy
    float occupancy = float(bitCount(childMask)) / 8.0;
    color.r = occupancy;

    // Green channel: leaf vs internal
    float leafRatio = float(bitCount(childMask & ~nonLeafMask)) / max(1.0, float(bitCount(childMask)));
    color.g = leafRatio;

    // Blue channel: node depth (estimated)
    color.b = float(targetLevel) / 5.0;

    return color;
}

// Main ESVO octree traversal
bool traverseOctreeSimple(vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                          out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    const float EPSILON_ESVO = exp2(-float(S_MAX));

    // World-space AABB test
    vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);
    if (gridT.y < 0.0) return false;

    vec3 gridSize = gridMax - gridMin;
    vec3 invGridSize = 1.0 / gridSize;
    vec3 rayStartWorld = (gridT.x > 0.0) ? (rayOrigin + rayDir * (gridT.x + EPSILON)) : rayOrigin;

    // Transform to octree space [1,2] - ESVO standard space
    vec3 p = ((rayStartWorld - gridMin) * invGridSize) + 1.0;
    vec3 d = rayDir * invGridSize;

    // Avoid division by zero
    float sx = d.x >= 0.0 ? 1.0 : -1.0;
    float sy = d.y >= 0.0 ? 1.0 : -1.0;
    float sz = d.z >= 0.0 ? 1.0 : -1.0;
    if(abs(d.x) < EPSILON_ESVO) d.x = sx * EPSILON_ESVO;
    if(abs(d.y) < EPSILON_ESVO) d.y = sy * EPSILON_ESVO;
    if(abs(d.z) < EPSILON_ESVO) d.z = sz * EPSILON_ESVO;

    // Parametric coefficients for ray equation: p + t*d
    float tx_coef = 1.0 / -abs(d.x);
    float ty_coef = 1.0 / -abs(d.y);
    float tz_coef = 1.0 / -abs(d.z);
    float tx_bias = tx_coef * p.x;
    float ty_bias = ty_coef * p.y;
    float tz_bias = tz_coef * p.z;

    // Octant mirroring for ESVO traversal - CRITICAL: initialize to 7!
    // This mirrors the coordinate system so ray direction is negative along each axis
    int octant_mask = 7;
    if (d.x > 0.0) { octant_mask ^= 1; tx_bias = 3.0 * tx_coef - tx_bias; }
    if (d.y > 0.0) { octant_mask ^= 2; ty_bias = 3.0 * ty_coef - ty_bias; }
    if (d.z > 0.0) { octant_mask ^= 4; tz_bias = 3.0 * tz_coef - tz_bias; }

    // Root node t-span (reference line 36-40)
    float t_min = max(max(2.0 * tx_coef - tx_bias, 2.0 * ty_coef - ty_bias), 2.0 * tz_coef - tz_bias);
    float t_max = min(min(tx_coef - tx_bias, ty_coef - ty_bias), tz_coef - tz_bias);
    float h = t_max;  // CRITICAL: h must be initialized to t_max, not 1e10!
    t_min = max(t_min, 0.0);
    t_max = min(t_max, 1.0);  // Clamp to [0,1] range

    if (t_min >= t_max) return false;

    // Stack for DFS traversal
    struct StackEntry {
        uint parentPtr;
        float t_max;
    };

    const int STACK_SIZE = 23;
    StackEntry stack[STACK_SIZE];

    // Initialize traversal at root
    uint parentPtr = 0u;
    int scale = S_MAX - 1;
    float scale_exp2 = 0.5; // exp2(scale - S_MAX) = exp2(-1) = 0.5

    // Position in octree space - ESVO algorithm initializes to corner
    vec3 pos = vec3(1.0);

    // Select initial child octant based on ray entry point (1.5 is center of [1,2])
    int idx = 0;
    if (1.5 * tx_coef - tx_bias > t_min) { idx ^= 1; pos.x = 1.5; }
    if (1.5 * ty_coef - ty_bias > t_min) { idx ^= 2; pos.y = 1.5; }
    if (1.5 * tz_coef - tz_bias > t_min) { idx ^= 4; pos.z = 1.5; }

    // Main traversal loop (reference line 53)
    const int MAX_ITERS = 512;  // Safety limit
    for (int iter = 0; iter < MAX_ITERS && scale < S_MAX; ++iter) {

        // Fetch current parent node
        uvec2 parent_descriptor = fetchESVONode(parentPtr);
        uint childMask = getChildMask(parent_descriptor);
        uint childOffset = getChildOffset(parent_descriptor);

        // Compute current voxel exit planes
        float tx_corner = pos.x * tx_coef - tx_bias;
        float ty_corner = pos.y * ty_coef - ty_bias;
        float tz_corner = pos.z * tz_coef - tz_bias;
        float tc_max = min(min(tx_corner, ty_corner), tz_corner);

        // Check if current child exists in octree
        int childIndex = idx ^ octant_mask;

        if (childExists(childMask, childIndex) && t_min <= t_max) {
            // INTERSECT: Compute tv_max and check if t-span is non-empty (reference line 77, 100)
            float tv_max = min(t_max, tc_max);
            float halfScale = scale_exp2 * 0.5;

            // Descend to child if the resulting t-span is non-empty (reference line 100)
            if (t_min <= tv_max) {
                // Check if this is a leaf
                uint nonLeafMask = getNonLeafMask(parent_descriptor);
                bool isLeaf = childIsLeaf(nonLeafMask, childIndex);

                if (isLeaf) {
                    // Process leaf voxel/brick
                    // Only EXISTING children are stored, count how many come before this one
                    uint childLocalIndex = countChildrenBefore(childMask, childIndex);
                    uint childPtr = childOffset + childLocalIndex;
                    uvec2 childNode = fetchESVONode(childPtr);

                    // Check for constant material
                    if (isConstant(childNode)) {
                        uint matID = getConstantMaterialID(childNode);
                        Material m = getMaterial(matID);
                        hitColor = m.albedo;

                        // Compute normal based on exit plane
                        vec3 normal = vec3(0.0);
                        if (tx_corner <= tc_max) normal.x = (idx & 1) != 0 ? 1.0 : -1.0;
                        if (ty_corner <= tc_max) normal.y = (idx & 2) != 0 ? 1.0 : -1.0;
                        if (tz_corner <= tc_max) normal.z = (idx & 4) != 0 ? 1.0 : -1.0;
                        hitNormal = normalize(normal);
                        hitT = t_min;
                        return true;
                    }

                    // Process brick
                    uint brickIndex = getBrickOffset(childNode);
                    vec3 leafMin = pos - vec3(scale_exp2);
                    vec3 leafMax = pos;
                    vec3 brickMin = gridMin + (leafMin - 1.0) * gridSize;
                    vec3 brickMax = gridMin + (leafMax - 1.0) * gridSize;

                    uint axisMask;
                    if (marchBrick(rayOrigin, rayDir, 0.0,
                                   brickMin, brickMax, brickIndex, hitColor, hitNormal, axisMask)) {
                        hitT = t_min;
                        return true;
                    }

                    // Skip past empty brick
                    t_min = tv_max;

                } else {
                    // Internal node - PUSH & DESCEND

                    // Compute child center for subdivision
                    float tx_center = halfScale * tx_coef + tx_corner;
                    float ty_center = halfScale * ty_coef + ty_corner;
                    float tz_center = halfScale * tz_coef + tz_corner;

                    // PUSH: Store current parent in stack for backtracking (reference line 107-109)
                    // Only push if tc_max < h (stack pruning optimization)
                    if (tc_max < h) {
                        stack[scale].parentPtr = parentPtr;
                        stack[scale].t_max = t_max;
                    }
                    h = tc_max;

                    // DESCEND to near child
                    // Only EXISTING children are stored, count how many come before this one
                    uint childLocalIndex = countChildrenBefore(childMask, childIndex);
                    parentPtr = childOffset + childLocalIndex;

                    // Update position for child level - CRITICAL: match reference algorithm!
                    // Reference only ADDS scale_exp2, never subtracts
                    idx = 0;
                    scale--;
                    scale_exp2 = halfScale;

                    if (tx_center > t_min) { idx ^= 1; pos.x += scale_exp2; }
                    if (ty_center > t_min) { idx ^= 2; pos.y += scale_exp2; }
                    if (tz_center > t_min) { idx ^= 4; pos.z += scale_exp2; }

                    // Update active t-span (reference line 124)
                    t_max = tv_max;
                    continue;
                }
            }
        }

        // ADVANCE - Move to next sibling voxel
        int step_mask = 0;
        if (tx_corner <= tc_max) { step_mask ^= 1; pos.x -= scale_exp2; }
        if (ty_corner <= tc_max) { step_mask ^= 2; pos.y -= scale_exp2; }
        if (tz_corner <= tc_max) { step_mask ^= 4; pos.z -= scale_exp2; }

        t_min = tc_max;
        idx ^= step_mask;

        // POP: Check if we need to backtrack to parent (reference line 140-165)
        if ((idx & step_mask) != 0) {
            // Find highest differing bit to determine scale (reference line 144-148)
            uint differing_bits = 0u;
            if ((step_mask & 1) != 0) differing_bits |= floatBitsToUint(pos.x) ^ floatBitsToUint(pos.x + scale_exp2);
            if ((step_mask & 2) != 0) differing_bits |= floatBitsToUint(pos.y) ^ floatBitsToUint(pos.y + scale_exp2);
            if ((step_mask & 4) != 0) differing_bits |= floatBitsToUint(pos.z) ^ floatBitsToUint(pos.z + scale_exp2);
            scale = int(floatBitsToUint(float(differing_bits)) >> 23) - 127;
            scale_exp2 = uintBitsToFloat((uint(scale - S_MAX + 127) << 23));

            // Restore parent from stack (reference line 151-153)
            parentPtr = stack[scale].parentPtr;
            t_max = stack[scale].t_max;

            // Round cube position and extract child slot index (reference line 155-161)
            int shx = int(floatBitsToUint(pos.x)) >> scale;
            int shy = int(floatBitsToUint(pos.y)) >> scale;
            int shz = int(floatBitsToUint(pos.z)) >> scale;
            pos.x = uintBitsToFloat(uint(shx << scale));
            pos.y = uintBitsToFloat(uint(shy << scale));
            pos.z = uintBitsToFloat(uint(shz << scale));
            idx = (shx & 1) | ((shy & 1) << 1) | ((shz & 1) << 2);

            // Prevent same parent from being stored again (reference line 163)
            h = 0.0;
        }
    }

    return false;
}

// Basic shading
vec3 shade(vec3 hitColor, vec3 hitNormal, vec3 rayDir) {
    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
    float NdotL = max(dot(hitNormal, lightDir), 0.0);
    vec3 ambient = hitColor * 0.2;
    vec3 diffuse = hitColor * NdotL * 0.8;
    return ambient + diffuse;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(imageSize);
    vec3 rayOrigin = pc.cameraPos;
    vec3 rayDir = getRayDir(uv);

    vec3 color = vec3(0.0);
    vec3 hitColor, hitNormal;
    float hitT;

    // Grid bounds for octree (Cornell box is centered at origin, spans [-8,8])
    vec3 gridMin = vec3(-8.0, -8.0, -8.0);
    vec3 gridMax = vec3(8.0, 8.0, 8.0);

    // DEBUG: Test ray-AABB intersection first
    vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);

    // Color based on intersection results:
    // - Green: Ray hits AABB (gridT.y >= 0 && gridT.x < gridT.y)
    // - Red: Ray misses AABB (gridT.y < 0)
    // - Blue: Ray starts inside AABB (gridT.x <= 0 && gridT.y > 0)
    // - Yellow: Traversal succeeds (normal rendering)

    // ESVO traversal - show hits with actual material colors, misses as black
    if (gridT.y >= 0.0) {
        // Ray intersects AABB - try traversal
        if (traverseOctreeSimple(rayOrigin, rayDir, gridMin, gridMax, hitColor, hitNormal, hitT)) {
            // HIT - show actual material color (should be red/green/white for Cornell box)
            color = hitColor;
        } else {
            // MISS - pure black to clearly see the hit pattern
            color = vec3(0.0);
        }
    } else {
        // No AABB intersection - background gradient
        color = vec3(0.5, 0.7, 1.0) * (1.0 - uv.y * 0.5);
    }

    // 2. Wall of bricks (fallback test) - DISABLED to see pure ESVO results
    //if (traverseWallOfBricks(rayOrigin, rayDir, hitColor, hitNormal, hitT)) {
    //    color = shade(hitColor, hitNormal, rayDir);
    //}

    // 3. Single brick test
    //vec3 brickMin = vec3(-1.0, -1.0, 2.0);
    //vec3 brickMax = vec3(1.0, 1.0, 4.0);
    //if (traverseSingleBrick(rayOrigin, rayDir, brickMin, brickMax, 0u, hitColor, hitNormal)) {
    //    color = shade(hitColor, hitNormal, rayDir);
    //}

    // // Background gradient
    // if (all(equal(color, vec3(0.0)))) {
    //     float t = uv.y;
    //     color = mix(vec3(0.1, 0.15, 0.3), vec3(0.4, 0.6, 0.8), t);
    // }

    imageStore(outputImage, pixelCoords, vec4(color, 1.0));
}