#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BUFFER BINDINGS
// ============================================================================

// Output image (uses shaderStorageImageWriteWithoutFormat feature)
layout(binding = 0) uniform writeonly image2D outputImage;

// ESVO octree buffer (uvec2 per node - 64 bits)
layout(std430, binding = 1) readonly buffer ESVOBuffer {
    uvec2 esvoNodes[];
};

// Brick buffer (8x8x8 voxels per brick)
layout(std430, binding = 2) readonly buffer BrickBuffer {
    uint brickData[];
};

// Material buffer
struct Material {
    vec3 albedo;
    float metalness;
    float roughness;
    float emissive;
    vec2 padding;
};

layout(std430, binding = 3) readonly buffer MaterialBuffer {
    Material materials[];
};

// ============================================================================
// CONSTANTS - MUST MATCH C++ LaineKarrasOctree.h
// ============================================================================

// ESVO uses fixed 23-bit mantissa precision for float bit manipulation tricks
// This is INDEPENDENT of user's octree depth - it's how ESVO normalizes [1,2] space
const int ESVO_MAX_SCALE = 22;  // Root scale in ESVO normalized space (matches C++)

// User-defined octree parameters (must match VoxelGridNode setup)
// TODO: Move these to octree UBO for runtime configuration
// For resolution 128: maxLevels=7, brickDepth=3
const int USER_MAX_LEVELS = 7;  // log2(128) = 7 levels
const int BRICK_DEPTH = 3;      // 8x8x8 bricks = 2^3

// Derived constants
const int STACK_SIZE = 23;      // Must cover full ESVO range
const int MAX_ITERS = 512;
const float EPSILON = 0.001;

// Scale mapping: Convert between user scale and ESVO internal scale
// For depth 7: userScales [0-6] map to esvoScales [16-22]
// userScale 0 (finest) -> ESVO 22-(7-1-0) = 16
// userScale 6 (root)   -> ESVO 22-(7-1-6) = 22
int userToESVOScale(int userScale) {
    return ESVO_MAX_SCALE - (USER_MAX_LEVELS - 1 - userScale);
}

int esvoToUserScale(int esvoScale) {
    return esvoScale - (ESVO_MAX_SCALE - USER_MAX_LEVELS + 1);
}

// Brick level: octants that are 8x8x8 voxels (2^BRICK_DEPTH per side)
// For resolution 128 with 8x8x8 bricks: 128/8 = 16 bricks per axis = 2^4
//
// ESVO scale_exp2 formula: At scale N, scale_exp2 = 2^(N - ESVO_MAX_SCALE - 1)
//   - Root (scale 22): scale_exp2 = 2^(22-22-1) = 0.5 => 64 world units
//   - Scale 21: scale_exp2 = 0.25 => 32 world units
//   - Scale 20: scale_exp2 = 0.125 => 16 world units
//   - Scale 19: scale_exp2 = 0.0625 => 8 world units (BRICK SIZE!)
//   - Scale 18: scale_exp2 = 0.03125 => 4 world units
//
// For 8x8x8 bricks (8 world units), we need scale_exp2 = 8/128 = 0.0625 = 2^(-4)
// Solving: 2^(N - 23) = 2^(-4) => N = 19
//
// General formula: scale = ESVO_MAX_SCALE - (USER_MAX_LEVELS - BRICK_DEPTH - 1)
//                        = 22 - (7 - 3 - 1) = 22 - 3 = 19
int getBrickESVOScale() {
    // At brick level, octant size = 2^BRICK_DEPTH world units = brick side length
    // scale_exp2 must equal 2^BRICK_DEPTH / resolution = 2^BRICK_DEPTH / 2^USER_MAX_LEVELS
    // 2^(scale - ESVO_MAX_SCALE - 1) = 2^(BRICK_DEPTH - USER_MAX_LEVELS)
    // scale = ESVO_MAX_SCALE + 1 + BRICK_DEPTH - USER_MAX_LEVELS
    return ESVO_MAX_SCALE + 1 + BRICK_DEPTH - USER_MAX_LEVELS;
}

// ============================================================================
// PUSH CONSTANTS (Camera)
// ============================================================================

layout(push_constant) uniform PushConstants {
    vec3 cameraPos;
    float time;
    vec3 cameraDir;
    float fov;
    vec3 cameraUp;
    float aspect;
    vec3 cameraRight;
    float pad;
} pc;

// ============================================================================
// DATA STRUCTURES (Matching C++ LaineKarrasOctree.h)
// ============================================================================

// Ray coefficients for parametric traversal (matches ESVORayCoefficients)
struct RayCoefficients {
    float tx_coef, ty_coef, tz_coef;
    float tx_bias, ty_bias, tz_bias;
    int octant_mask;
    vec3 rayDir;
};

// Stack entry for DFS traversal (matches CastStack)
struct StackEntry {
    uint parentPtr;
    float t_max;
};

// Traversal state (matches ESVOTraversalState)
struct TraversalState {
    uint parentPtr;
    int idx;              // Current child octant index (0-7) in MIRRORED space
    int scale;            // Current ESVO scale (16-22 for USER_MAX_LEVELS=7)
    float scale_exp2;     // 2^(scale - ESVO_MAX_SCALE)
    vec3 pos;             // Position in normalized [1,2] space
    float t_min, t_max;
    float h;              // Horizon value for stack management
};

// ============================================================================
// ESVO DESCRIPTOR HELPERS (Matching SVOTypes.h ChildDescriptor)
// ============================================================================
// C++ ChildDescriptor layout:
//   First 32 bits:
//     bits 0-14:  childPointer (15 bits) - offset to first child
//     bit 15:     farBit (1 bit) - indirect reference flag
//     bits 16-23: validMask (8 bits) - which children exist
//     bits 24-31: leafMask (8 bits) - which children are leaves
//   Second 32 bits:
//     bits 0-23:  contourPointer (24 bits)
//     bits 24-31: contourMask (8 bits)

uvec2 fetchESVONode(uint nodeIndex) {
    return esvoNodes[nodeIndex];
}

uint getValidMask(uvec2 descriptor) {
    return (descriptor.x >> 16) & 0xFFu;
}

uint getLeafMask(uvec2 descriptor) {
    return (descriptor.x >> 24) & 0xFFu;
}

uint getChildPointer(uvec2 descriptor) {
    return descriptor.x & 0x7FFFu;
}

bool childExists(uint validMask, int childIndex) {
    return ((validMask >> childIndex) & 1u) != 0u;
}

bool childIsLeaf(uint leafMask, int childIndex) {
    return ((leafMask >> childIndex) & 1u) != 0u;
}

// ============================================================================
// OCTANT MIRRORING HELPERS (Matching SVOTypes.h mirrorMask, mirroredToLocalOctant)
// ============================================================================

// Convert mirrored-space octant index to local-space (descriptor storage order)
// Formula: localIdx = mirroredIdx ^ (~octant_mask & 7)
// octant_mask bit=1 means NOT mirrored, bit=0 means IS mirrored
int mirroredToLocalOctant(int mirroredIdx, int octant_mask) {
    return mirroredIdx ^ ((~octant_mask) & 7);
}

// Convert local-space octant index to mirrored-space
int localToMirroredOctant(int localIdx, int octant_mask) {
    return localIdx ^ ((~octant_mask) & 7);
}

// ============================================================================
// CHILD COUNTING HELPERS
// ============================================================================

// Count INTERNAL (non-leaf) children before childIndex in packed array
// Only count children that EXIST (validMask bit set) AND are NOT leaves (leafMask bit clear)
uint countInternalChildrenBefore(uint validMask, uint leafMask, int childIndex) {
    if (childIndex <= 0) return 0u;
    uint mask = (1u << childIndex) - 1u;
    uint internalMask = validMask & ~leafMask;
    return bitCount(internalMask & mask);
}

// Count LEAF children before childIndex (for leaf brick lookup)
uint countLeavesBefore(uint validMask, uint leafMask, int childIndex) {
    if (childIndex <= 0) return 0u;
    uint mask = (1u << childIndex) - 1u;
    uint leafChildren = validMask & leafMask;
    return bitCount(leafChildren & mask);
}

// ============================================================================
// RAY HELPERS
// ============================================================================

vec3 getRayDir(vec2 uv) {
    float tanHalfFov = tan(radians(pc.fov * 0.5));
    vec2 ndc = uv * 2.0 - 1.0;
    vec3 rayDir = pc.cameraDir +
                  pc.cameraRight * ndc.x * tanHalfFov * pc.aspect +
                  pc.cameraUp * ndc.y * tanHalfFov;
    return normalize(rayDir);
}

vec2 rayAABBIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 invDir = 1.0 / rayDir;
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;
    vec3 tMin = min(t0, t1);
    vec3 tMax = max(t0, t1);
    float tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar = min(min(tMax.x, tMax.y), tMax.z);
    return vec2(tNear, tFar);
}

// ============================================================================
// RAY COEFFICIENT INITIALIZATION (Matching initializeRayCoefficients)
// ============================================================================

RayCoefficients initRayCoefficients(vec3 rayDir, vec3 rayStartWorld, vec3 gridMin, vec3 gridSize) {
    RayCoefficients coef;
    coef.rayDir = rayDir;

    vec3 invGridSize = 1.0 / gridSize;

    // Transform to octree space [1,2] - ESVO standard space
    vec3 p = ((rayStartWorld - gridMin) * invGridSize) + 1.0;

    // Use world-space ray direction (matching CPU implementation exactly)
    // The ESVO algorithm uses normalized [1,2] positions with world-space direction
    // This works because: for unit-length direction, t in [0,1] traverses [1,2] cube
    // (position spans 1 unit in normalized space, direction magnitude ~1)
    vec3 d = rayDir;

    // Avoid division by zero
    float epsilon_esvo = exp2(-float(ESVO_MAX_SCALE));
    float sx = d.x >= 0.0 ? 1.0 : -1.0;
    float sy = d.y >= 0.0 ? 1.0 : -1.0;
    float sz = d.z >= 0.0 ? 1.0 : -1.0;
    if (abs(d.x) < epsilon_esvo) d.x = sx * epsilon_esvo;
    if (abs(d.y) < epsilon_esvo) d.y = sy * epsilon_esvo;
    if (abs(d.z) < epsilon_esvo) d.z = sz * epsilon_esvo;

    // Parametric coefficients for ray equation: p + t*d
    coef.tx_coef = 1.0 / -abs(d.x);
    coef.ty_coef = 1.0 / -abs(d.y);
    coef.tz_coef = 1.0 / -abs(d.z);
    coef.tx_bias = coef.tx_coef * p.x;
    coef.ty_bias = coef.ty_coef * p.y;
    coef.tz_bias = coef.tz_coef * p.z;

    // Octant mirroring - CRITICAL: initialize to 7!
    // This mirrors the coordinate system so ray direction is negative along each axis
    coef.octant_mask = 7;
    if (d.x > 0.0) { coef.octant_mask ^= 1; coef.tx_bias = 3.0 * coef.tx_coef - coef.tx_bias; }
    if (d.y > 0.0) { coef.octant_mask ^= 2; coef.ty_bias = 3.0 * coef.ty_coef - coef.ty_bias; }
    if (d.z > 0.0) { coef.octant_mask ^= 4; coef.tz_bias = 3.0 * coef.tz_coef - coef.tz_bias; }

    return coef;
}

// ============================================================================
// TRAVERSAL STATE INITIALIZATION (Matching initializeTraversalState)
// ============================================================================

TraversalState initTraversalState(RayCoefficients coef, inout StackEntry stack[STACK_SIZE], bool rayStartsInside) {
    TraversalState state;

    // Root node t-span computation depends on whether ray starts inside or outside the volume
    // The ESVO paper formula assumes ray starts at origin, but we may start at grid entry point
    if (rayStartsInside) {
        // Interior ray: ray starts inside [1,2]³ space
        // t_min = 0 (we're already inside), t_max = exit from [1,2]³
        state.t_min = 0.0;
        state.t_max = min(min(coef.tx_coef - coef.tx_bias,
                             coef.ty_coef - coef.ty_bias),
                         coef.tz_coef - coef.tz_bias);
    } else {
        // Exterior ray: ray enters [1,2]³ from outside
        // Since we already moved rayStart to entry point, t_min should be ~0
        // Formula: t enters at far corner of octant (pos=2 in mirrored space)
        state.t_min = max(max(2.0 * coef.tx_coef - coef.tx_bias,
                             2.0 * coef.ty_coef - coef.ty_bias),
                         2.0 * coef.tz_coef - coef.tz_bias);
        state.t_max = min(min(coef.tx_coef - coef.tx_bias,
                             coef.ty_coef - coef.ty_bias),
                         coef.tz_coef - coef.tz_bias);
    }

    state.h = state.t_max;  // CRITICAL: h must be initialized to t_max!
    state.t_min = max(state.t_min, 0.0);
    // CPU also clamps t_max to 1.0 (see LaineKarrasOctree.cpp:1298,1309)
    state.t_max = min(state.t_max, 1.0);

    // Initialize traversal at root - use ESVO scale system
    state.parentPtr = 0u;
    state.scale = ESVO_MAX_SCALE;  // Start at root (scale 22)
    state.scale_exp2 = 0.5;  // exp2(scale - ESVO_MAX_SCALE - 1) = exp2(-1) = 0.5
    state.pos = vec3(1.0);

    // Initialize stack with root at all scales
    for (int s = 0; s < STACK_SIZE; s++) {
        stack[s].parentPtr = 0u;
        stack[s].t_max = state.t_max;
    }

    // Select initial child octant based on ray entry point (1.5 is center of [1,2])
    state.idx = 0;
    if (1.5 * coef.tx_coef - coef.tx_bias > state.t_min) { state.idx ^= 1; state.pos.x = 1.5; }
    if (1.5 * coef.ty_coef - coef.ty_bias > state.t_min) { state.idx ^= 2; state.pos.y = 1.5; }
    if (1.5 * coef.tz_coef - coef.tz_bias > state.t_min) { state.idx ^= 4; state.pos.z = 1.5; }

    return state;
}

// ============================================================================
// VOXEL CORNER COMPUTATION
// ============================================================================

void computeVoxelCorners(vec3 pos, RayCoefficients coef,
                         out float tx_corner, out float ty_corner, out float tz_corner) {
    tx_corner = pos.x * coef.tx_coef - coef.tx_bias;
    ty_corner = pos.y * coef.ty_coef - coef.ty_bias;
    tz_corner = pos.z * coef.tz_coef - coef.tz_bias;
}

// Compute corrected tc_max for axis-parallel rays
// Filters out misleading corner values from perpendicular axes
float computeCorrectedTcMax(float tx_corner, float ty_corner, float tz_corner,
                            vec3 rayDir, float t_max) {
    const float corner_threshold = 1000.0;
    const float dir_epsilon = 1e-5;

    bool useXCorner = (abs(rayDir.x) >= dir_epsilon);
    bool useYCorner = (abs(rayDir.y) >= dir_epsilon);
    bool useZCorner = (abs(rayDir.z) >= dir_epsilon);

    float tx_valid = (useXCorner && abs(tx_corner) < corner_threshold) ? tx_corner : t_max;
    float ty_valid = (useYCorner && abs(ty_corner) < corner_threshold) ? ty_corner : t_max;
    float tz_valid = (useZCorner && abs(tz_corner) < corner_threshold) ? tz_corner : t_max;

    return min(min(tx_valid, ty_valid), tz_valid);
}

// ============================================================================
// CHILD VALIDITY CHECK (Matching checkChildValidity)
// ============================================================================

bool checkChildValidity(TraversalState state, RayCoefficients coef,
                        uint validMask, uint leafMask,
                        out bool isLeaf, out float tv_max,
                        out float tx_center, out float ty_center, out float tz_center) {
    // Convert mirrored-space idx to local-space for descriptor lookup
    int localChildIdx = mirroredToLocalOctant(state.idx, coef.octant_mask);

    // Check if child exists using local-space validMask
    bool child_valid = childExists(validMask, localChildIdx);
    isLeaf = childIsLeaf(leafMask, localChildIdx);

    // Force leaf status at brick level (matches CPU behavior)
    // At brick level, treat all valid children as leaves to trigger brick DDA
    // Brick ESVO scale = 22 + 1 + 3 - 7 = 19 for resolution 128 with 8x8x8 bricks
    int brickESVOScale = getBrickESVOScale();
    if (state.scale == brickESVOScale && child_valid) {
        isLeaf = true;
    }

    if (!child_valid || state.t_min > state.t_max) {
        return false;
    }

    // Compute corner values
    float tx_corner, ty_corner, tz_corner;
    computeVoxelCorners(state.pos, coef, tx_corner, ty_corner, tz_corner);

    // Use corrected tc_max for axis-parallel rays (filters out invalid corners)
    float tc_max = computeCorrectedTcMax(tx_corner, ty_corner, tz_corner, coef.rayDir, state.t_max);
    tv_max = min(state.t_max, tc_max);

    // Compute center values for octant selection after DESCEND
    float halfScale = state.scale_exp2 * 0.5;
    tx_center = halfScale * coef.tx_coef + tx_corner;
    ty_center = halfScale * coef.ty_coef + ty_corner;
    tz_center = halfScale * coef.tz_coef + tz_corner;

    return state.t_min <= tv_max;
}

// ============================================================================
// PUSH PHASE (Matching executePushPhase)
// ============================================================================

void executePushPhase(inout TraversalState state, RayCoefficients coef,
                      inout StackEntry stack[STACK_SIZE],
                      uint validMask, uint leafMask, uint childPointer,
                      float tv_max, float tx_center, float ty_center, float tz_center) {
    // Compute tc_max for stack management
    float tx_corner, ty_corner, tz_corner;
    computeVoxelCorners(state.pos, coef, tx_corner, ty_corner, tz_corner);
    float tc_max = min(min(tx_corner, ty_corner), tz_corner);

    // Push current state to stack if needed
    if (tc_max < state.h && state.scale >= 0 && state.scale < STACK_SIZE) {
        stack[state.scale].parentPtr = state.parentPtr;
        stack[state.scale].t_max = state.t_max;
    }
    state.h = tc_max;

    // Convert mirrored idx to local space for child offset calculation
    int localChildIdx = mirroredToLocalOctant(state.idx, coef.octant_mask);

    // Calculate child offset (count non-leaf children before current in LOCAL space)
    uint childLocalIndex = countInternalChildrenBefore(validMask, leafMask, localChildIdx);
    state.parentPtr = childPointer + childLocalIndex;

    // Descend to next level
    state.idx = 0;
    state.scale--;
    float halfScale = state.scale_exp2 * 0.5;
    state.scale_exp2 = halfScale;

    // Select child octant using parent's center values
    if (tx_center > state.t_min) { state.idx ^= 1; state.pos.x += state.scale_exp2; }
    if (ty_center > state.t_min) { state.idx ^= 2; state.pos.y += state.scale_exp2; }
    if (tz_center > state.t_min) { state.idx ^= 4; state.pos.z += state.scale_exp2; }

    // Update t-span
    state.t_max = tv_max;
}

// ============================================================================
// ADVANCE PHASE (Matching executeAdvancePhase)
// ============================================================================

// Returns: 0 = CONTINUE, 1 = POP_NEEDED, 2 = EXIT_OCTREE
int executeAdvancePhase(inout TraversalState state, RayCoefficients coef, out int step_mask) {
    // Compute corner values
    float tx_corner, ty_corner, tz_corner;
    computeVoxelCorners(state.pos, coef, tx_corner, ty_corner, tz_corner);

    // Determine which axes can step (non-parallel)
    const float dir_epsilon = 1e-5;
    bool canStepX = (abs(coef.rayDir.x) >= dir_epsilon);
    bool canStepY = (abs(coef.rayDir.y) >= dir_epsilon);
    bool canStepZ = (abs(coef.rayDir.z) >= dir_epsilon);

    // Compute corrected tc_max (filters out invalid corners for axis-parallel rays)
    float tc_max = computeCorrectedTcMax(tx_corner, ty_corner, tz_corner, coef.rayDir, state.t_max);

    // Step along axes at their exit boundary (in mirrored space, pos decreases)
    // Only step axes that are non-parallel to avoid incorrect traversal
    step_mask = 0;
    if (canStepX && tx_corner <= tc_max) { step_mask ^= 1; state.pos.x -= state.scale_exp2; }
    if (canStepY && ty_corner <= tc_max) { step_mask ^= 2; state.pos.y -= state.scale_exp2; }
    if (canStepZ && tz_corner <= tc_max) { step_mask ^= 4; state.pos.z -= state.scale_exp2; }

    state.t_min = max(tc_max, 0.0);
    state.idx ^= step_mask;

    // Check if we need to POP (bit flips disagree with ray direction)
    if ((state.idx & step_mask) != 0) {
        return 1;  // POP_NEEDED
    }

    return 0;  // CONTINUE
}

// ============================================================================
// POP PHASE (Matching executePopPhase)
// ============================================================================

// Returns: 0 = CONTINUE, 1 = EXIT_OCTREE
int executePopPhase(inout TraversalState state, RayCoefficients coef,
                    inout StackEntry stack[STACK_SIZE], int step_mask) {
    // For root scale (ESVO_MAX_SCALE), check for octree exit
    if (state.scale >= ESVO_MAX_SCALE) {
        if (state.t_min > state.t_max ||
            state.pos.x < 1.0 || state.pos.x >= 2.0 ||
            state.pos.y < 1.0 || state.pos.y >= 2.0 ||
            state.pos.z < 1.0 || state.pos.z >= 2.0) {
            return 1;  // EXIT_OCTREE
        }
        return 0;  // CONTINUE at root
    }

    // Find highest differing bit to determine scale
    // Convert positions to integers in [0, 2^ESVO_MAX_SCALE) range
    // Positions are in [1,2], so subtract 1 to get [0,1], then scale
    const uint MAX_RES = 1u << ESVO_MAX_SCALE;  // 2^22 = 4194304

    uint pos_x_int = uint(clamp((state.pos.x - 1.0) * float(MAX_RES), 0.0, float(MAX_RES - 1u)));
    uint pos_y_int = uint(clamp((state.pos.y - 1.0) * float(MAX_RES), 0.0, float(MAX_RES - 1u)));
    uint pos_z_int = uint(clamp((state.pos.z - 1.0) * float(MAX_RES), 0.0, float(MAX_RES - 1u)));

    // Compute next position for stepped axes
    uint next_x_int = ((step_mask & 1) != 0) ? uint(clamp((state.pos.x + state.scale_exp2 - 1.0) * float(MAX_RES), 0.0, float(MAX_RES - 1u))) : pos_x_int;
    uint next_y_int = ((step_mask & 2) != 0) ? uint(clamp((state.pos.y + state.scale_exp2 - 1.0) * float(MAX_RES), 0.0, float(MAX_RES - 1u))) : pos_y_int;
    uint next_z_int = ((step_mask & 4) != 0) ? uint(clamp((state.pos.z + state.scale_exp2 - 1.0) * float(MAX_RES), 0.0, float(MAX_RES - 1u))) : pos_z_int;

    // Find differing bits to determine ascent level
    uint differing_bits = 0u;
    if ((step_mask & 1) != 0) differing_bits |= (pos_x_int ^ next_x_int);
    if ((step_mask & 2) != 0) differing_bits |= (pos_y_int ^ next_y_int);
    if ((step_mask & 4) != 0) differing_bits |= (pos_z_int ^ next_z_int);

    if (differing_bits == 0u) {
        return 1;  // EXIT_OCTREE
    }

    // Find highest set bit (scale)
    state.scale = findMSB(differing_bits);
    state.scale_exp2 = 1.0 / float(1u << (ESVO_MAX_SCALE - state.scale));

    // Validate scale range
    int minESVOScale = ESVO_MAX_SCALE - USER_MAX_LEVELS + 1;
    if (state.scale < minESVOScale || state.scale > ESVO_MAX_SCALE) {
        return 1;  // EXIT_OCTREE
    }

    // Restore from stack
    state.parentPtr = stack[state.scale].parentPtr;
    state.t_max = stack[state.scale].t_max;

    // Round position to voxel boundary using integer coordinates
    int shift_amount = ESVO_MAX_SCALE - state.scale;
    if (shift_amount < 0 || shift_amount >= 32) {
        return 1;  // EXIT_OCTREE
    }

    uint mask = ~((1u << shift_amount) - 1u);
    pos_x_int &= mask;
    pos_y_int &= mask;
    pos_z_int &= mask;

    // Convert back to float in [1,2] range
    state.pos.x = 1.0 + float(pos_x_int) / float(MAX_RES);
    state.pos.y = 1.0 + float(pos_y_int) / float(MAX_RES);
    state.pos.z = 1.0 + float(pos_z_int) / float(MAX_RES);

    // Extract child index from position
    int idx_shift = ESVO_MAX_SCALE - state.scale - 1;
    if (idx_shift < 0 || idx_shift >= 32) {
        state.idx = 0;
    } else {
        state.idx = int((pos_x_int >> idx_shift) & 1u) |
                   (int((pos_y_int >> idx_shift) & 1u) << 1) |
                   (int((pos_z_int >> idx_shift) & 1u) << 2);
    }

    // Prevent same parent from being stored again
    state.h = 0.0;

    return 0;  // CONTINUE
}

// ============================================================================
// BRICK DDA MARCHING (Matching traverseBrickView)
// ============================================================================

bool marchBrick(vec3 rayOrigin, vec3 rayDir, float startT,
                vec3 brickMin, vec3 brickMax, uint brickIndex,
                out vec3 hitColor, out vec3 hitNormal, out uint axisMask) {

    // Ray-AABB test for brick bounds
    vec2 brickT = rayAABBIntersection(rayOrigin, rayDir, brickMin, brickMax);
    if (brickT.y < 0.0) return false;

    float t = max(brickT.x, startT);
    if (t > brickT.y) return false;

    vec3 brickSize = brickMax - brickMin;
    vec3 voxelSize = brickSize / 8.0;

    // Start position in world space
    // FIXED: Use minimal epsilon to avoid skipping first voxel at oblique angles
    // Large epsilon can push position past voxel boundaries
    vec3 pos = rayOrigin + rayDir * (t + EPSILON * 0.01);

    // DDA setup - compute step direction and inverse direction
    // NOTE: invDir must preserve sign for correct tMax calculation
    vec3 invDir;
    invDir.x = abs(rayDir.x) > EPSILON ? 1.0 / rayDir.x : (rayDir.x >= 0.0 ? 1e20 : -1e20);
    invDir.y = abs(rayDir.y) > EPSILON ? 1.0 / rayDir.y : (rayDir.y >= 0.0 ? 1e20 : -1e20);
    invDir.z = abs(rayDir.z) > EPSILON ? 1.0 / rayDir.z : (rayDir.z >= 0.0 ? 1e20 : -1e20);

    ivec3 step = ivec3(sign(rayDir));
    vec3 deltaDist = abs(voxelSize * invDir);

    // Compute initial voxel and tMax values
    vec3 localPos = (pos - brickMin) / voxelSize;
    ivec3 currentVoxel = ivec3(floor(localPos));
    currentVoxel = clamp(currentVoxel, ivec3(0), ivec3(7));

    // Compute initial tMax - ABSOLUTE ray parameter to next voxel boundary
    // Must match CPU traverseBrickView: tMin + distToNextBoundary / abs(rayDir)
    vec3 tMax;
    for (int axis = 0; axis < 3; axis++) {
        if (abs(rayDir[axis]) < EPSILON) {
            tMax[axis] = 1e20;  // Ray parallel to axis, never crosses
        } else if (rayDir[axis] > 0.0) {
            // Next boundary is at currentVoxel + 1
            float nextBoundaryWorld = brickMin[axis] + float(currentVoxel[axis] + 1) * voxelSize[axis];
            float distToNextBoundary = nextBoundaryWorld - pos[axis];
            tMax[axis] = t + distToNextBoundary / rayDir[axis];
        } else {
            // Next boundary is at currentVoxel (min edge)
            float nextBoundaryWorld = brickMin[axis] + float(currentVoxel[axis]) * voxelSize[axis];
            float distToNextBoundary = pos[axis] - nextBoundaryWorld;  // positive distance
            tMax[axis] = t + distToNextBoundary / abs(rayDir[axis]);   // use abs() like CPU
        }
    }

    const int MAX_STEPS = 64;
    for (int i = 0; i < MAX_STEPS; i++) {
        // Check bounds
        if (any(lessThan(currentVoxel, ivec3(0))) || any(greaterThanEqual(currentVoxel, ivec3(8)))) {
            break;
        }

        // Sample brick voxel (linear index: z*64 + y*8 + x)
        uint voxelLinearIdx = uint(currentVoxel.z * 64 + currentVoxel.y * 8 + currentVoxel.x);
        uint voxelData = brickData[brickIndex * 512u + voxelLinearIdx];

        if (voxelData != 0u) {
            // Hit! Extract material ID
            uint matID = voxelData & 0xFFu;

            // Color by material ID (Cornell box palette)
            if (matID == 1u) hitColor = vec3(1.0, 0.0, 0.0);       // Red (left wall)
            else if (matID == 2u) hitColor = vec3(0.0, 1.0, 0.0);  // Green (right wall)
            else if (matID == 3u) hitColor = vec3(0.9, 0.9, 0.9);  // White (floor/ceiling/back)
            else if (matID == 4u) hitColor = vec3(1.0, 0.8, 0.0);  // Yellow (light)
            else if (matID == 5u) hitColor = vec3(0.8, 0.8, 0.8);  // Gray (tall box)
            else if (matID == 6u) hitColor = vec3(0.7, 0.7, 0.7);  // Light gray (short box)
            else hitColor = vec3(float(matID) / 10.0);             // Fallback: grayscale

            // Compute entry normal based on which axis we entered from
            hitNormal = vec3(0.0);
            if (axisMask == 1u) hitNormal.x = -float(step.x);
            else if (axisMask == 2u) hitNormal.y = -float(step.y);
            else hitNormal.z = -float(step.z);

            // First iteration: use ray direction for normal
            if (i == 0) {
                vec3 absRayDir = abs(rayDir);
                if (absRayDir.x > absRayDir.y && absRayDir.x > absRayDir.z) {
                    hitNormal = vec3(-sign(rayDir.x), 0.0, 0.0);
                } else if (absRayDir.y > absRayDir.z) {
                    hitNormal = vec3(0.0, -sign(rayDir.y), 0.0);
                } else {
                    hitNormal = vec3(0.0, 0.0, -sign(rayDir.z));
                }
            }

            return true;
        }

        // DDA step - advance to next voxel along axis with smallest tMax
        if (tMax.x < tMax.y && tMax.x < tMax.z) {
            currentVoxel.x += step.x;
            tMax.x += deltaDist.x;
            axisMask = 1u;
        } else if (tMax.y < tMax.z) {
            currentVoxel.y += step.y;
            tMax.y += deltaDist.y;
            axisMask = 2u;
        } else {
            currentVoxel.z += step.z;
            tMax.z += deltaDist.z;
            axisMask = 4u;
        }
    }

    return false;
}

// ============================================================================
// LEAF HIT HANDLING (Matching handleLeafHit)
// ============================================================================

bool handleLeafHit(TraversalState state, RayCoefficients coef,
                   vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridSize,
                   out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    // FIXED: Match CPU handleLeafHit approach - use ESVO state position with
    // directional offset to move inside the octant (not on boundary)
    //
    // The ESVO state.pos is in mirrored parametric space [1,2].
    // Convert to local space [0,1] then to world units [0, gridSize].

    // Get ray position from ESVO state (mirrored -> local conversion)
    vec3 mirroredNorm = state.pos - vec3(1.0);  // [1,2] -> [0,1]
    vec3 localNorm;
    localNorm.x = ((coef.octant_mask & 1u) != 0u) ? mirroredNorm.x : (1.0 - mirroredNorm.x);
    localNorm.y = ((coef.octant_mask & 2u) != 0u) ? mirroredNorm.y : (1.0 - mirroredNorm.y);
    localNorm.z = ((coef.octant_mask & 4u) != 0u) ? mirroredNorm.z : (1.0 - mirroredNorm.z);

    // Apply small offset in WORLD ray direction to push sample point into the octant
    // This prevents boundary ambiguity when floor() could land on either side
    // CRITICAL: localNorm is in WORLD space after unmirroring, so use world rayDir
    const float offset = 0.001;
    vec3 offsetDir;
    offsetDir.x = (rayDir.x > 0.0) ? offset : -offset;
    offsetDir.y = (rayDir.y > 0.0) ? offset : -offset;
    offsetDir.z = (rayDir.z > 0.0) ? offset : -offset;

    vec3 octantInside = localNorm + offsetDir;
    octantInside = clamp(octantInside, vec3(0.001), vec3(0.999));

    // Convert normalized [0,1] to local position [0, gridSize]
    vec3 hitPosLocal = octantInside * gridSize;
    hitPosLocal = clamp(hitPosLocal, vec3(0.001), gridSize - vec3(0.001));

    // Compute brick index from position
    const int BRICK_SIZE = 8;
    int bricksPerAxis = int(gridSize.x) / BRICK_SIZE;

    ivec3 brickCoord = ivec3(floor(hitPosLocal / float(BRICK_SIZE)));
    brickCoord = clamp(brickCoord, ivec3(0), ivec3(bricksPerAxis - 1));

    // Compute brick bounds in world space for DDA
    vec3 brickMinWorld = gridMin + vec3(brickCoord) * float(BRICK_SIZE);
    vec3 brickMaxWorld = brickMinWorld + vec3(float(BRICK_SIZE));

    uint brickIndex = uint(brickCoord.z * bricksPerAxis * bricksPerAxis +
                          brickCoord.y * bricksPerAxis +
                          brickCoord.x);

    // March through the brick's voxels
    uint axisMask;
    if (marchBrick(rayOrigin, rayDir, 0.0, brickMinWorld, brickMaxWorld, brickIndex,
                   hitColor, hitNormal, axisMask)) {
        hitT = state.t_min;
        return true;
    }

    // No solid voxel found in brick - return false without setting hitColor
    // This allows the ray to continue traversal or exit cleanly to background
    return false;
}

// ============================================================================
// MAIN ESVO TRAVERSAL (Matching castRayImpl)
// ============================================================================

bool traverseOctree(vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                    out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    // World-space AABB test
    vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);
    if (gridT.y < 0.0) {
        return false;
    }

    vec3 gridSize = gridMax - gridMin;

    // Detect if ray starts inside the volume
    // gridT.x < 0 means the ray origin is inside the AABB (entry point is behind us)
    bool rayStartsInside = (gridT.x < 0.0);

    // For exterior rays, move to entry point; for interior, use origin
    vec3 rayStartWorld;
    if (rayStartsInside) {
        rayStartWorld = rayOrigin;  // Already inside, start from current position
    } else {
        rayStartWorld = rayOrigin + rayDir * (gridT.x + EPSILON);  // Move to entry point
    }

    // Initialize ray coefficients
    RayCoefficients coef = initRayCoefficients(rayDir, rayStartWorld, gridMin, gridSize);

    // Initialize traversal stack and state
    StackEntry stack[STACK_SIZE];
    TraversalState state = initTraversalState(coef, stack, rayStartsInside);

    // Check for valid initial t-span
    if (state.t_min >= state.t_max) {
        return false;
    }

    // Main traversal loop - exit when scale exceeds root (ESVO_MAX_SCALE)
    for (int iter = 0; iter < MAX_ITERS && state.scale <= ESVO_MAX_SCALE; ++iter) {

        // Fetch current parent node
        uvec2 parent_descriptor = fetchESVONode(state.parentPtr);
        uint validMask = getValidMask(parent_descriptor);
        uint leafMask = getLeafMask(parent_descriptor);
        uint childPointer = getChildPointer(parent_descriptor);

        // Check child validity and compute t-span intersection
        bool isLeaf;
        float tv_max, tx_center, ty_center, tz_center;

        if (checkChildValidity(state, coef, validMask, leafMask,
                               isLeaf, tv_max, tx_center, ty_center, tz_center)) {

            if (isLeaf) {
                // Try to hit voxels in this brick
                if (handleLeafHit(state, coef, rayOrigin, rayDir, gridMin, gridSize,
                                  hitColor, hitNormal, hitT)) {
                    return true;
                }
                // Skip past empty brick
                state.t_min = tv_max;
            } else {
                // Internal node - PUSH & DESCEND
                executePushPhase(state, coef, stack, validMask, leafMask, childPointer,
                                 tv_max, tx_center, ty_center, tz_center);
                continue;
            }
        }

        // ADVANCE to next sibling
        int step_mask;
        int advanceResult = executeAdvancePhase(state, coef, step_mask);

        if (advanceResult == 1) {
            // POP needed
            int popResult = executePopPhase(state, coef, stack, step_mask);
            if (popResult == 1) {
                break;  // Exit octree
            }
        }
    }

    // No hit - hitColor is undefined, caller should use background
    return false;
}

// ============================================================================
// SHADING
// ============================================================================

vec3 shade(vec3 hitColor, vec3 hitNormal, vec3 rayDir) {
    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
    float NdotL = max(dot(hitNormal, lightDir), 0.0);
    vec3 ambient = hitColor * 0.2;
    vec3 diffuse = hitColor * NdotL * 0.8;
    return ambient + diffuse;
}

// ============================================================================
// MAIN
// ============================================================================

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(imageSize);
    vec3 rayOrigin = pc.cameraPos;
    vec3 rayDir = getRayDir(uv);

    vec3 color = vec3(0.0);
    float hitT = 0.0;  // Declare at function scope for alpha

    // Grid bounds for octree
    vec3 gridMin = vec3(0.0, 0.0, 0.0);
    vec3 gridMax = vec3(128.0, 128.0, 128.0);

    vec2 gridT = rayAABBIntersection(rayOrigin, rayDir, gridMin, gridMax);

    if (gridT.y >= 0.0) {
        // Ray hits bounding box - try traversal with debug
        vec3 hitColor, hitNormal;

        // Attempt ESVO traversal
        bool hit = traverseOctree(rayOrigin, rayDir, gridMin, gridMax, hitColor, hitNormal, hitT);

        if (hit) {
            // Successful hit - show voxel color with simple lighting
            vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
            float ndotl = max(dot(hitNormal, lightDir), 0.0);
            color = hitColor * (0.3 + 0.7 * ndotl);
        } else {
            // Ray traversed octree but didn't hit solid geometry
            // Show background gradient (same as AABB miss case)
            color = vec3(0.5, 0.7, 1.0) * (1.0 - uv.y * 0.5);
        }
    } else {
        // Background gradient
        color = vec3(0.5, 0.7, 1.0) * (1.0 - uv.y * 0.5);
        // hitT already 0.0 from initialization
    }

    // Alpha = depth (more opaque the deeper we go)
    float alpha = clamp(hitT, 0.2, 1.0);  // Min 0.2 so we always see something
    imageStore(outputImage, pixelCoords, vec4(color, alpha));
}
