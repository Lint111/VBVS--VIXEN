#version 460
#extension GL_GOOGLE_include_directive : require

// ============================================================================
// VoxelRayMarch.comp - Uncompressed Voxel Ray Marching (Refactored)
// ============================================================================
// Reads voxel color from material palette via brickData material index.
// Uses shared include files for ESVO traversal algorithm.
// ============================================================================

#include "SVOTypes.glsl"
#include "Materials.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BUFFER BINDINGS (Must be defined BEFORE includes)
// ============================================================================

layout(binding = 0) uniform writeonly image2D outputImage;

layout(std430, binding = 1) readonly buffer ESVOBuffer {
    uvec2 esvoNodes[];
};

layout(std430, binding = 2) readonly buffer BrickBuffer {
    uint brickData[];
};

layout(std430, binding = 3) readonly buffer MaterialBuffer {
    Material materials[];
};

layout(std430, binding = 4) buffer RayTraceBuffer {
    uint traceWriteIndex;
    uint traceCapacity;
    uint _padding[2];
    uint traceData[];
};

layout(std140, binding = 5) uniform OctreeConfigUBO {
    int esvoMaxScale;
    int userMaxLevels;
    int brickDepthLevels;
    int brickSize;
    int minESVOScale;
    int brickESVOScale;
    int bricksPerAxis;
    int _padding1;
    vec3 gridMin;
    float _padding2;
    vec3 gridMax;
    float _padding3;
    mat4 localToWorld;
    mat4 worldToLocal;
    float _padding4[16];
} octreeConfig;

// ============================================================================
// PUSH CONSTANTS
// ============================================================================

// Debug visualization modes (controlled by 1-9 keys)
#define DEBUG_MODE_NORMAL 0
#define DEBUG_MODE_OCTANT 1
#define DEBUG_MODE_DEPTH 2
#define DEBUG_MODE_ITERATIONS 3
#define DEBUG_MODE_T_SPAN 4
#define DEBUG_MODE_NORMALS 5
#define DEBUG_MODE_POSITION 6
#define DEBUG_MODE_BRICKS 7
#define DEBUG_MODE_MATERIALS 8

layout(push_constant) uniform PushConstants {
    vec3 cameraPos;
    float time;
    vec3 cameraDir;
    float fov;
    vec3 cameraUp;
    float aspect;
    vec3 cameraRight;
    int debugMode;
} pc;

// ============================================================================
// SHARED INCLUDES (Order matters - dependencies must come first)
// ============================================================================

#include "CoordinateTransforms.glsl"
#include "RayGeneration.glsl"
#include "ESVOCoefficients.glsl"
#include "TraceRecording.glsl"
#include "ESVOTraversal.glsl"
#include "Lighting.glsl"

// ============================================================================
// DEBUG FLAGS (Shader-specific)
// ============================================================================

#define DEBUG_OCTANT_MASK 0
#define DEBUG_ISOLATE_OCTANT 0
#define DEBUG_ONLY_OCTANT 0
#define DEBUG_FORCE_OCTANT_ZERO 0
#define DEBUG_LOCAL_NORM 0
#define DEBUG_BRICK_COORD 0
#define DEBUG_FIRST_VOXEL 0
#define DEBUG_RAY_BRICK_LOOKUP 0
#define DEBUG_BYPASS_ESVO 0
#define DEBUG_AXIS_PARALLEL 0
#define DEBUG_BRICK_MISS 0
#define DEBUG_DDA_START_VOXEL 0

// ============================================================================
// BRICK DDA MARCHING (Shader-specific - uncompressed brick data)
// ============================================================================

bool marchBrickFromPos(vec3 rayDir, vec3 posInBrick, uint brickIndex,
                       out vec3 hitColor, out vec3 hitNormal, out uint axisMask,
                       out vec3 hitBrickLocalPos) {
    ivec3 currentVoxel = ivec3(floor(posInBrick));
    currentVoxel = clamp(currentVoxel, ivec3(0), ivec3(7));

#if DEBUG_DDA_START_VOXEL
    hitColor = vec3(currentVoxel) / 7.0;
    hitNormal = vec3(0.0, 1.0, 0.0);
    axisMask = 0u;
    hitBrickLocalPos = vec3(0.0);
    return true;
#endif

    ivec3 step = ivec3(sign(rayDir));
    if (step.x == 0) step.x = 1;
    if (step.y == 0) step.y = 1;
    if (step.z == 0) step.z = 1;

    int BRICK_SIZE_VAL = octreeConfig.brickSize;
    if ((posInBrick.x <= 0.001 && rayDir.x < 0.0) || (posInBrick.x >= float(BRICK_SIZE_VAL)-0.001 && rayDir.x > 0.0) ||
        (posInBrick.y <= 0.001 && rayDir.y < 0.0) || (posInBrick.y >= float(BRICK_SIZE_VAL)-0.001 && rayDir.y > 0.0) ||
        (posInBrick.z <= 0.001 && rayDir.z < 0.0) || (posInBrick.z >= float(BRICK_SIZE_VAL)-0.001 && rayDir.z > 0.0)) {
        recordTraceStep(5u, brickIndex, 0, 0u, posInBrick, 0.0, 0.0, uvec2(0, 0));
        return false;
    }

    vec3 deltaDist;
    deltaDist.x = abs(rayDir.x) > DIR_EPSILON ? 1.0 / abs(rayDir.x) : 1e20;
    deltaDist.y = abs(rayDir.y) > DIR_EPSILON ? 1.0 / abs(rayDir.y) : 1e20;
    deltaDist.z = abs(rayDir.z) > DIR_EPSILON ? 1.0 / abs(rayDir.z) : 1e20;

    vec3 tMax;
    const float MIN_DIST = 0.0001;
    for (int axis = 0; axis < 3; axis++) {
        if (abs(rayDir[axis]) < DIR_EPSILON) {
            tMax[axis] = 1e20;
        } else {
            float posLocal = posInBrick[axis];
            float distToNext;
            if (rayDir[axis] > 0.0) {
                distToNext = float(currentVoxel[axis] + 1) - posLocal;
            } else {
                distToNext = posLocal - float(currentVoxel[axis]);
            }
            distToNext = max(distToNext, MIN_DIST);
            tMax[axis] = distToNext / abs(rayDir[axis]);
        }
    }

    axisMask = 0u;
    const int MAX_STEPS = 300;
    for (int i = 0; i < MAX_STEPS; i++) {
        recordTraceStep(4u, brickIndex, 0, 0u, vec3(currentVoxel), tMax.x, tMax.y, uvec2(0, 0));

        if (any(lessThan(currentVoxel, ivec3(0))) || any(greaterThanEqual(currentVoxel, ivec3(8)))) {
            break;
        }

        uint voxelLinearIdx = uint(currentVoxel.z * 64 + currentVoxel.y * 8 + currentVoxel.x);
        uint voxelData = brickData[brickIndex * 512u + voxelLinearIdx];

        if (voxelData != 0u) {
            uint matID = voxelData & 0xFFu;
            hitColor = getMaterialColor(matID);

            hitNormal = vec3(0.0);
            if (axisMask == 1u) hitNormal.x = -float(step.x);
            else if (axisMask == 2u) hitNormal.y = -float(step.y);
            else hitNormal.z = -float(step.z);

            if (i == 0) {
                vec3 absRayDir = abs(rayDir);
                if (absRayDir.x > absRayDir.y && absRayDir.x > absRayDir.z) {
                    hitNormal = vec3(-sign(rayDir.x), 0.0, 0.0);
                } else if (absRayDir.y > absRayDir.z) {
                    hitNormal = vec3(0.0, -sign(rayDir.y), 0.0);
                } else {
                    hitNormal = vec3(0.0, 0.0, -sign(rayDir.z));
                }
            }

            hitBrickLocalPos = vec3(currentVoxel) + vec3(0.5);
            return true;
        }

        if (tMax.x < tMax.y && tMax.x < tMax.z) {
            currentVoxel.x += step.x;
            tMax.x += deltaDist.x;
            axisMask = 1u;
        } else if (tMax.y < tMax.z) {
            currentVoxel.y += step.y;
            tMax.y += deltaDist.y;
            axisMask = 2u;
        } else {
            currentVoxel.z += step.z;
            tMax.z += deltaDist.z;
            axisMask = 4u;
        }
    }

#if DEBUG_BRICK_MISS
    hitColor = vec3(0.0, 1.0, 1.0);
    hitNormal = vec3(0.0, 1.0, 0.0);
    return true;
#endif
    return false;
}

// ============================================================================
// LEAF HIT HANDLING - DESCRIPTOR-BASED SPARSE BRICK LOOKUP
// ============================================================================

bool handleLeafHit(TraversalState state, RayCoefficients coef,
                   vec3 rayStartWorld, vec3 rayDir, float tBias,
                   uvec2 parentDescriptor, uint validMask, uint leafMask, uint parentNodeIndex,
                   inout StackEntry stack[STACK_SIZE],
                   out vec3 hitColor, out vec3 hitNormal, out float hitT) {

    int BRICK_SIZE_VAL = octreeConfig.brickSize;

    int localChildIdx = mirroredToLocalOctant(state.idx, coef.octant_mask);
    if (localChildIdx < 0 || localChildIdx > 7) {
        recordTraceStep(8u, 0, 0, 0u, vec3(0), 0.0, 0.0, uvec2(0));
        return false;
    }

    uint childPointer = getChildPointer(parentDescriptor);
    uint totalInternalChildren = bitCount(validMask & ~leafMask);
    uint leafChildrenBeforeMe = countLeavesBefore(validMask, leafMask, localChildIdx);
    uint leafDescriptorIndex = childPointer + totalInternalChildren + leafChildrenBeforeMe;

    uvec2 leafDescriptor = fetchESVONode(leafDescriptorIndex);
    uint brickIndex = getContourPointer(leafDescriptor);

    // Note: brickIndex 0 IS valid - only reject SVO_INVALID_INDEX (0xFFFFFF)
    if (brickIndex == SVO_INVALID_INDEX) {
        recordTraceStep(9u, leafDescriptorIndex, 0, brickIndex, vec3(0), 0.0, 0.0, leafDescriptor);
        return false;
    }

    // Use coef.normOrigin directly (already in [1,2] space) - matches compressed shader logic
    float tHit = state.t_min;
    vec3 rayDirLocal = mat3(octreeConfig.worldToLocal) * rayDir;
    vec3 hitPos12 = coef.normOrigin + rayDirLocal * tHit;

    // Compute posInBrick using shared helper (handles mirroring correctly)
    vec3 posInBrick = computePosInBrick(hitPos12, state.pos, state.scale_exp2, coef.octant_mask, BRICK_SIZE_VAL);
    posInBrick = clamp(posInBrick, vec3(0.0), vec3(float(BRICK_SIZE_VAL) - 0.001));

    vec3 brickHitColor, brickHitNormal;
    uint axisMask;
    vec3 hitBrickLocalPos;
    if (marchBrickFromPos(rayDir, posInBrick, brickIndex, brickHitColor, brickHitNormal, axisMask, hitBrickLocalPos)) {
        hitColor = brickHitColor;
        hitNormal = brickHitNormal;
        hitT = tBias + tHit;
        return true;
    }

    return false;
}

// ============================================================================
// MAIN TRAVERSAL LOOP
// ============================================================================

bool traverseOctree(vec3 rayOrigin, vec3 rayDir, vec3 gridMin, vec3 gridMax,
                    out vec3 hitColor, out vec3 hitNormal, out float hitT,
                    inout DebugRaySample debugInfo) {

    debugInfo.hitFlag = 0u;
    debugInfo.exitCode = DEBUG_EXIT_NONE;
    debugInfo.lastStepMask = 0u;
    debugInfo.iterationCount = 0u;

    vec3 rayOriginLocal = (octreeConfig.worldToLocal * vec4(rayOrigin, 1.0)).xyz;
    vec3 rayDirLocal = mat3(octreeConfig.worldToLocal) * rayDir;

    vec2 gridT = rayAABBIntersection(rayOriginLocal, rayDirLocal, vec3(0.0), vec3(1.0));
    if (gridT.y < 0.0) {
        debugInfo.exitCode = DEBUG_EXIT_INVALID_SPAN;
        debugInfo.tMin = gridT.x;
        debugInfo.tMax = gridT.y;
        return false;
    }

    bool rayStartsInside = (gridT.x < 0.0);

    vec3 rayStartWorld;
    float tEntryWorld = 0.0;
    if (rayStartsInside) {
        rayStartWorld = rayOrigin;
        tEntryWorld = 0.0;
    } else {
        vec3 entryPointLocal = rayOriginLocal + rayDirLocal * (gridT.x + EPSILON);
        rayStartWorld = (octreeConfig.localToWorld * vec4(entryPointLocal, 1.0)).xyz;
        tEntryWorld = length(rayStartWorld - rayOrigin);
    }

    RayCoefficients coef = initRayCoefficients(rayDir, rayStartWorld);
    debugInfo.octantMask = uint(coef.octant_mask);

    StackEntry stack[STACK_SIZE];
    TraversalState state = initTraversalState(coef, stack, rayStartsInside);
    snapshotTraversalState(state, coef, debugInfo);

    ivec2 pixelCoords = ivec2(debugInfo.pixel);
    bool isTracing = beginRayTrace(pixelCoords);

    if (state.t_min >= state.t_max) {
        snapshotTraversalState(state, coef, debugInfo);
        debugInfo.exitCode = DEBUG_EXIT_INVALID_SPAN;
        debugInfo.iterationCount = 0u;
        recordTraceStep(TRACE_STEP_MISS, state.parentPtr, state.scale, uint(state.idx),
                        state.pos, state.t_min, state.t_max, uvec2(0u));
        endRayTrace(false);
        return false;
    }

    int iter = 0;
    for (; iter < MAX_ITERS && state.scale <= octreeConfig.esvoMaxScale; ++iter) {

        uvec2 parent_descriptor = fetchESVONode(state.parentPtr);
        uint validMask = getValidMask(parent_descriptor);
        uint leafMask = getLeafMask(parent_descriptor);
        uint childPointer = getChildPointer(parent_descriptor);

        bool isLeaf;
        float tv_max, tx_center, ty_center, tz_center;

        if (checkChildValidity(state, coef, validMask, leafMask,
                               isLeaf, tv_max, tx_center, ty_center, tz_center)) {

            if (isLeaf) {
                recordTraceStep(TRACE_STEP_BRICK_ENTER, state.parentPtr, state.scale, uint(state.idx),
                                state.pos, state.t_min, tv_max, parent_descriptor);

                float tBias = tEntryWorld;
                if (handleLeafHit(state, coef, rayStartWorld, rayDir, tBias,
                                  parent_descriptor, validMask, leafMask, state.parentPtr,
                                  stack, hitColor, hitNormal, hitT)) {
                    recordTraceStep(TRACE_STEP_HIT, state.parentPtr, state.scale, uint(state.idx),
                                    state.pos, state.t_min, tv_max, parent_descriptor);
                    endRayTrace(true);

                    snapshotTraversalState(state, coef, debugInfo);
                    debugInfo.hitFlag = 1u;
                    debugInfo.exitCode = DEBUG_EXIT_HIT;
                    debugInfo.iterationCount = uint(iter + 1);
                    return true;
                }

                recordTraceStep(TRACE_STEP_BRICK_EXIT, state.parentPtr, state.scale, uint(state.idx),
                                state.pos, state.t_min, tv_max, parent_descriptor);

                state.t_min = tv_max;
                snapshotTraversalState(state, coef, debugInfo);
            } else {
                executePushPhase(state, coef, stack, validMask, leafMask, childPointer,
                                 tv_max, tx_center, ty_center, tz_center);

                recordTraceStep(TRACE_STEP_PUSH, state.parentPtr, state.scale, uint(state.idx),
                                state.pos, state.t_min, state.t_max, parent_descriptor);

                snapshotTraversalState(state, coef, debugInfo);
                continue;
            }
        }

        int step_mask;
        int advanceResult = executeAdvancePhase(state, coef, step_mask);

        recordTraceStep(TRACE_STEP_ADVANCE, state.parentPtr, state.scale, uint(state.idx),
                        state.pos, state.t_min, state.t_max, parent_descriptor);

        debugInfo.lastStepMask = uint(step_mask);
        snapshotTraversalState(state, coef, debugInfo);

        if (advanceResult == 0) {
             if (state.scale < octreeConfig.esvoMaxScale) {
                 state.t_max = stack[state.scale + 1].t_max;
             }
        }

        if (advanceResult == 1) {
            int popResult = executePopPhase(state, coef, stack, step_mask);

            recordTraceStep(TRACE_STEP_POP, state.parentPtr, state.scale, uint(state.idx),
                            state.pos, state.t_min, state.t_max, uvec2(0u));

            snapshotTraversalState(state, coef, debugInfo);
            if (popResult == 1) {
                recordTraceStep(TRACE_STEP_MISS, state.parentPtr, state.scale, uint(state.idx),
                                state.pos, state.t_min, state.t_max, uvec2(0u));
                endRayTrace(false);

                debugInfo.exitCode = DEBUG_EXIT_STACK;
                debugInfo.iterationCount = uint(iter + 1);
                return false;
            }
        }
    }

    recordTraceStep(TRACE_STEP_MISS, state.parentPtr, state.scale, uint(state.idx),
                    state.pos, state.t_min, state.t_max, uvec2(0u));
    endRayTrace(false);

    debugInfo.exitCode = DEBUG_EXIT_NO_HIT;
    debugInfo.iterationCount = uint(iter);
    return false;
}

// ============================================================================
// MAIN
// ============================================================================

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(imageSize);
    vec3 rayOrigin = pc.cameraPos;
    vec3 rayDir = getRayDir(uv);

    vec3 color = vec3(0.0);
    float hitT = 0.0;
    DebugRaySample debugSample;
    debugSample.pixel = uvec2(pixelCoords);
    debugSample.rayDir = rayDir;
    debugSample.octantMask = 0u;
    debugSample.hitFlag = 0u;
    debugSample.exitCode = DEBUG_EXIT_NONE;
    debugSample.lastStepMask = 0u;
    debugSample.iterationCount = 0u;
    debugSample.scale = octreeConfig.esvoMaxScale;
    debugSample.stateIdx = 0u;
    debugSample.tMin = 0.0;
    debugSample.tMax = 0.0;
    debugSample.scaleExp2 = 0.0;
    debugSample.posMirrored = vec3(0.0);
    debugSample.localNorm = vec3(0.0);

    vec3 gridMin = octreeConfig.gridMin;
    vec3 gridMax = octreeConfig.gridMax;

    vec3 rayOriginLocal = (octreeConfig.worldToLocal * vec4(rayOrigin, 1.0)).xyz;
    vec3 rayDirLocal = mat3(octreeConfig.worldToLocal) * rayDir;

    vec2 gridT = rayAABBIntersection(rayOriginLocal, rayDirLocal, vec3(0.0), vec3(1.0));

    if (gridT.y >= 0.0) {
        vec3 hitColor, hitNormal;

        bool hit = traverseOctree(rayOrigin, rayDir, vec3(0.0), vec3(1.0),
                                  hitColor, hitNormal, hitT, debugSample);

        if (hit) {
            color = computeLighting(hitColor, hitNormal, rayDir);
        } else {
            color = vec3(0.5, 0.7, 1.0) * (1.0 - uv.y * 0.5);
        }
    } else {
        color = vec3(0.5, 0.7, 1.0) * (1.0 - uv.y * 0.5);
    }

    // Debug visualization modes
    if (pc.debugMode > 0) {
        switch (pc.debugMode) {
            case DEBUG_MODE_OCTANT:
                color = vec3(
                    float(debugSample.octantMask & 1u),
                    float((debugSample.octantMask >> 1u) & 1u),
                    float((debugSample.octantMask >> 2u) & 1u)
                );
                break;

            case DEBUG_MODE_DEPTH:
                {
                    float normalizedScale = float(debugSample.scale - 16) / float(octreeConfig.esvoMaxScale - 16);
                    color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), normalizedScale);
                }
                break;

            case DEBUG_MODE_ITERATIONS:
                {
                    float normalizedIter = float(debugSample.iterationCount) / 100.0;
                    color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), clamp(normalizedIter, 0.0, 1.0));
                }
                break;

            case DEBUG_MODE_T_SPAN:
                color = vec3(debugSample.tMin * 0.1, debugSample.tMax * 0.1, 0.0);
                break;

            case DEBUG_MODE_NORMALS:
                color = normalShading(debugSample.localNorm);
                break;

            case DEBUG_MODE_POSITION:
                color = debugSample.posMirrored - vec3(1.0);
                break;
        }
    }

    imageStore(outputImage, pixelCoords, vec4(color, 1.0));
}
