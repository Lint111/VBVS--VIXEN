#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

// ============================================================================
// VoxelRT_Compressed.rchit - Compressed Closest Hit Shader (Phase K: Hardware RT)
// ============================================================================
// Called when a ray hits the closest voxel AABB.
// Uses DXT-compressed color/normal buffers with brick mapping for lookup.
//
// COMPRESSION: Uses same DXT compression scheme as VoxelRayMarch_Compressed.comp
// - Color:  32 blocks * 8 bytes  = 256 bytes per brick
// - Normal: 32 blocks * 16 bytes = 512 bytes per brick
// - Total:  768 bytes per brick (4:1 compression vs uncompressed)
//
// BINDING LAYOUT (consistent with VoxelRT.rchit):
// - Binding 3: materialIdBuffer (same as uncompressed)
// - Binding 5: octreeConfig (UBO, same as uncompressed)
// - Binding 6: compressedColors (DXT1 color blocks) [compressed only]
// - Binding 7: compressedNormals (DXT normal blocks) [compressed only]
// - Binding 8: brickMapping (SSBO) - Maps gl_PrimitiveID to (brickIndex, localVoxelIdx)
// ============================================================================

#include "Compression.glsl"

// Hit attributes from intersection shader
hitAttributeEXT vec3 hitNormal;

// Ray payload - color output
layout(location = 0) rayPayloadInEXT vec3 hitColor;

// Material ID buffer - indexed by gl_PrimitiveID to get material
// Same binding as uncompressed shader for consistent naming
layout(std430, binding = 3) readonly buffer MaterialIdBuffer {
    uint materialIds[];  // Material IDs (512 per brick)
} materialIdBuffer;

// DXT1 compressed colors - 32 blocks per brick, 8 bytes (uvec2) per block
layout(std430, binding = 6) readonly buffer CompressedColorBuffer {
    uvec2 compressedColors[];
};

// DXT compressed normals - 32 blocks per brick, 16 bytes (uvec4) per block
layout(std430, binding = 7) readonly buffer CompressedNormalBuffer {
    uvec4 compressedNormals[];
};

// Brick mapping buffer - one entry per AABB primitive
// Maps gl_PrimitiveID to (brickIndex, localVoxelIdx) for compressed buffer access
// Generated by VoxelAABBConverterNode during AABB extraction
layout(std430, binding = 8) readonly buffer BrickMappingBuffer {
    uvec2 brickMapping[];  // .x = brickIndex, .y = localVoxelIdx (0-511)
};

// OctreeConfigUBO - matches compute shader binding 5
layout(std140, binding = 5) uniform OctreeConfigUBO {
    int esvoMaxScale;
    int userMaxLevels;
    int brickDepthLevels;
    int brickSize;
    int minESVOScale;
    int brickESVOScale;
    int bricksPerAxis;
    int _padding1;
    vec3 gridMin;
    float _padding2;
    vec3 gridMax;
    float _padding3;
    mat4 localToWorld;
    mat4 worldToLocal;
} octreeConfig;

// Push constants (same as compute shader)
layout(push_constant) uniform PushConstants {
    vec3 cameraPos;
    float time;
    vec3 cameraDir;
    float fov;
    vec3 cameraUp;
    float aspect;
    vec3 cameraRight;
    int debugMode;
} pc;

// ============================================================================
// COMPRESSED BUFFER ACCESS FUNCTIONS
// ============================================================================

uvec2 loadColorBlock(uint brickIndex, int voxelLinearIdx) {
    int blockIdx = voxelLinearIdx >> 4;
    return compressedColors[brickIndex * 32u + uint(blockIdx)];
}

void loadNormalBlocks(uint brickIndex, int voxelLinearIdx, out uvec2 blockA, out uvec2 blockB) {
    int blockIdx = voxelLinearIdx >> 4;
    uvec4 packed = compressedNormals[brickIndex * 32u + uint(blockIdx)];
    blockA = packed.xy;
    blockB = packed.zw;
}

vec3 getCompressedVoxelColor(uint brickIndex, int voxelLinearIdx) {
    uvec2 block = loadColorBlock(brickIndex, voxelLinearIdx);
    int texelIdx = voxelLinearIdx & 15;
    return decodeDXT1Color(block, texelIdx);
}

vec3 getCompressedVoxelNormal(uint brickIndex, int voxelLinearIdx) {
    uvec2 blockA, blockB;
    loadNormalBlocks(brickIndex, voxelLinearIdx, blockA, blockB);
    int texelIdx = voxelLinearIdx & 15;
    return normalize(decodeDXTNormal(blockA, blockB, texelIdx));
}

// Lighting computation - matches compute shader (Lighting.glsl)
vec3 computeLighting(vec3 baseColor, vec3 normal, vec3 rayDir) {
    // Simple directional light from upper-right (same as compute)
    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));

    // Basic diffuse lighting
    float NdotL = max(dot(normal, lightDir), 0.0);

    // Ambient term (matches compute shader)
    float ambient = 0.3;

    // Final color with lighting
    float lighting = ambient + (1.0 - ambient) * NdotL;
    return baseColor * lighting;
}

// Material color lookup - fallback when compressed access fails
vec3 getMaterialColor(uint matID) {
    if (matID == 1u) return vec3(1.0, 0.0, 0.0);      // Red
    else if (matID == 2u) return vec3(0.0, 1.0, 0.0); // Green
    else if (matID == 3u) return vec3(0.9, 0.9, 0.9); // Light gray (white wall)
    else if (matID == 4u) return vec3(1.0, 0.8, 0.0); // Yellow/Gold
    else if (matID == 5u) return vec3(0.8, 0.8, 0.8); // Medium gray
    else if (matID == 6u) return vec3(0.7, 0.7, 0.7); // Darker gray
    else return vec3(float(matID) / 10.0);            // Fallback gradient
}

void main() {
    // Get ray direction (in local voxel space, matches rgen)
    vec3 rayDir = gl_WorldRayDirectionEXT;

    // Normalize the hit normal from intersection shader
    vec3 N = normalize(hitNormal);

    // Get brick mapping from buffer using primitive ID
    // This maps the AABB primitive to its brick and local voxel position
    uvec2 mapping = brickMapping[gl_PrimitiveID];
    uint brickIndex = mapping.x;
    int localVoxelIdx = int(mapping.y);

    // Get compressed color from DXT1 buffer
    vec3 baseColor = getCompressedVoxelColor(brickIndex, localVoxelIdx);

    // Get compressed normal from DXT buffer (use if hitNormal is unreliable)
    // For now, use intersection shader's hitNormal since it's per-face accurate
    // vec3 compressedNormal = getCompressedVoxelNormal(brickIndex, localVoxelIdx);

    // Apply lighting
    hitColor = computeLighting(baseColor, N, rayDir);

    // Debug modes (aligned with compute shader debug modes)
    if (pc.debugMode > 0) {
        vec3 hitPos = gl_WorldRayOriginEXT + gl_WorldRayDirectionEXT * gl_HitTEXT;
        uint matID = materialIdBuffer.materialIds[gl_PrimitiveID];

        switch (pc.debugMode) {
            case 2:  // DEBUG_MODE_DEPTH
                {
                    float depth = gl_HitTEXT / 100.0;
                    hitColor = vec3(depth, depth * 0.5, 1.0 - depth);
                }
                break;

            case 5:  // DEBUG_MODE_NORMALS
                hitColor = N * 0.5 + 0.5;
                break;

            case 6:  // DEBUG_MODE_POSITION
                hitColor = fract(hitPos);
                break;

            case 8:  // DEBUG_MODE_MATERIALS
                hitColor = vec3(float(matID) / 10.0, float(matID % 3u) / 3.0, float(matID % 5u) / 5.0);
                break;

            case 9:  // DEBUG_MODE_BRICK_INDEX (new debug mode for compressed RTX)
                {
                    // Visualize brick index as color (useful for debugging brick mapping)
                    float r = float(brickIndex % 8u) / 7.0;
                    float g = float((brickIndex / 8u) % 8u) / 7.0;
                    float b = float((brickIndex / 64u) % 8u) / 7.0;
                    hitColor = vec3(r, g, b);
                }
                break;

            case 10: // DEBUG_MODE_LOCAL_VOXEL_IDX (new debug mode for compressed RTX)
                {
                    // Visualize local voxel index within brick
                    float idx = float(localVoxelIdx) / 511.0;  // Normalize 0-511 to 0-1
                    hitColor = vec3(idx, 1.0 - idx, 0.5);
                }
                break;
        }
    }
}
