#version 460
#extension GL_EXT_ray_tracing : require

// ============================================================================
// VoxelRT.rint - Intersection Shader (Phase K: Hardware Ray Tracing)
// ============================================================================
// Custom intersection test for voxel AABBs.
// Called by hardware for each AABB that the ray potentially intersects.
// Reports hit via reportIntersectionEXT if ray hits the AABB.
// ============================================================================

// Hit attributes passed to closest-hit shader
hitAttributeEXT vec3 hitNormal;

void main() {
    // gl_ObjectRayOriginEXT - ray origin in object space
    // gl_ObjectRayDirectionEXT - ray direction in object space
    // gl_RayTminEXT - minimum t value
    // gl_RayTmaxEXT - maximum t value (current closest hit)

    // The AABB bounds are implicitly defined by the geometry.
    // For procedural AABBs, we get the primitive ID to look up actual bounds.
    // In our case, each voxel AABB is unit-sized at its stored position.

    vec3 rayOrigin = gl_ObjectRayOriginEXT;
    vec3 rayDir = gl_ObjectRayDirectionEXT;
    vec3 invDir = 1.0 / rayDir;

    // AABB bounds - each voxel AABB was stored with its actual min/max
    // The hardware already knows the AABB bounds, so we just test intersection
    // For unit cube at origin (0,0,0) to (1,1,1) in object space:
    vec3 aabbMin = vec3(0.0);
    vec3 aabbMax = vec3(1.0);

    // Ray-AABB intersection (slab method)
    vec3 t0 = (aabbMin - rayOrigin) * invDir;
    vec3 t1 = (aabbMax - rayOrigin) * invDir;

    vec3 tMin = min(t0, t1);
    vec3 tMax = max(t0, t1);

    float tEnter = max(max(tMin.x, tMin.y), tMin.z);
    float tExit = min(min(tMax.x, tMax.y), tMax.z);

    // Check for valid intersection
    if (tEnter <= tExit && tExit >= gl_RayTminEXT && tEnter <= gl_RayTmaxEXT) {
        // Use entry point if ray starts outside, otherwise use tMin
        float hitT = tEnter;
        if (hitT < gl_RayTminEXT) {
            hitT = tExit;
        }

        // Compute hit normal based on which face was hit
        vec3 hitPoint = rayOrigin + rayDir * hitT;

        // Determine which face was hit by finding which component is closest to boundary
        vec3 d0 = abs(hitPoint - aabbMin);
        vec3 d1 = abs(hitPoint - aabbMax);

        hitNormal = vec3(0.0);
        float minDist = 1e10;

        if (d0.x < minDist) { minDist = d0.x; hitNormal = vec3(-1.0, 0.0, 0.0); }
        if (d1.x < minDist) { minDist = d1.x; hitNormal = vec3(1.0, 0.0, 0.0); }
        if (d0.y < minDist) { minDist = d0.y; hitNormal = vec3(0.0, -1.0, 0.0); }
        if (d1.y < minDist) { minDist = d1.y; hitNormal = vec3(0.0, 1.0, 0.0); }
        if (d0.z < minDist) { minDist = d0.z; hitNormal = vec3(0.0, 0.0, -1.0); }
        if (d1.z < minDist) { hitNormal = vec3(0.0, 0.0, 1.0); }

        // Report intersection
        // hitKind: 0 for front face, 1 for back face
        uint hitKind = (tEnter < gl_RayTminEXT) ? 1u : 0u;
        reportIntersectionEXT(hitT, hitKind);
    }
}
