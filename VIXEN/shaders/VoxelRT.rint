#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require

// ============================================================================
// VoxelRT.rint - Intersection Shader (Phase K: Hardware Ray Tracing)
// ============================================================================
// Custom intersection test for voxel AABBs.
// Called by hardware for each AABB that the ray potentially intersects.
// Reports hit via reportIntersectionEXT if ray hits the AABB.
// ============================================================================

// AABB structure matching VoxelAABB in C++ (24 bytes)
struct AABB {
    float minX, minY, minZ;
    float maxX, maxY, maxZ;
};

// AABB buffer for looking up voxel bounds by primitive ID
layout(binding = 2, set = 0, scalar) readonly buffer AABBBuffer {
    AABB aabbs[];
} aabbBuffer;

// Hit attributes passed to closest-hit shader
hitAttributeEXT vec3 hitNormal;

void main() {
    // gl_ObjectRayOriginEXT - ray origin in object space
    // gl_ObjectRayDirectionEXT - ray direction in object space
    // gl_RayTminEXT - minimum t value
    // gl_RayTmaxEXT - maximum t value (current closest hit)
    // gl_PrimitiveID - index of the AABB being tested

    vec3 rayOrigin = gl_ObjectRayOriginEXT;
    vec3 rayDir = gl_ObjectRayDirectionEXT;
    vec3 invDir = 1.0 / rayDir;

    // Look up actual AABB bounds from buffer using primitive ID
    AABB aabb = aabbBuffer.aabbs[gl_PrimitiveID];
    vec3 aabbMin = vec3(aabb.minX, aabb.minY, aabb.minZ);
    vec3 aabbMax = vec3(aabb.maxX, aabb.maxY, aabb.maxZ);

    // Ray-AABB intersection (slab method)
    vec3 t0 = (aabbMin - rayOrigin) * invDir;
    vec3 t1 = (aabbMax - rayOrigin) * invDir;

    vec3 tMin = min(t0, t1);
    vec3 tMax = max(t0, t1);

    float tEnter = max(max(tMin.x, tMin.y), tMin.z);
    float tExit = min(min(tMax.x, tMax.y), tMax.z);

    // Check for valid intersection
    if (tEnter <= tExit && tExit >= gl_RayTminEXT && tEnter <= gl_RayTmaxEXT) {
        // Use entry point if ray starts outside, otherwise use tMin
        float hitT = tEnter;
        if (hitT < gl_RayTminEXT) {
            hitT = tExit;
        }

        // Compute hit normal based on which face was hit
        vec3 hitPoint = rayOrigin + rayDir * hitT;

        // Determine which face was hit by finding which component is closest to boundary
        vec3 d0 = abs(hitPoint - aabbMin);
        vec3 d1 = abs(hitPoint - aabbMax);

        hitNormal = vec3(0.0);
        float minDist = 1e10;

        if (d0.x < minDist) { minDist = d0.x; hitNormal = vec3(-1.0, 0.0, 0.0); }
        if (d1.x < minDist) { minDist = d1.x; hitNormal = vec3(1.0, 0.0, 0.0); }
        if (d0.y < minDist) { minDist = d0.y; hitNormal = vec3(0.0, -1.0, 0.0); }
        if (d1.y < minDist) { minDist = d1.y; hitNormal = vec3(0.0, 1.0, 0.0); }
        if (d0.z < minDist) { minDist = d0.z; hitNormal = vec3(0.0, 0.0, -1.0); }
        if (d1.z < minDist) { hitNormal = vec3(0.0, 0.0, 1.0); }

        // Report intersection
        // hitKind: 0 for front face, 1 for back face
        uint hitKind = (tEnter < gl_RayTminEXT) ? 1u : 0u;
        reportIntersectionEXT(hitT, hitKind);
    }
}
