#pragma once

#include "ResourceConfig.h"
#include <concepts>
#include <type_traits>
#include <iterator>  // For std::input_or_output_iterator, std::sentinel_for

namespace Vixen::RenderGraph {

// Forward declare VkDescriptorType if not already included
// (Vulkan headers may not be included in all translation units)

// ============================================================================
// SPRINT 6.0.1: C++20 CONCEPTS FOR UNIFIED CONNECTION SYSTEM
// ============================================================================
//
// These concepts enable compile-time type resolution for the unified Connect()
// API. The compiler uses concept constraints to select the appropriate overload
// based on source/target types, providing clear error messages when constraints
// are not satisfied.
//
// Benefits over SFINAE/type traits:
// - Clear error messages: "T does not satisfy SlotReference" vs "no matching function"
// - Self-documenting constraints
// - Composable: AccumulationSlot = SlotReference && has Accumulation flag
// - Cleaner syntax: `SlotReference auto slot` vs `enable_if_t<is_slot_ref_v<T>>`
//
// ============================================================================

// ============================================================================
// CORE CONCEPTS
// ============================================================================

/**
 * @brief Concept for static slot references from node configs
 *
 * Satisfied by types generated by INPUT_SLOT/OUTPUT_SLOT macros.
 * These have compile-time metadata: index, role, nullability, etc.
 *
 * Example of satisfying type (from ResourceSlot template):
 * ```cpp
 * struct MyConfig {
 *     INPUT_SLOT(DATA, VkBuffer, 0, SlotNullability::Required,
 *                SlotRole::Dependency, SlotMutability::ReadOnly, SlotScope::NodeLevel);
 *     // DATA_Slot satisfies SlotReference
 * };
 * ```
 */
template<typename T>
concept SlotReference = requires {
    // Must have a nested Type alias for the resource type
    typename T::Type;

    // Must have compile-time index
    { T::index } -> std::convertible_to<uint32_t>;

    // Must have role metadata
    { T::role } -> std::convertible_to<SlotRole>;

    // Must have nullability metadata
    { T::nullability } -> std::convertible_to<SlotNullability>;

    // Must have mutability metadata
    { T::mutability } -> std::convertible_to<SlotMutability>;

    // Must have scope metadata
    { T::scope } -> std::convertible_to<SlotScope>;

    // Sprint 6.0.1: Must have flags (defaults to None for backward compat)
    { T::flags } -> std::convertible_to<SlotFlags>;
};

/**
 * @brief Concept for binding references from shader metadata
 *
 * Satisfied by types that reference shader descriptor bindings.
 * Used for variadic connections where the target is a shader binding
 * rather than a static slot.
 *
 * Expected properties:
 * - binding: uint32_t shader binding index (layout(binding=N))
 * - descriptorType: VkDescriptorType (or compatible integral)
 *
 * Example of satisfying type:
 * ```cpp
 * struct MyBindingRef {
 *     uint32_t binding;
 *     VkDescriptorType descriptorType;
 *     const char* name;  // Optional, for debugging
 * };
 * ```
 */
template<typename T>
concept BindingReference = requires(T t) {
    // Must have binding index
    { t.binding } -> std::convertible_to<uint32_t>;

    // Must have descriptor type (VkDescriptorType is uint32_t enum)
    { t.descriptorType } -> std::convertible_to<uint32_t>;
};

/**
 * @brief Concept for accumulation-enabled slots
 *
 * Extends SlotReference with requirement for Accumulation flag.
 * Used for slots that accept multiple connections merged into a collection.
 *
 * Example:
 * ```cpp
 * ACCUMULATION_INPUT_SLOT(PASSES, std::vector<DispatchPass>, 0,
 *                         SlotNullability::Required, SlotRole::Dependency);
 * // PASSES satisfies AccumulationSlot
 * ```
 */
template<typename T>
concept AccumulationSlot = SlotReference<T> && requires {
    // Must have isAccumulation helper (set by ResourceSlot when flags include Accumulation)
    requires T::isAccumulation == true;
};

/**
 * @brief Concept for multi-connect slots (may or may not accumulate)
 *
 * Slots that allow multiple source connections.
 * Accumulation slots flatten inputs into a vector.
 * Non-accumulating multi-connect allows multiple connections but uses last value.
 */
template<typename T>
concept MultiConnectSlot = SlotReference<T> && requires {
    requires T::isMultiConnect == true;
};

/**
 * @brief Concept for connection metadata
 *
 * Optional metadata passed to Connect() for ordering and role hints.
 * Used primarily with accumulation slots to control ordering.
 *
 * Example:
 * ```cpp
 * struct ConnectionMeta {
 *     int32_t sortKey;
 *     std::string_view role;  // Optional hint
 * };
 * ```
 */
template<typename T>
concept ConnectionMetadata = requires(T t) {
    // Must have a sortKey for ordering
    { t.sortKey } -> std::convertible_to<int32_t>;
};

/**
 * @brief Concept for types that can be used as SlotRole hints
 *
 * Allows passing SlotRole directly as metadata for simple cases.
 */
template<typename T>
concept SlotRoleHint = std::is_same_v<std::remove_cvref_t<T>, SlotRole>;

/**
 * @brief Combined concept for any valid connection metadata
 *
 * Accepts either structured ConnectionMetadata or simple SlotRole.
 */
template<typename T>
concept AnyConnectionMetadata = ConnectionMetadata<T> || SlotRoleHint<T>;

// ============================================================================
// INPUT SLOT CONCEPTS (for type-safe input handling)
// ============================================================================

/**
 * @brief Concept for input slots specifically
 *
 * Input slots should not have Output role.
 */
template<typename T>
concept InputSlotReference = SlotReference<T> && requires {
    requires (T::role != SlotRole::Output);
};

/**
 * @brief Concept for output slots specifically
 */
template<typename T>
concept OutputSlotReference = SlotReference<T> && requires {
    requires (T::role == SlotRole::Output);
};

// ============================================================================
// ITERABLE/RANGE CONCEPTS (for accumulation flattening)
// ============================================================================
//
// These concepts enable accumulation slots to accept any iterable container,
// similar to C#'s IEnumerable<T>. When connecting to an accumulation slot:
// - Single values are added directly
// - Containers (vector, array, span, etc.) are flattened into the accumulation
//

/**
 * @brief Concept for iterable ranges (C++ ranges/containers)
 *
 * Satisfied by any type that has begin()/end() returning iterators.
 * This is the C++ equivalent of C#'s IEnumerable<T>.
 *
 * Examples of satisfying types:
 * - std::vector<T>
 * - std::array<T, N>
 * - std::span<T>
 * - std::list<T>
 * - Raw arrays (via std::begin/std::end)
 * - Custom containers with begin()/end()
 */
template<typename T>
concept Iterable = requires(T t) {
    { std::begin(t) } -> std::input_or_output_iterator;
    { std::end(t) } -> std::sentinel_for<decltype(std::begin(t))>;
};

/**
 * @brief Get the element type of an iterable
 *
 * Extracts the value_type from iterables for compile-time type checking.
 */
template<Iterable T>
using iterable_value_t = std::remove_cvref_t<decltype(*std::begin(std::declval<T&>()))>;

/**
 * @brief Concept for containers of a specific element type
 *
 * Used to validate that a container holds the correct element type
 * when connecting to an accumulation slot.
 */
template<typename Container, typename ElementType>
concept IterableOf = Iterable<Container> &&
    std::same_as<iterable_value_t<Container>, ElementType>;

/**
 * @brief Type trait to check if a type is iterable
 */
template<typename T>
struct is_iterable : std::bool_constant<Iterable<T>> {};

template<typename T>
inline constexpr bool is_iterable_v = Iterable<T>;

/**
 * @brief Type trait to check if a type is iterable of specific element
 */
template<typename Container, typename ElementType>
struct is_iterable_of : std::bool_constant<IterableOf<Container, ElementType>> {};

template<typename Container, typename ElementType>
inline constexpr bool is_iterable_of_v = IterableOf<Container, ElementType>;

/**
 * @brief Concept for accumulation-compatible source types
 *
 * A source can connect to an accumulation slot of element type T if:
 * - It IS type T (single value added directly)
 * - It IS an iterable of T (flattened into accumulation)
 *
 * Example:
 * ```cpp
 * // Accumulation slot expects vector<DispatchPass>
 * // These all work:
 * Connect(nodeA, ConfigA::SINGLE_PASS_OUT, accumNode, AccumConfig::PASSES);  // T
 * Connect(nodeB, ConfigB::PASS_VECTOR_OUT, accumNode, AccumConfig::PASSES);  // vector<T>
 * Connect(nodeC, ConfigC::PASS_ARRAY_OUT, accumNode, AccumConfig::PASSES);   // array<T,N>
 * ```
 */
template<typename Source, typename TargetElement>
concept AccumulationCompatible =
    std::same_as<std::remove_cvref_t<Source>, TargetElement> ||
    IterableOf<Source, TargetElement>;

// ============================================================================
// LEGACY TYPE TRAITS (for backward compatibility)
// ============================================================================
//
// These type traits wrap the concepts for code that uses the older
// enable_if/SFINAE patterns. New code should use concepts directly.
//

/**
 * @brief Type trait wrapper for SlotReference concept
 */
template<typename T>
struct is_slot_ref : std::bool_constant<SlotReference<T>> {};

template<typename T>
inline constexpr bool is_slot_ref_v = SlotReference<T>;

/**
 * @brief Type trait wrapper for BindingReference concept
 */
template<typename T>
struct is_binding_ref : std::bool_constant<BindingReference<T>> {};

template<typename T>
inline constexpr bool is_binding_ref_v = BindingReference<T>;

/**
 * @brief Type trait wrapper for AccumulationSlot concept
 */
template<typename T>
struct is_accumulation_slot : std::bool_constant<AccumulationSlot<T>> {};

template<typename T>
inline constexpr bool is_accumulation_slot_v = AccumulationSlot<T>;

/**
 * @brief Type trait wrapper for MultiConnectSlot concept
 */
template<typename T>
struct is_multi_connect_slot : std::bool_constant<MultiConnectSlot<T>> {};

template<typename T>
inline constexpr bool is_multi_connect_slot_v = MultiConnectSlot<T>;

/**
 * @brief Type trait wrapper for ConnectionMetadata concept
 */
template<typename T>
struct is_connection_metadata : std::bool_constant<ConnectionMetadata<T>> {};

template<typename T>
inline constexpr bool is_connection_metadata_v = ConnectionMetadata<T>;

// ============================================================================
// HELPER STRUCTURES
// ============================================================================

/**
 * @brief Simple connection metadata with sortKey
 *
 * Use when connecting to accumulation slots that require ordering.
 *
 * Example:
 * ```cpp
 * batch.Connect(nodeA, ConfigA::OUTPUT,
 *               nodeB, ConfigB::ACCUMULATING_INPUT,
 *               ConnectionOrder{.sortKey = 0});
 * ```
 */
struct ConnectionOrder {
    int32_t sortKey = 0;

    constexpr ConnectionOrder() = default;
    constexpr explicit ConnectionOrder(int32_t key) : sortKey(key) {}
};

// Verify ConnectionOrder satisfies ConnectionMetadata
static_assert(ConnectionMetadata<ConnectionOrder>,
    "ConnectionOrder must satisfy ConnectionMetadata concept");

/**
 * @brief Extended connection metadata with role hint
 *
 * For connections that need both ordering and role override.
 */
struct ConnectionInfo {
    int32_t sortKey = 0;
    SlotRole roleOverride = SlotRole::None;  // None = use slot's default role

    constexpr ConnectionInfo() = default;
    constexpr ConnectionInfo(int32_t key, SlotRole role = SlotRole::None)
        : sortKey(key), roleOverride(role) {}
};

static_assert(ConnectionMetadata<ConnectionInfo>,
    "ConnectionInfo must satisfy ConnectionMetadata concept");

// ============================================================================
// COMPILE-TIME VALIDATION HELPERS
// ============================================================================

/**
 * @brief Check if a slot type is compatible with accumulation
 *
 * Accumulation slots should have a container type (vector, array).
 * This is a soft check - the actual accumulation logic handles type flattening.
 */
template<typename SlotType>
struct is_container_type : std::false_type {};

template<typename T, typename Alloc>
struct is_container_type<std::vector<T, Alloc>> : std::true_type {};

template<typename T, size_t N>
struct is_container_type<std::array<T, N>> : std::true_type {};

template<typename T>
inline constexpr bool is_container_type_v = is_container_type<T>::value;

/**
 * @brief Validate that accumulation slot has appropriate container type
 *
 * Used in static_assert to catch configuration errors early.
 */
template<typename SlotType>
constexpr bool ValidateAccumulationSlotType() {
    if constexpr (AccumulationSlot<SlotType>) {
        // Accumulation slots should have container types
        return is_container_type_v<typename SlotType::Type>;
    }
    return true;  // Non-accumulation slots pass validation
}

} // namespace Vixen::RenderGraph
