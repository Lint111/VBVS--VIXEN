[main] Starting VulkanGraphApplication...

Instanced Layers
================

AMD switchable graphics layer
	|
	\ --- [Layer Name] --> VK_LAYER_AMD_switchable_graphics

NVIDIA Optimus layer
	|
	\ --- [Layer Name] --> VK_LAYER_NV_optimus

NVIDIA GR2608 layer
	|
	\ --- [Layer Name] --> VK_LAYER_NV_present

Steam Overlay Layer
	|
	\ --- [Layer Name] --> VK_LAYER_VALVE_steam_overlay

Steam Pipeline Caching Layer
	|
	\ --- [Layer Name] --> VK_LAYER_VALVE_steam_fossilize

Open Broadcaster Software hook
	|
	\ --- [Layer Name] --> VK_LAYER_OBS_HOOK

Open Broadcaster Software hook
	|
	\ --- [Layer Name] --> VK_LAYER_OBS_HOOK

LunarG API dump layer
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_api_dump
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

GFXReconstruct Capture Layer Version 1.0.5
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_gfxreconstruct

Khronos Synchronization2 layer
	|
	\ --- [Layer Name] --> VK_LAYER_KHRONOS_synchronization2
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

Khronos Validation Layer
	|
	\ --- [Layer Name] --> VK_LAYER_KHRONOS_validation
		|
		|--- [LayerExtension] --> VK_EXT_debug_report
		|
		|--- [LayerExtension] --> VK_EXT_debug_utils
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings
		|
		|--- [LayerExtension] --> VK_EXT_validation_features

Execution Monitoring Layer
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_monitor
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

LunarG image capture layer
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_screenshot
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

Khronos Profiles layer
	|
	\ --- [Layer Name] --> VK_LAYER_KHRONOS_profiles
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

Khronos Shader object layer
	|
	\ --- [Layer Name] --> VK_LAYER_KHRONOS_shader_object
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

Crash Diagnostic Layer is a crash/hang debugging tool that helps determines GPU progress in a Vulkan application.
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_crash_diagnostic
		|
		|--- [LayerExtension] --> VK_EXT_debug_report
		|
		|--- [LayerExtension] --> VK_EXT_debug_utils
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings
[main] Calling Initialize...
Layer support found, keep the layer: VK_LAYER_KHRONOS_validation
GetProcAddr: Found vkCreateDebugReportCallbackEXT function.
GetProcAddr: Found vkDestroyDebugReportCallbackEXT function.
Debug Callback: Successfully created.
[main] Calling Prepare...
[VulkanGraphApplication::Prepare] START
[VulkanGraphApplication::Prepare] Calling BuildRenderGraph...
[ConstantNode::SetValue] Setting value for node: physics_loop_id
[ConstantNode::SetValue] Value set successfully
[VulkanGraphApplication::Prepare] BuildRenderGraph complete
[VulkanGraphApplication::Prepare] Calling CompileRenderGraph...
[CompileRenderGraph] START
[CompileRenderGraph] Pre-compiling device node...
[VulkanDevice::CreateDevice] Enabling 3 extensions:
[VulkanDevice::CreateDevice]   0: VK_KHR_swapchain
[VulkanDevice::CreateDevice]   1: VK_EXT_swapchain_maintenance1
[VulkanDevice::CreateDevice]   2: VK_KHR_maintenance6
[CompileRenderGraph] Device node compiled and marked as Compiled
[CompileRenderGraph] Calling graph.Compile()...
[RenderGraph::Compile] Starting compilation...
[RenderGraph::Compile] Phase: Validation...
[RenderGraph::Compile] Phase: AnalyzeDependencies...
[RenderGraph::Compile] Phase: AllocateResources...
[RenderGraph::Compile] Phase: GeneratePipelines...
[GeneratePipelines] Total instances to compile: 17
[GeneratePipelines]   0: main_device
[GeneratePipelines]   1: triangle_vb
[GeneratePipelines]   2: main_texture
[GeneratePipelines]   3: shader_lib
[GeneratePipelines]   4: frame_sync
[GeneratePipelines]   5: main_window
[GeneratePipelines]   6: main_swapchain
[GeneratePipelines]   7: main_cmd_pool
[GeneratePipelines]   8: depth_buffer
[GeneratePipelines]   9: main_pass
[GeneratePipelines]   10: main_fb
[GeneratePipelines]   11: physics_loop_id
[GeneratePipelines]   12: physics_loop
[GeneratePipelines]   13: main_descriptors
[GeneratePipelines]   14: triangle_pipeline
[GeneratePipelines]   15: triangle_render
[GeneratePipelines]   16: present
[GeneratePipelines] Skipping already-compiled node: main_device
[GeneratePipelines] Calling Setup() on node: triangle_vb
[GeneratePipelines] Loading persistent caches...
[RenderGraph] Loading persistent caches from: cache
[DeviceRegistry] Pre-registering cachers from manifest...
[DeviceRegistry] Found cacher in manifest: TextureCacher
[DeviceRegistry] Found cacher in manifest: ShaderModuleCacher
[DeviceRegistry] Found cacher in manifest: DescriptorCacher
[DeviceRegistry] Found cacher in manifest: PipelineCacher
[DeviceRegistry] Found cacher in manifest: PipelineLayoutCacher
[RenderGraph] Persistent caches loaded successfully
[GeneratePipelines] Calling Compile() on node: triangle_vb
[VertexBufferNode::Compile] vertexBuffer BEFORE Out(): 2199023255554
[VertexBufferNode::Compile] vertexBuffer AFTER Out(): 2199023255554
[GeneratePipelines] Node compiled successfully: triangle_vb
[GeneratePipelines] Calling Setup() on node: main_texture
[TextureLoader] Base constructor - device=0000022E587B26D0, cmdPool=0000040000000004
[STBTextureLoader] Constructor called
[GeneratePipelines] Calling Compile() on node: main_texture
[TextureLoader::Load] START
[TextureLoader::Load] Calling LoadPixelData...
[STB] LoadPixelData ENTRY
[STB] Loading: C:\Users\liory\Downloads\earthmap.jpg
[STB] Loaded 1024x512, 3 channels
[GeneratePipelines] Node compiled successfully: main_texture
[GeneratePipelines] Calling Setup() on node: shader_lib
[ShaderLibraryNode::Setup] Called
[ShaderLibraryNode::Setup] Complete
[GeneratePipelines] Calling Compile() on node: shader_lib
[ShaderLibraryNode::Compile] START - Phase 1 integration
[ShaderLibraryNode] Current working directory: "C:\\cpp\\VBVS--VIXEN\\VIXEN"
[ShaderLibraryNode] Found shaders at: "Shaders"
[ShaderLibraryNode] Checking for shader files...
[ShaderLibraryNode] Vertex path: "Shaders/Draw.vert" exists=1
[ShaderLibraryNode] Fragment path: "Shaders\\Draw.frag" exists=1
[ShaderLibraryNode] Creating ShaderBundleBuilder...
[ShaderLibraryNode] Stages added (SDI enabled), calling Build()...
[SpirvReflector::ReflectVertexInputs] location=1 name=inUV format=103 (from SPIRV-Reflect)
[SpirvReflector::ReflectVertexInputs] location=0 name=pos format=109 (from SPIRV-Reflect)
[ShaderLibraryNode] Shader bundle built successfully
[ShaderLibraryNode] Using device: 0000022E587B26D0
[ShaderLibraryNode] Creating VkShaderModules via CashSystem...
[ShaderLibraryNode] Checking if ShaderModuleCacher is registered...
[ShaderLibraryNode] Is registered: 0
[ShaderLibraryNode] Registering ShaderModuleCacher...
[ShaderLibraryNode] ShaderModuleCacher registered
[ShaderLibraryNode] Getting ShaderModuleCacher from MainCacher...
[ShaderLibraryNode] Device pointer value: 0000022E587B26D0
[ShaderLibraryNode] IsDeviceDependent: 1
[ShaderLibraryNode] Got ShaderModuleCacher successfully
[ShaderLibraryNode] ShaderModuleCacher->IsInitialized()=1
[ShaderLibraryNode] ShaderModuleCacher->GetDevice()=0000022E587B26D0
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=5635850799421726357
[ShaderModuleCacher] CACHE MISS for SPIR-V Draw_Vertex (key=5635850799421726357), creating new VkShaderModule...
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkCreateShaderModule(): pCreateInfo->pCode (spirv-val produced an error):
Invalid SPIR-V header.
The Vulkan spec states: If pCode is a pointer to SPIR-V code, pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/shaders.html#VUID-VkShaderModuleCreateInfo-pCode-08737)
[ShaderModuleCacher] VkShaderModule created from SPIR-V: 13194139533324
[ShaderModuleCacher] GetOrCreateFromSpirv EXIT: VkShaderModule=13194139533324
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=1416478403420909105
[ShaderModuleCacher] CACHE MISS for SPIR-V Draw_Fragment (key=1416478403420909105), creating new VkShaderModule...
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkCreateShaderModule(): pCreateInfo->pCode (spirv-val produced an error):
Invalid SPIR-V header.
The Vulkan spec states: If pCode is a pointer to SPIR-V code, pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/shaders.html#VUID-VkShaderModuleCreateInfo-pCode-08737)
[ShaderModuleCacher] VkShaderModule created from SPIR-V: 14293651161101
[ShaderModuleCacher] GetOrCreateFromSpirv EXIT: VkShaderModule=14293651161101
[GeneratePipelines] Node compiled successfully: shader_lib
[GeneratePipelines] Calling Setup() on node: frame_sync
[GeneratePipelines] Calling Compile() on node: frame_sync
[GeneratePipelines] Node compiled successfully: frame_sync
[GeneratePipelines] Calling Setup() on node: main_window
[GeneratePipelines] Calling Compile() on node: main_window
[WindowNode::Compile] START
[WindowNode::Compile] Creating window 800x600
[GeneratePipelines] Node compiled successfully: main_window
[GeneratePipelines] Calling Setup() on node: main_swapchain
[GeneratePipelines] Calling Compile() on node: main_swapchain
[SwapChainNode::Compile] START
[SwapChainNode::Compile] Reading HWND...
[SwapChainNode::Compile] Reading HINSTANCE...
[SwapChainNode::Compile] Reading WIDTH...
[SwapChainNode::Compile] WIDTH = 800
[SwapChainNode::Compile] Reading HEIGHT...
[SwapChainNode::Compile] HEIGHT = 600
[SwapChainNode::Compile] Reading INSTANCE...
[SwapChainNode::Compile] Validating dimensions...
[SwapChainNode::Compile] Validating HWND...
[SwapChainNode::Compile] Validating HINSTANCE...
[SwapChainNode::Compile] Validating VkInstance...
[SwapChainNode::Compile] Checking swapchain wrapper...
[SwapChainNode::Compile] Swapchain wrapper OK
[SwapChainNode::Compile] Loading swapchain extensions...
[SwapChainNode::Compile] Instance handle: 0000022E01B1C680
[SwapChainNode::Compile] Extension function pointers loaded successfully
[ManagePresentMode] Available present modes: 2 3 1 0 1000361000 
[ManagePresentMode] Selected MAILBOX mode
[ManagePresentMode] Selected IMMEDIATE mode (uncapped FPS)
[SwapChainNode::Compile] ColorBuffers populated: 3 buffers
[GeneratePipelines] Node compiled successfully: main_swapchain
[GeneratePipelines] Calling Setup() on node: main_cmd_pool
[GeneratePipelines] Calling Compile() on node: main_cmd_pool
[GeneratePipelines] Node compiled successfully: main_cmd_pool
[GeneratePipelines] Calling Setup() on node: depth_buffer
[GeneratePipelines] Calling Compile() on node: depth_buffer
[GeneratePipelines] Node compiled successfully: depth_buffer
[GeneratePipelines] Calling Setup() on node: main_pass
[GeneratePipelines] Calling Compile() on node: main_pass
[GeneratePipelines] Node compiled successfully: main_pass
[GeneratePipelines] Calling Setup() on node: main_fb
[GeneratePipelines] Calling Compile() on node: main_fb
[FramebufferNode::Compile] Creating 3 framebuffers from swapchain
[FramebufferNode::Compile] Processing attachment 0, view=00001A000000001A
[FramebufferNode::Compile] Created framebuffer[0]=0000220000000022
[FramebufferNode::Compile] Processing attachment 1, view=00001B000000001B
[FramebufferNode::Compile] Created framebuffer[1]=0000230000000023
[FramebufferNode::Compile] Processing attachment 2, view=00001C000000001C
[FramebufferNode::Compile] Created framebuffer[2]=0000240000000024
[FramebufferNode::Compile] Output 3 framebuffers as vector
[GeneratePipelines] Node compiled successfully: main_fb
[GeneratePipelines] Calling Setup() on node: physics_loop_id
[GeneratePipelines] Calling Compile() on node: physics_loop_id
[ConstantNode::Compile] START for node: physics_loop_id
[ConstantNode::Compile] Value is set, retrieving output resource...
[ConstantNode::Compile] Moving resource to output...
[ConstantNode::Compile] Output resource address: 0000022E587A6EA0
[ConstantNode::Compile] Source resource is valid: 1
[ConstantNode::Compile] Transferred resource is valid: 1
[ConstantNode::Compile] SUCCESS - Resource transferred
[ConstantNode::Compile] Checking cleanup callback: NULL
[ConstantNode::Compile] NOT registering cleanup (callback=NULL, graph=EXISTS)
[GeneratePipelines] Node compiled successfully: physics_loop_id
[GeneratePipelines] Calling Setup() on node: physics_loop
[GeneratePipelines] Calling Compile() on node: physics_loop
[GeneratePipelines] Node compiled successfully: physics_loop
[GeneratePipelines] Calling Setup() on node: main_descriptors
[GeneratePipelines] Calling Compile() on node: main_descriptors
[DescriptorSetNode::Compile] Received ShaderDataBundle: Draw_Shader
[DescriptorSetNode::Compile] Found 2 descriptor bindings in set 0
[DescriptorSetNode::Compile] Binding 0: type=6, count=1, stages=1, name=myBufferVals
[DescriptorSetNode::Compile] Binding 1: type=1, count=1, stages=10, name=tex
[DescriptorSetNode::Compile] Successfully created descriptor set layout from reflection
[DescriptorSetNode::Compile] Created layout: 0000250000000025
[CalculateDescriptorPoolSizes] Pool size: type=6, count=1 (per-set=1, maxSets=1)
[CalculateDescriptorPoolSizes] Pool size: type=1, count=1 (per-set=1, maxSets=1)
[DescriptorSetNode::Compile] Created descriptor pool: 0000260000000026
[DescriptorSetNode::Compile] Allocated descriptor set: 0000270000000027
[DescriptorSetNode::Compile] Creating per-frame resources for 3 swapchain images
[PerFrameResources] Initialized for 3 frames
[PerFrameResources] Created UBO for frame 0 (buffer=0000280000000028, size=64)
[PerFrameResources] Created UBO for frame 1 (buffer=00002A000000002A, size=64)
[PerFrameResources] Created UBO for frame 2 (buffer=00002C000000002C, size=64)
[DescriptorSetNode::Compile] Created 3 per-frame UBOs
[DescriptorSetNode::Compile] Updated descriptor set with UBO (binding 0)
[DescriptorSetNode::Compile] Updated descriptor set with texture (view=00000A000000000A, sampler=00000B000000000B)
[DescriptorSetNode::Compile] Outputs set successfully
[GeneratePipelines] Node compiled successfully: main_descriptors
[GeneratePipelines] Calling Setup() on node: triangle_pipeline
[GeneratePipelines] Calling Compile() on node: triangle_pipeline
[ExtractPushConstantsFromReflection] Push constant: pushConstantsColorBlock (offset=0, size=16, stages=0x10)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=12519004405771622927
[ShaderModuleCacher] CACHE MISS for SPIR-V Draw_Shader_Vertex (key=12519004405771622927), creating new VkShaderModule...
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkCreateShaderModule(): pCreateInfo->pCode (spirv-val produced an error):
Invalid SPIR-V header.
The Vulkan spec states: If pCode is a pointer to SPIR-V code, pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/shaders.html#VUID-VkShaderModuleCreateInfo-pCode-08737)
[ShaderModuleCacher] VkShaderModule created from SPIR-V: 50577534877742
[ShaderModuleCacher] GetOrCreateFromSpirv EXIT: VkShaderModule=50577534877742
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=11960572834381217403
[ShaderModuleCacher] CACHE MISS for SPIR-V Draw_Shader_Fragment (key=11960572834381217403), creating new VkShaderModule...
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkCreateShaderModule(): pCreateInfo->pCode (spirv-val produced an error):
Invalid SPIR-V header.
The Vulkan spec states: If pCode is a pointer to SPIR-V code, pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/shaders.html#VUID-VkShaderModuleCreateInfo-pCode-08737)
[ShaderModuleCacher] VkShaderModule created from SPIR-V: 51677046505519
[ShaderModuleCacher] GetOrCreateFromSpirv EXIT: VkShaderModule=51677046505519
[GraphicsPipelineNode] enableVertexInput=1
[GraphicsPipelineNode] Calling BuildVertexInputsFromReflection...
[BuildVertexInputsFromReflection] bundle=valid reflectionData=valid vertexInputCount=2 hasReflection=1
[GraphicsPipelineNode] BuildVertexInputsFromReflection complete: 1 bindings, 2 attributes
  Binding 0: stride=24 inputRate=0
  Attribute location=0 binding=0 format=109 offset=0
  Attribute location=1 binding=0 format=103 offset=16
[GraphicsPipelineNode] Pipeline params: depth=1 depthWrite=1 cull=2 polyMode=0 topo=3
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::GetOrCreate] CACHE MISS for pipeline Draw_Shader+Draw_Shader (key=13576878286581977099), creating new resource...
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::Create] CACHE MISS - Creating new pipeline: Draw_Shader + Draw_Shader
[PipelineCacher::Create] Creating pipeline cache...
[PipelineCacher::Create] Creating pipeline layout...
[PipelineCacher] No layout wrapper provided, using convenience path (PipelineLayoutCacher)
[PipelineCacher] Registering PipelineLayoutCacher
[PipelineLayoutCacher::ComputeKey] keyString="40681930227749|1|16:0:16" hash=1193753291618295134
[PipelineLayoutCacher::GetOrCreate] CACHE MISS for layout main_pipeline_layout (key=1193753291618295134), creating new resource...
[PipelineLayoutCacher::ComputeKey] keyString="40681930227749|1|16:0:16" hash=1193753291618295134
[PipelineLayoutCacher::Create] Creating pipeline layout: main_pipeline_layout
[PipelineLayoutCacher::Create] Created VkPipelineLayout: 53876069761073
[PipelineCacher] Using shared VkPipelineLayout: 53876069761073
[PipelineCacher::Create] Creating VkPipeline...
[PipelineCacher::CreatePipeline] Using 2 shader stages
[PipelineCacher::Create] VkPipeline created: 54975581388850
[GeneratePipelines] Node compiled successfully: triangle_pipeline
[GeneratePipelines] Calling Setup() on node: triangle_render
[GeneratePipelines] Calling Compile() on node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[GeneratePipelines] Node compiled successfully: triangle_render
[GeneratePipelines] Calling Setup() on node: present
[GeneratePipelines] Calling Compile() on node: present
[GeneratePipelines] Node compiled successfully: present
[RenderGraph::Compile] Phase: BuildExecutionOrder...
[RenderGraph::Compile] Compilation complete!
[CompileRenderGraph] Graph compilation complete
[CompileRenderGraph] Validating graph...
[CompileRenderGraph] Validation passed
[CompileRenderGraph] SUCCESS
[VulkanGraphApplication::Prepare] CompileRenderGraph complete
[VulkanGraphApplication::Prepare] SUCCESS - isPrepared = true
[main] Entering render loop...
[RenderGraph] Window state changed: FOCUSED
[RenderGraph] Render pause event: START (reason: 0)
[RenderGraph] Rendering paused - continuing with event processing only
[RenderGraph] Render pause event: END (reason: 0)
[RenderGraph] Rendering resumed
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e58f7de30 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x100000000010) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 0, [1], 0, 2.
(brackets mark the last use of VkSemaphore 0x100000000010 in a presentation operation)
Swapchain image 1 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x100000000010 may still be in use and cannot be safely reused with image index 2.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e58fe99d0 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x130000000013) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 0, 1, [0], 2, 1.
(brackets mark the last use of VkSemaphore 0x130000000013 in a presentation operation)
Swapchain image 0 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x130000000013 may still be in use and cannot be safely reused with image index 1.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e58fe99d0 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e58fe99d0 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e58fe99d0 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e58fe99d0 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e58fe99d0 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e5901ddf0 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e58f7de30 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : (Warning - This VUID has now been reported 10 times, which is the duplicated_message_limit value, this will be the last time reporting it).
vkQueueSubmit(): pSubmits[0].pCommandBuffers[0] was called in VkCommandBuffer 0x22e58fe99d0 which is invalid because the bound VkDescriptorSet 0x270000000027 was destroyed or updated.
The Vulkan spec states: Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pCommandBuffers-00070)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x130000000013) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 0, 2, 1, 0, 0, [0], 1, 1.
(brackets mark the last use of VkSemaphore 0x130000000013 in a presentation operation)
Swapchain image 0 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x130000000013 may still be in use and cannot be safely reused with image index 1.
Vulkan insight: One solution is to assign each image its own semaphore. This also handles the case where vkAcquireNextImageKHR returns the same index twice in a row. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x100000000010) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 1, 0, 1, 0, 1, [0], 2, 1.
(brackets mark the last use of VkSemaphore 0x100000000010 in a presentation operation)
Swapchain image 0 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x100000000010 may still be in use and cannot be safely reused with image index 1.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x100000000010) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 0, 2, 1, 1, 1, [2], 0, 1.
(brackets mark the last use of VkSemaphore 0x100000000010 in a presentation operation)
Swapchain image 2 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x100000000010 may still be in use and cannot be safely reused with image index 1.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x130000000013) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 0, 0, 1, 0, 1, [0], 1, 2.
(brackets mark the last use of VkSemaphore 0x130000000013 in a presentation operation)
Swapchain image 0 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x130000000013 may still be in use and cannot be safely reused with image index 2.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x100000000010) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 2, 1, 2, 1, 2, [1], 2, 2.
(brackets mark the last use of VkSemaphore 0x100000000010 in a presentation operation)
Swapchain image 1 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x100000000010 may still be in use and cannot be safely reused with image index 2.
Vulkan insight: One solution is to assign each image its own semaphore. This also handles the case where vkAcquireNextImageKHR returns the same index twice in a row. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x130000000013) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 2, 1, 2, 0, 2, [1], 2, 2.
(brackets mark the last use of VkSemaphore 0x130000000013 in a presentation operation)
Swapchain image 1 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x130000000013 may still be in use and cannot be safely reused with image index 2.
Vulkan insight: One solution is to assign each image its own semaphore. This also handles the case where vkAcquireNextImageKHR returns the same index twice in a row. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x100000000010) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 2, 1, 2, 1, 2, [1], 0, 2.
(brackets mark the last use of VkSemaphore 0x100000000010 in a presentation operation)
Swapchain image 1 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x100000000010 may still be in use and cannot be safely reused with image index 2.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : (Warning - This VUID has now been reported 10 times, which is the duplicated_message_limit value, this will be the last time reporting it).
vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x130000000013) is being signaled by VkQueue 0x22e58a81240, but it may still be in use by VkSwapchainKHR 0x160000000016.
Here are the most recently acquired image indices: 1, 2, 1, 0, 2, [0], 2, 1.
(brackets mark the last use of VkSemaphore 0x130000000013 in a presentation operation)
Swapchain image 0 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x130000000013 may still be in use and cannot be safely reused with image index 1.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[WindowNode::WM_EXITSIZEMOVE] GetClientRect returned: 986x600
[WindowNode::WM_EXITSIZEMOVE] Old cached dimensions: 800x600
[WindowNode::WM_EXITSIZEMOVE] Calling Out() with: 986x600
[WindowNode::WM_EXITSIZEMOVE] Read back from outputs: width=986, height=600
[WindowNode::WM_EXITSIZEMOVE] Publishing WindowResizedMessage with 986x600
[RenderGraph] Window resized: 986x600
[SwapChainNode] Received WindowResizedMessage - marking self for recompilation
[RenderGraph] Recompiling 1 dirty nodes
[RenderGraph] Recompiling node: main_swapchain
[SwapChainNode::CleanupImpl] Called
[VulkanSwapChain::Destroy] Called with device=0000022E587D7460, instance=0000022E01B1C680
[VulkanSwapChain::Destroy] Current surface=0000150000000015, swapchain=0000160000000016
  Destroying VkSurfaceKHR
[VulkanSwapChain::Destroy] Cleanup complete
[SwapChainNode::Compile] START
[SwapChainNode::Compile] Reading HWND...
[SwapChainNode::Compile] Reading HINSTANCE...
[SwapChainNode::Compile] Reading WIDTH...
[SwapChainNode::Compile] WIDTH = 986
[SwapChainNode::Compile] Reading HEIGHT...
[SwapChainNode::Compile] HEIGHT = 600
[SwapChainNode::Compile] Reading INSTANCE...
[SwapChainNode::Compile] Validating dimensions...
[SwapChainNode::Compile] Validating HWND...
[SwapChainNode::Compile] Validating HINSTANCE...
[SwapChainNode::Compile] Validating VkInstance...
[SwapChainNode::Compile] Checking swapchain wrapper...
[SwapChainNode::Compile] Swapchain wrapper OK
[SwapChainNode::Compile] Loading swapchain extensions...
[SwapChainNode::Compile] Instance handle: 0000022E01B1C680
[SwapChainNode::Compile] Extension function pointers loaded successfully
[ManagePresentMode] Available present modes: 2 3 1 0 1000361000 
[ManagePresentMode] Selected MAILBOX mode
[ManagePresentMode] Selected IMMEDIATE mode (uncapped FPS)
[SwapChainNode::Compile] ColorBuffers populated: 3 buffers
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Marking dependent node 'depth_buffer' for recompilation
[RenderGraph] Marking dependent node 'main_pass' for recompilation
[RenderGraph] Marking dependent node 'main_fb' for recompilation
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Marking dependent node 'main_descriptors' for recompilation
[RenderGraph] Recompiling 6 dirty nodes
[RenderGraph] Recompiling node: depth_buffer
[RenderGraph] Marking dependent node 'main_pass' for recompilation
[RenderGraph] Marking dependent node 'main_fb' for recompilation
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Recompiling node: main_pass
[RenderGraph] Marking dependent node 'main_fb' for recompilation
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Recompiling node: main_fb
[FramebufferNode::Compile] Creating 3 framebuffers from swapchain
[FramebufferNode::Compile] Processing attachment 0, view=0000380000000038
[FramebufferNode::Compile] Created framebuffer[0]=00003F000000003F
[FramebufferNode::Compile] Processing attachment 1, view=0000390000000039
[FramebufferNode::Compile] Created framebuffer[1]=0000400000000040
[FramebufferNode::Compile] Processing attachment 2, view=00003A000000003A
[FramebufferNode::Compile] Created framebuffer[2]=0000410000000041
[FramebufferNode::Compile] Output 3 framebuffers as vector
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: main_descriptors
[PerFrameResources] Cleaned up all per-frame resources
[DescriptorSetNode::Compile] Received ShaderDataBundle: Draw_Shader
[DescriptorSetNode::Compile] Found 2 descriptor bindings in set 0
[DescriptorSetNode::Compile] Binding 0: type=6, count=1, stages=1, name=myBufferVals
[DescriptorSetNode::Compile] Binding 1: type=1, count=1, stages=10, name=tex
[DescriptorSetNode::Compile] Successfully created descriptor set layout from reflection
[DescriptorSetNode::Compile] Created layout: 0000420000000042
[CalculateDescriptorPoolSizes] Pool size: type=6, count=1 (per-set=1, maxSets=1)
[CalculateDescriptorPoolSizes] Pool size: type=1, count=1 (per-set=1, maxSets=1)
[DescriptorSetNode::Compile] Created descriptor pool: 0000430000000043
[DescriptorSetNode::Compile] Allocated descriptor set: 0000440000000044
[DescriptorSetNode::Compile] Creating per-frame resources for 3 swapchain images
[PerFrameResources] Initialized for 3 frames
[PerFrameResources] Created UBO for frame 0 (buffer=0000450000000045, size=64)
[PerFrameResources] Created UBO for frame 1 (buffer=0000470000000047, size=64)
[PerFrameResources] Created UBO for frame 2 (buffer=0000490000000049, size=64)
[DescriptorSetNode::Compile] Created 3 per-frame UBOs
[DescriptorSetNode::Compile] Updated descriptor set with UBO (binding 0)
[DescriptorSetNode::Compile] Updated descriptor set with texture (view=00000A000000000A, sampler=00000B000000000B)
[DescriptorSetNode::Compile] Outputs set successfully
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_pipeline
[GraphicsPipelineNode::CleanupImpl] Releasing cached pipeline wrapper (cacher owns all resources)
[ExtractPushConstantsFromReflection] Push constant: pushConstantsColorBlock (offset=0, size=16, stages=0x10)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=12519004405771622927
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Vertex (key=12519004405771622927, VkShaderModule=50577534877742)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=11960572834381217403
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Fragment (key=11960572834381217403, VkShaderModule=51677046505519)
[GraphicsPipelineNode] enableVertexInput=1
[GraphicsPipelineNode] Calling BuildVertexInputsFromReflection...
[BuildVertexInputsFromReflection] bundle=valid reflectionData=valid vertexInputCount=2 hasReflection=1
[GraphicsPipelineNode] BuildVertexInputsFromReflection complete: 1 bindings, 2 attributes
  Binding 0: stride=24 inputRate=0
  Attribute location=0 binding=0 format=109 offset=0
  Attribute location=1 binding=0 format=103 offset=16
[GraphicsPipelineNode] Pipeline params: depth=1 depthWrite=1 cull=2 polyMode=0 topo=3
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::GetOrCreate] CACHE HIT for pipeline Draw_Shader+Draw_Shader (key=13576878286581977099, VkPipeline=54975581388850)
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[RenderGraph] Recompiling 4 dirty nodes
[RenderGraph] Recompiling node: main_pass
[RenderGraph] Marking dependent node 'main_fb' for recompilation
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Recompiling node: main_fb
[FramebufferNode::Compile] Creating 3 framebuffers from swapchain
[FramebufferNode::Compile] Processing attachment 0, view=0000380000000038
[FramebufferNode::Compile] Created framebuffer[0]=00004C000000004C
[FramebufferNode::Compile] Processing attachment 1, view=0000390000000039
[FramebufferNode::Compile] Created framebuffer[1]=00004D000000004D
[FramebufferNode::Compile] Processing attachment 2, view=00003A000000003A
[FramebufferNode::Compile] Created framebuffer[2]=00004E000000004E
[FramebufferNode::Compile] Output 3 framebuffers as vector
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_pipeline
[GraphicsPipelineNode::CleanupImpl] Releasing cached pipeline wrapper (cacher owns all resources)
[ExtractPushConstantsFromReflection] Push constant: pushConstantsColorBlock (offset=0, size=16, stages=0x10)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=12519004405771622927
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Vertex (key=12519004405771622927, VkShaderModule=50577534877742)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=11960572834381217403
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Fragment (key=11960572834381217403, VkShaderModule=51677046505519)
[GraphicsPipelineNode] enableVertexInput=1
[GraphicsPipelineNode] Calling BuildVertexInputsFromReflection...
[BuildVertexInputsFromReflection] bundle=valid reflectionData=valid vertexInputCount=2 hasReflection=1
[GraphicsPipelineNode] BuildVertexInputsFromReflection complete: 1 bindings, 2 attributes
  Binding 0: stride=24 inputRate=0
  Attribute location=0 binding=0 format=109 offset=0
  Attribute location=1 binding=0 format=103 offset=16
[GraphicsPipelineNode] Pipeline params: depth=1 depthWrite=1 cull=2 polyMode=0 topo=3
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::GetOrCreate] CACHE HIT for pipeline Draw_Shader+Draw_Shader (key=13576878286581977099, VkPipeline=54975581388850)
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[RenderGraph] Recompiling 3 dirty nodes
[RenderGraph] Recompiling node: main_fb
[FramebufferNode::Compile] Creating 3 framebuffers from swapchain
[FramebufferNode::Compile] Processing attachment 0, view=0000380000000038
[FramebufferNode::Compile] Created framebuffer[0]=00004F000000004F
[FramebufferNode::Compile] Processing attachment 1, view=0000390000000039
[FramebufferNode::Compile] Created framebuffer[1]=0000500000000050
[FramebufferNode::Compile] Processing attachment 2, view=00003A000000003A
[FramebufferNode::Compile] Created framebuffer[2]=0000510000000051
[FramebufferNode::Compile] Output 3 framebuffers as vector
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_pipeline
[GraphicsPipelineNode::CleanupImpl] Releasing cached pipeline wrapper (cacher owns all resources)
[ExtractPushConstantsFromReflection] Push constant: pushConstantsColorBlock (offset=0, size=16, stages=0x10)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=12519004405771622927
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Vertex (key=12519004405771622927, VkShaderModule=50577534877742)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=11960572834381217403
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Fragment (key=11960572834381217403, VkShaderModule=51677046505519)
[GraphicsPipelineNode] enableVertexInput=1
[GraphicsPipelineNode] Calling BuildVertexInputsFromReflection...
[BuildVertexInputsFromReflection] bundle=valid reflectionData=valid vertexInputCount=2 hasReflection=1
[GraphicsPipelineNode] BuildVertexInputsFromReflection complete: 1 bindings, 2 attributes
  Binding 0: stride=24 inputRate=0
  Attribute location=0 binding=0 format=109 offset=0
  Attribute location=1 binding=0 format=103 offset=16
[GraphicsPipelineNode] Pipeline params: depth=1 depthWrite=1 cull=2 polyMode=0 topo=3
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::GetOrCreate] CACHE HIT for pipeline Draw_Shader+Draw_Shader (key=13576878286581977099, VkPipeline=54975581388850)
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[RenderGraph] Recompiling 1 dirty nodes
[RenderGraph] Recompiling node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[RenderGraph] All nodes successfully recompiled - graph is compiled
[RenderGraph] Render pause event: START (reason: 0)
[RenderGraph] Rendering paused - continuing with event processing only
[RenderGraph] Render pause event: END (reason: 0)
[RenderGraph] Rendering resumed
[WindowNode::WM_EXITSIZEMOVE] GetClientRect returned: 1118x600
[WindowNode::WM_EXITSIZEMOVE] Old cached dimensions: 986x600
[WindowNode::WM_EXITSIZEMOVE] Calling Out() with: 1118x600
[WindowNode::WM_EXITSIZEMOVE] Read back from outputs: width=1118, height=600
[WindowNode::WM_EXITSIZEMOVE] Publishing WindowResizedMessage with 1118x600
[RenderGraph] Window resized: 1118x600
[SwapChainNode] Received WindowResizedMessage - marking self for recompilation
[SwapChainNode] Received WindowResizedMessage - marking self for recompilation
[RenderGraph] Recompiling 1 dirty nodes
[RenderGraph] Recompiling node: main_swapchain
[SwapChainNode::CleanupImpl] Called
[VulkanSwapChain::Destroy] Called with device=0000022E587D7460, instance=0000022E01B1C680
[VulkanSwapChain::Destroy] Current surface=0000330000000033, swapchain=0000340000000034
  Destroying VkSurfaceKHR
[VulkanSwapChain::Destroy] Cleanup complete
[SwapChainNode::Compile] START
[SwapChainNode::Compile] Reading HWND...
[SwapChainNode::Compile] Reading HINSTANCE...
[SwapChainNode::Compile] Reading WIDTH...
[SwapChainNode::Compile] WIDTH = 1118
[SwapChainNode::Compile] Reading HEIGHT...
[SwapChainNode::Compile] HEIGHT = 600
[SwapChainNode::Compile] Reading INSTANCE...
[SwapChainNode::Compile] Validating dimensions...
[SwapChainNode::Compile] Validating HWND...
[SwapChainNode::Compile] Validating HINSTANCE...
[SwapChainNode::Compile] Validating VkInstance...
[SwapChainNode::Compile] Checking swapchain wrapper...
[SwapChainNode::Compile] Swapchain wrapper OK
[SwapChainNode::Compile] Loading swapchain extensions...
[SwapChainNode::Compile] Instance handle: 0000022E01B1C680
[SwapChainNode::Compile] Extension function pointers loaded successfully
[ManagePresentMode] Available present modes: 2 3 1 0 1000361000 
[ManagePresentMode] Selected MAILBOX mode
[ManagePresentMode] Selected IMMEDIATE mode (uncapped FPS)
[SwapChainNode::Compile] ColorBuffers populated: 3 buffers
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Marking dependent node 'depth_buffer' for recompilation
[RenderGraph] Marking dependent node 'main_pass' for recompilation
[RenderGraph] Marking dependent node 'main_fb' for recompilation
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Marking dependent node 'main_descriptors' for recompilation
[RenderGraph] Recompiling 6 dirty nodes
[RenderGraph] Recompiling node: depth_buffer
[RenderGraph] Marking dependent node 'main_pass' for recompilation
[RenderGraph] Marking dependent node 'main_fb' for recompilation
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Recompiling node: main_pass
[RenderGraph] Marking dependent node 'main_fb' for recompilation
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Recompiling node: main_fb
[FramebufferNode::Compile] Creating 3 framebuffers from swapchain
[FramebufferNode::Compile] Processing attachment 0, view=0000570000000057
[FramebufferNode::Compile] Created framebuffer[0]=00005E000000005E
[FramebufferNode::Compile] Processing attachment 1, view=0000580000000058
[FramebufferNode::Compile] Created framebuffer[1]=00005F000000005F
[FramebufferNode::Compile] Processing attachment 2, view=0000590000000059
[FramebufferNode::Compile] Created framebuffer[2]=0000600000000060
[FramebufferNode::Compile] Output 3 framebuffers as vector
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: main_descriptors
[PerFrameResources] Cleaned up all per-frame resources
[DescriptorSetNode::Compile] Received ShaderDataBundle: Draw_Shader
[DescriptorSetNode::Compile] Found 2 descriptor bindings in set 0
[DescriptorSetNode::Compile] Binding 0: type=6, count=1, stages=1, name=myBufferVals
[DescriptorSetNode::Compile] Binding 1: type=1, count=1, stages=10, name=tex
[DescriptorSetNode::Compile] Successfully created descriptor set layout from reflection
[DescriptorSetNode::Compile] Created layout: 0000610000000061
[CalculateDescriptorPoolSizes] Pool size: type=6, count=1 (per-set=1, maxSets=1)
[CalculateDescriptorPoolSizes] Pool size: type=1, count=1 (per-set=1, maxSets=1)
[DescriptorSetNode::Compile] Created descriptor pool: 0000620000000062
[DescriptorSetNode::Compile] Allocated descriptor set: 0000630000000063
[DescriptorSetNode::Compile] Creating per-frame resources for 3 swapchain images
[PerFrameResources] Initialized for 3 frames
[PerFrameResources] Created UBO for frame 0 (buffer=0000640000000064, size=64)
[PerFrameResources] Created UBO for frame 1 (buffer=0000660000000066, size=64)
[PerFrameResources] Created UBO for frame 2 (buffer=0000680000000068, size=64)
[DescriptorSetNode::Compile] Created 3 per-frame UBOs
[DescriptorSetNode::Compile] Updated descriptor set with UBO (binding 0)
[DescriptorSetNode::Compile] Updated descriptor set with texture (view=00000A000000000A, sampler=00000B000000000B)
[DescriptorSetNode::Compile] Outputs set successfully
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_pipeline
[GraphicsPipelineNode::CleanupImpl] Releasing cached pipeline wrapper (cacher owns all resources)
[ExtractPushConstantsFromReflection] Push constant: pushConstantsColorBlock (offset=0, size=16, stages=0x10)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=12519004405771622927
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Vertex (key=12519004405771622927, VkShaderModule=50577534877742)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=11960572834381217403
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Fragment (key=11960572834381217403, VkShaderModule=51677046505519)
[GraphicsPipelineNode] enableVertexInput=1
[GraphicsPipelineNode] Calling BuildVertexInputsFromReflection...
[BuildVertexInputsFromReflection] bundle=valid reflectionData=valid vertexInputCount=2 hasReflection=1
[GraphicsPipelineNode] BuildVertexInputsFromReflection complete: 1 bindings, 2 attributes
  Binding 0: stride=24 inputRate=0
  Attribute location=0 binding=0 format=109 offset=0
  Attribute location=1 binding=0 format=103 offset=16
[GraphicsPipelineNode] Pipeline params: depth=1 depthWrite=1 cull=2 polyMode=0 topo=3
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::GetOrCreate] CACHE HIT for pipeline Draw_Shader+Draw_Shader (key=13576878286581977099, VkPipeline=54975581388850)
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[RenderGraph] Recompiling 4 dirty nodes
[RenderGraph] Recompiling node: main_pass
[RenderGraph] Marking dependent node 'main_fb' for recompilation
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Marking dependent node 'triangle_pipeline' for recompilation
[RenderGraph] Recompiling node: main_fb
[FramebufferNode::Compile] Creating 3 framebuffers from swapchain
[FramebufferNode::Compile] Processing attachment 0, view=0000570000000057
[FramebufferNode::Compile] Created framebuffer[0]=00006B000000006B
[FramebufferNode::Compile] Processing attachment 1, view=0000580000000058
[FramebufferNode::Compile] Created framebuffer[1]=00006C000000006C
[FramebufferNode::Compile] Processing attachment 2, view=0000590000000059
[FramebufferNode::Compile] Created framebuffer[2]=00006D000000006D
[FramebufferNode::Compile] Output 3 framebuffers as vector
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_pipeline
[GraphicsPipelineNode::CleanupImpl] Releasing cached pipeline wrapper (cacher owns all resources)
[ExtractPushConstantsFromReflection] Push constant: pushConstantsColorBlock (offset=0, size=16, stages=0x10)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=12519004405771622927
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Vertex (key=12519004405771622927, VkShaderModule=50577534877742)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=11960572834381217403
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Fragment (key=11960572834381217403, VkShaderModule=51677046505519)
[GraphicsPipelineNode] enableVertexInput=1
[GraphicsPipelineNode] Calling BuildVertexInputsFromReflection...
[BuildVertexInputsFromReflection] bundle=valid reflectionData=valid vertexInputCount=2 hasReflection=1
[GraphicsPipelineNode] BuildVertexInputsFromReflection complete: 1 bindings, 2 attributes
  Binding 0: stride=24 inputRate=0
  Attribute location=0 binding=0 format=109 offset=0
  Attribute location=1 binding=0 format=103 offset=16
[GraphicsPipelineNode] Pipeline params: depth=1 depthWrite=1 cull=2 polyMode=0 topo=3
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::GetOrCreate] CACHE HIT for pipeline Draw_Shader+Draw_Shader (key=13576878286581977099, VkPipeline=54975581388850)
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[RenderGraph] Recompiling 3 dirty nodes
[RenderGraph] Recompiling node: main_fb
[FramebufferNode::Compile] Creating 3 framebuffers from swapchain
[FramebufferNode::Compile] Processing attachment 0, view=0000570000000057
[FramebufferNode::Compile] Created framebuffer[0]=00006E000000006E
[FramebufferNode::Compile] Processing attachment 1, view=0000580000000058
[FramebufferNode::Compile] Created framebuffer[1]=00006F000000006F
[FramebufferNode::Compile] Processing attachment 2, view=0000590000000059
[FramebufferNode::Compile] Created framebuffer[2]=0000700000000070
[FramebufferNode::Compile] Output 3 framebuffers as vector
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_pipeline
[GraphicsPipelineNode::CleanupImpl] Releasing cached pipeline wrapper (cacher owns all resources)
[ExtractPushConstantsFromReflection] Push constant: pushConstantsColorBlock (offset=0, size=16, stages=0x10)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=12519004405771622927
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Vertex (key=12519004405771622927, VkShaderModule=50577534877742)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=11960572834381217403
[ShaderModuleCacher] CACHE HIT for SPIR-V Draw_Shader_Fragment (key=11960572834381217403, VkShaderModule=51677046505519)
[GraphicsPipelineNode] enableVertexInput=1
[GraphicsPipelineNode] Calling BuildVertexInputsFromReflection...
[BuildVertexInputsFromReflection] bundle=valid reflectionData=valid vertexInputCount=2 hasReflection=1
[GraphicsPipelineNode] BuildVertexInputsFromReflection complete: 1 bindings, 2 attributes
  Binding 0: stride=24 inputRate=0
  Attribute location=0 binding=0 format=109 offset=0
  Attribute location=1 binding=0 format=103 offset=16
[GraphicsPipelineNode] Pipeline params: depth=1 depthWrite=1 cull=2 polyMode=0 topo=3
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::GetOrCreate] CACHE HIT for pipeline Draw_Shader+Draw_Shader (key=13576878286581977099, VkPipeline=54975581388850)
[RenderGraph] Marking dependent node 'triangle_render' for recompilation
[RenderGraph] Recompiling node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[RenderGraph] Recompiling 1 dirty nodes
[RenderGraph] Recompiling node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[RenderGraph] All nodes successfully recompiled - graph is compiled
[RenderGraph] Render pause event: START (reason: 0)
[RenderGraph] Rendering paused - continuing with event processing only
[RenderGraph] Render pause event: END (reason: 0)
[RenderGraph] Rendering resumed
[RenderGraph] Received WindowCloseEvent - initiating graceful cleanup
[RenderGraph] Saving persistent caches asynchronously to: cache
[DeviceRegistry] Saved cacher manifest with 5 entries
[DeviceRegistry] Saving TextureCacher to "cache\\devices\\Device_0x10de91476520\\TextureCacher.cache"
[DeviceRegistry] Saving ShaderModuleCacher to "cache\\devices\\Device_0x10de91476520\\ShaderModuleCacher.cache"
[ShaderModuleCacher::SerializeToFile] Saving 4 shader modules to "cache\\devices\\Device_0x10de91476520\\ShaderModuleCacher.cache"
[DeviceRegistry] Saving DescriptorCacher to "cache\\devices\\Device_0x10de91476520\\DescriptorCacher.cache"
[DeviceRegistry] Saving PipelineCacher to "cache\\devices\\Device_0x10de91476520\\PipelineCacher.cache"
[ShaderModuleCacher::SerializeToFile] Successfully saved cache
[DeviceRegistry] Saving PipelineLayoutCacher to "cache\\devices\\Device_0x10de91476520\\PipelineLayoutCacher.cache"
[PipelineCacher] Serialized 1 pipeline caches (15003 bytes) to "cache\\devices\\Device_0x10de91476520\\PipelineCacher.cache"
[RenderGraph] Persistent caches saved successfully
[RenderGraph::ExecuteCleanup] Executing cleanup callbacks...
[GraphicsPipelineNode::CleanupImpl] Releasing cached pipeline wrapper (cacher owns all resources)
[PerFrameResources] Cleaned up all per-frame resources
[SwapChainNode::CleanupImpl] Called
[VulkanSwapChain::Destroy] Called with device=0000022E587D7460, instance=0000022E01B1C680
[VulkanSwapChain::Destroy] Current surface=0000520000000052, swapchain=0000530000000053
  Destroying VkSurfaceKHR
[VulkanSwapChain::Destroy] Cleanup complete
[ShaderModuleCacher::Cleanup] Cleaning up 4 cached shader modules
[ShaderModuleCacher::Cleanup] Destroying VkShaderModule: 13194139533324
[ShaderModuleCacher::Cleanup] Destroying VkShaderModule: 14293651161101
[ShaderModuleCacher::Cleanup] Destroying VkShaderModule: 50577534877742
[ShaderModuleCacher::Cleanup] Destroying VkShaderModule: 51677046505519
[ShaderModuleCacher::Cleanup] Cleanup complete
[PipelineCacher::Cleanup] Cleaning up 1 cached pipelines
[PipelineCacher::Cleanup] Destroying VkPipeline: 54975581388850
[PipelineCacher::Cleanup] Releasing shared pipeline layout wrapper
[PipelineCacher::Cleanup] Destroying VkPipelineCache: 52776558133296
[PipelineCacher::Cleanup] Cleanup complete
[PipelineLayoutCacher::Cleanup] Cleaning up 1 cached layouts
[PipelineLayoutCacher::Cleanup] Destroying VkPipelineLayout: 53876069761073
[PipelineLayoutCacher::Cleanup] Cleanup complete
[RenderGraph::ExecuteCleanup] Cleanup complete
[RenderGraph] Cleanup complete
[main] Cleaning up...
Logs written to binaries\vulkan_app_log.txt
[DeInitialize] Destroying render graph...
[RenderGraph::ExecuteCleanup] Executing cleanup callbacks...
[RenderGraph::ExecuteCleanup] Cleanup already executed, skipping
[DeInitialize] Render graph destroyed
[main] Exiting normally
Logs written to binaries\vulkan_app_log.txt
[DeInitialize] Destroying render graph...
[DeInitialize] Render graph destroyed
