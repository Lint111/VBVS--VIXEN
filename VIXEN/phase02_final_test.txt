[main] Starting VulkanGraphApplication...

Instanced Layers
================

AMD switchable graphics layer
	|
	\ --- [Layer Name] --> VK_LAYER_AMD_switchable_graphics

NVIDIA Optimus layer
	|
	\ --- [Layer Name] --> VK_LAYER_NV_optimus

NVIDIA GR2608 layer
	|
	\ --- [Layer Name] --> VK_LAYER_NV_present

Steam Overlay Layer
	|
	\ --- [Layer Name] --> VK_LAYER_VALVE_steam_overlay

Steam Pipeline Caching Layer
	|
	\ --- [Layer Name] --> VK_LAYER_VALVE_steam_fossilize

Open Broadcaster Software hook
	|
	\ --- [Layer Name] --> VK_LAYER_OBS_HOOK

Open Broadcaster Software hook
	|
	\ --- [Layer Name] --> VK_LAYER_OBS_HOOK

LunarG API dump layer
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_api_dump
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

GFXReconstruct Capture Layer Version 1.0.5
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_gfxreconstruct

Khronos Synchronization2 layer
	|
	\ --- [Layer Name] --> VK_LAYER_KHRONOS_synchronization2
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

Khronos Validation Layer
	|
	\ --- [Layer Name] --> VK_LAYER_KHRONOS_validation
		|
		|--- [LayerExtension] --> VK_EXT_debug_report
		|
		|--- [LayerExtension] --> VK_EXT_debug_utils
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings
		|
		|--- [LayerExtension] --> VK_EXT_validation_features

Execution Monitoring Layer
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_monitor
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

LunarG image capture layer
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_screenshot
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

Khronos Profiles layer
	|
	\ --- [Layer Name] --> VK_LAYER_KHRONOS_profiles
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

Khronos Shader object layer
	|
	\ --- [Layer Name] --> VK_LAYER_KHRONOS_shader_object
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings

Crash Diagnostic Layer is a crash/hang debugging tool that helps determines GPU progress in a Vulkan application.
	|
	\ --- [Layer Name] --> VK_LAYER_LUNARG_crash_diagnostic
		|
		|--- [LayerExtension] --> VK_EXT_debug_report
		|
		|--- [LayerExtension] --> VK_EXT_debug_utils
		|
		|--- [LayerExtension] --> VK_EXT_layer_settings
[main] Calling Initialize...
Layer support found, keep the layer: VK_LAYER_KHRONOS_validation
GetProcAddr: Found vkCreateDebugReportCallbackEXT function.
GetProcAddr: Found vkDestroyDebugReportCallbackEXT function.
Debug Callback: Successfully created.
[main] Calling Prepare...
[VulkanGraphApplication::Prepare] START
[VulkanGraphApplication::Prepare] Calling BuildRenderGraph...
[VulkanGraphApplication::Prepare] BuildRenderGraph complete
[VulkanGraphApplication::Prepare] Calling CompileRenderGraph...
[CompileRenderGraph] START
[CompileRenderGraph] Pre-compiling device node...
[VulkanDevice::CreateDevice] Enabling 3 extensions:
[VulkanDevice::CreateDevice]   0: VK_KHR_swapchain
[VulkanDevice::CreateDevice]   1: VK_EXT_swapchain_maintenance1
[VulkanDevice::CreateDevice]   2: VK_KHR_maintenance6
[CompileRenderGraph] Device node compiled and marked as Compiled
[CompileRenderGraph] Calling graph.Compile()...
[RenderGraph::Compile] Starting compilation...
[RenderGraph::Compile] Phase: Validation...
[RenderGraph::Compile] Phase: AnalyzeDependencies...
[RenderGraph::Compile] Phase: AllocateResources...
[RenderGraph::Compile] Phase: GeneratePipelines...
[GeneratePipelines] Total instances to compile: 15
[GeneratePipelines]   0: main_device
[GeneratePipelines]   1: triangle_vb
[GeneratePipelines]   2: main_texture
[GeneratePipelines]   3: shader_lib
[GeneratePipelines]   4: main_cmd_pool
[GeneratePipelines]   5: frame_sync
[GeneratePipelines]   6: main_window
[GeneratePipelines]   7: main_swapchain
[GeneratePipelines]   8: present
[GeneratePipelines]   9: main_descriptors
[GeneratePipelines]   10: depth_buffer
[GeneratePipelines]   11: main_pass
[GeneratePipelines]   12: triangle_pipeline
[GeneratePipelines]   13: main_fb
[GeneratePipelines]   14: triangle_render
[GeneratePipelines] Skipping already-compiled node: main_device
[GeneratePipelines] Calling Setup() on node: triangle_vb
[GeneratePipelines] Loading persistent caches...
[RenderGraph] Loading persistent caches from: cache
[DeviceRegistry] Pre-registering cachers from manifest...
[DeviceRegistry] Found cacher in manifest: TextureCacher
[DeviceRegistry] Found cacher in manifest: ShaderModuleCacher
[DeviceRegistry] Found cacher in manifest: DescriptorCacher
[DeviceRegistry] Found cacher in manifest: PipelineCacher
[DeviceRegistry] Found cacher in manifest: PipelineLayoutCacher
[RenderGraph] Persistent caches loaded successfully
[GeneratePipelines] Calling Compile() on node: triangle_vb
[VertexBufferNode::Compile] vertexBuffer BEFORE Out(): 2199023255554
[VertexBufferNode::Compile] vertexBuffer AFTER Out(): 2199023255554
[GeneratePipelines] Node compiled successfully: triangle_vb
[GeneratePipelines] Calling Setup() on node: main_texture
[TextureLoader] Base constructor - device=000001BE4A4EA910, cmdPool=0000040000000004
[STBTextureLoader] Constructor called
[GeneratePipelines] Calling Compile() on node: main_texture
[TextureLoader::Load] START
[TextureLoader::Load] Calling LoadPixelData...
[STB] LoadPixelData ENTRY
[STB] Loading: C:\Users\liory\Downloads\earthmap.jpg
[STB] Loaded 1024x512, 3 channels
[GeneratePipelines] Node compiled successfully: main_texture
[GeneratePipelines] Calling Setup() on node: shader_lib
[ShaderLibraryNode::Setup] Called
[ShaderLibraryNode::Setup] Complete
[GeneratePipelines] Calling Compile() on node: shader_lib
[ShaderLibraryNode::Compile] START - Phase 1 integration
[ShaderLibraryNode] Current working directory: "C:\\cpp\\VBVS--VIXEN\\VIXEN"
[ShaderLibraryNode] Found shaders at: "Shaders"
[ShaderLibraryNode] Checking for shader files...
[ShaderLibraryNode] Vertex path: "Shaders/Draw.vert" exists=1
[ShaderLibraryNode] Fragment path: "Shaders\\Draw.frag" exists=1
[ShaderLibraryNode] Creating ShaderBundleBuilder...
[ShaderLibraryNode] Stages added (SDI enabled), calling Build()...
[2025-11-01 11:39:12] [INFO] [Compiler] Compiling stage: Vertex
[2025-11-01 11:39:13] [INFO] [Compiler] Compiling stage: Fragment
[SpirvReflector::ReflectVertexInputs] location=1 name=inUV format=103 (from SPIRV-Reflect)
[SpirvReflector::ReflectVertexInputs] location=0 name=pos format=109 (from SPIRV-Reflect)
[2025-11-01 11:39:13] [INFO] [SDI] Generated shader-specific Names header: C:\cpp\VBVS--VIXEN\VIXEN\generated\sdi\Draw_ShaderNames.h
[2025-11-01 11:39:13] [INFO] [Builder] Shader bundle build completed successfully: Draw_Shader (691ms)
[ShaderLibraryNode] Shader bundle built successfully
[ShaderLibraryNode] Using device: 000001BE4A4EA910
[ShaderLibraryNode] Creating VkShaderModules via CashSystem...
[ShaderLibraryNode] Checking if ShaderModuleCacher is registered...
[ShaderLibraryNode] Is registered: 0
[ShaderLibraryNode] Registering ShaderModuleCacher...
[ShaderLibraryNode] ShaderModuleCacher registered
[ShaderLibraryNode] Getting ShaderModuleCacher from MainCacher...
[ShaderLibraryNode] Device pointer value: 000001BE4A4EA910
[ShaderLibraryNode] IsDeviceDependent: 1
[ShaderLibraryNode] Got ShaderModuleCacher successfully
[ShaderLibraryNode] ShaderModuleCacher->IsInitialized()=1
[ShaderLibraryNode] ShaderModuleCacher->GetDevice()=000001BE4A4EA910
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=5635850799421726357
[ShaderModuleCacher] CACHE MISS for SPIR-V Draw_Vertex (key=5635850799421726357), creating new VkShaderModule...
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkCreateShaderModule(): pCreateInfo->pCode (spirv-val produced an error):
Invalid SPIR-V header.
The Vulkan spec states: If pCode is a pointer to SPIR-V code, pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/shaders.html#VUID-VkShaderModuleCreateInfo-pCode-08737)
[ShaderModuleCacher] VkShaderModule created from SPIR-V: 13194139533324
[ShaderModuleCacher] GetOrCreateFromSpirv EXIT: VkShaderModule=13194139533324
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=1416478403420909105
[ShaderModuleCacher] CACHE MISS for SPIR-V Draw_Fragment (key=1416478403420909105), creating new VkShaderModule...
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkCreateShaderModule(): pCreateInfo->pCode (spirv-val produced an error):
Invalid SPIR-V header.
The Vulkan spec states: If pCode is a pointer to SPIR-V code, pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/shaders.html#VUID-VkShaderModuleCreateInfo-pCode-08737)
[ShaderModuleCacher] VkShaderModule created from SPIR-V: 14293651161101
[ShaderModuleCacher] GetOrCreateFromSpirv EXIT: VkShaderModule=14293651161101
[GeneratePipelines] Node compiled successfully: shader_lib
[GeneratePipelines] Calling Setup() on node: main_cmd_pool
[GeneratePipelines] Calling Compile() on node: main_cmd_pool
[GeneratePipelines] Node compiled successfully: main_cmd_pool
[GeneratePipelines] Calling Setup() on node: frame_sync
[GeneratePipelines] Calling Compile() on node: frame_sync
[GeneratePipelines] Node compiled successfully: frame_sync
[GeneratePipelines] Calling Setup() on node: main_window
[GeneratePipelines] Calling Compile() on node: main_window
[WindowNode::Compile] START
[WindowNode::Compile] Creating window 800x600
[GeneratePipelines] Node compiled successfully: main_window
[GeneratePipelines] Calling Setup() on node: main_swapchain
[GeneratePipelines] Calling Compile() on node: main_swapchain
[SwapChainNode::Compile] START
[SwapChainNode::Compile] Reading HWND...
[SwapChainNode::Compile] Reading HINSTANCE...
[SwapChainNode::Compile] Reading WIDTH...
[SwapChainNode::Compile] WIDTH = 800
[SwapChainNode::Compile] Reading HEIGHT...
[SwapChainNode::Compile] HEIGHT = 600
[SwapChainNode::Compile] Reading INSTANCE...
[SwapChainNode::Compile] Validating dimensions...
[SwapChainNode::Compile] Validating HWND...
[SwapChainNode::Compile] Validating HINSTANCE...
[SwapChainNode::Compile] Validating VkInstance...
[SwapChainNode::Compile] Checking swapchain wrapper...
[SwapChainNode::Compile] Swapchain wrapper OK
[SwapChainNode::Compile] Loading swapchain extensions...
[SwapChainNode::Compile] Instance handle: 000001BE75819790
[SwapChainNode::Compile] Extension function pointers loaded successfully
[ManagePresentMode] Available present modes: 2 3 1 0 1000361000 
[ManagePresentMode] Selected MAILBOX mode
[ManagePresentMode] Selected IMMEDIATE mode (uncapped FPS)
[SwapChainNode::Compile] ColorBuffers populated: 3 buffers
[GeneratePipelines] Node compiled successfully: main_swapchain
[GeneratePipelines] Calling Setup() on node: present
[GeneratePipelines] Calling Compile() on node: present
[GeneratePipelines] Node compiled successfully: present
[GeneratePipelines] Calling Setup() on node: main_descriptors
[GeneratePipelines] Calling Compile() on node: main_descriptors
[DescriptorSetNode::Compile] Received ShaderDataBundle: Draw_Shader
[DescriptorSetNode::Compile] Found 2 descriptor bindings in set 0
[DescriptorSetNode::Compile] Binding 0: type=6, count=1, stages=1, name=myBufferVals
[DescriptorSetNode::Compile] Binding 1: type=1, count=1, stages=10, name=tex
[DescriptorSetNode::Compile] Successfully created descriptor set layout from reflection
[DescriptorSetNode::Compile] Created layout: 00001E000000001E
[CalculateDescriptorPoolSizes] Pool size: type=6, count=1 (per-set=1, maxSets=1)
[CalculateDescriptorPoolSizes] Pool size: type=1, count=1 (per-set=1, maxSets=1)
[DescriptorSetNode::Compile] Created descriptor pool: 00001F000000001F
[DescriptorSetNode::Compile] Allocated descriptor set: 0000200000000020
[DescriptorSetNode::Compile] Creating per-frame resources for 3 swapchain images
[PerFrameResources] Initialized for 3 frames
[PerFrameResources] Created UBO for frame 0 (buffer=0000210000000021, size=64)
[PerFrameResources] Created UBO for frame 1 (buffer=0000230000000023, size=64)
[PerFrameResources] Created UBO for frame 2 (buffer=0000250000000025, size=64)
[DescriptorSetNode::Compile] Created 3 per-frame UBOs
[DescriptorSetNode::Compile] Updated descriptor set with UBO (binding 0)
[DescriptorSetNode::Compile] Updated descriptor set with texture (view=00000A000000000A, sampler=00000B000000000B)
[DescriptorSetNode::Compile] Outputs set successfully
[GeneratePipelines] Node compiled successfully: main_descriptors
[GeneratePipelines] Calling Setup() on node: depth_buffer
[GeneratePipelines] Calling Compile() on node: depth_buffer
[GeneratePipelines] Node compiled successfully: depth_buffer
[GeneratePipelines] Calling Setup() on node: main_pass
[GeneratePipelines] Calling Compile() on node: main_pass
[GeneratePipelines] Node compiled successfully: main_pass
[GeneratePipelines] Calling Setup() on node: triangle_pipeline
[GeneratePipelines] Calling Compile() on node: triangle_pipeline
[ExtractPushConstantsFromReflection] Push constant: pushConstantsColorBlock (offset=0, size=16, stages=0x10)
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Vertex
[ShaderModuleCacher]   SPIR-V size=371 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=1
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=32 schema=0
[ShaderModuleCacher]   cache_key=12519004405771622927
[ShaderModuleCacher] CACHE MISS for SPIR-V Draw_Shader_Vertex (key=12519004405771622927), creating new VkShaderModule...
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkCreateShaderModule(): pCreateInfo->pCode (spirv-val produced an error):
Invalid SPIR-V header.
The Vulkan spec states: If pCode is a pointer to SPIR-V code, pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/shaders.html#VUID-VkShaderModuleCreateInfo-pCode-08737)
[ShaderModuleCacher] VkShaderModule created from SPIR-V: 47278999994411
[ShaderModuleCacher] GetOrCreateFromSpirv EXIT: VkShaderModule=47278999994411
[ShaderModuleCacher] GetOrCreateFromSpirv ENTRY: Draw_Shader_Fragment
[ShaderModuleCacher]   SPIR-V size=262 uint32_t words
[ShaderModuleCacher]   entryPoint=main
[ShaderModuleCacher]   stage=16
[ShaderModuleCacher]   SPIR-V header: magic=7230203 version=96 generator=8000b bound=24 schema=0
[ShaderModuleCacher]   cache_key=11960572834381217403
[ShaderModuleCacher] CACHE MISS for SPIR-V Draw_Shader_Fragment (key=11960572834381217403), creating new VkShaderModule...
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkCreateShaderModule(): pCreateInfo->pCode (spirv-val produced an error):
Invalid SPIR-V header.
The Vulkan spec states: If pCode is a pointer to SPIR-V code, pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/shaders.html#VUID-VkShaderModuleCreateInfo-pCode-08737)
[ShaderModuleCacher] VkShaderModule created from SPIR-V: 48378511622188
[ShaderModuleCacher] GetOrCreateFromSpirv EXIT: VkShaderModule=48378511622188
[GraphicsPipelineNode] enableVertexInput=1
[GraphicsPipelineNode] Calling BuildVertexInputsFromReflection...
[BuildVertexInputsFromReflection] bundle=valid reflectionData=valid vertexInputCount=2 hasReflection=1
[GraphicsPipelineNode] BuildVertexInputsFromReflection complete: 1 bindings, 2 attributes
  Binding 0: stride=24 inputRate=0
  Attribute location=0 binding=0 format=109 offset=0
  Attribute location=1 binding=0 format=103 offset=16
[GraphicsPipelineNode] Pipeline params: depth=1 depthWrite=1 cull=2 polyMode=0 topo=3
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::GetOrCreate] CACHE MISS for pipeline Draw_Shader+Draw_Shader (key=13576878286581977099), creating new resource...
[PipelineCacher::ComputeKey] keyString="Draw_Shader|Draw_Shader|main_pipeline_layout|main_render_pass|1|1|2|0|3" hash=13576878286581977099
[PipelineCacher::Create] CACHE MISS - Creating new pipeline: Draw_Shader + Draw_Shader
[PipelineCacher::Create] Creating pipeline cache...
[PipelineCacher::Create] Creating pipeline layout...
[PipelineCacher] No layout wrapper provided, using convenience path (PipelineLayoutCacher)
[PipelineCacher] Registering PipelineLayoutCacher
[PipelineLayoutCacher::ComputeKey] keyString="32985348833310|1|16:0:16" hash=2116684100891140322
[PipelineLayoutCacher::GetOrCreate] CACHE MISS for layout main_pipeline_layout (key=2116684100891140322), creating new resource...
[PipelineLayoutCacher::ComputeKey] keyString="32985348833310|1|16:0:16" hash=2116684100891140322
[PipelineLayoutCacher::Create] Creating pipeline layout: main_pipeline_layout
[PipelineLayoutCacher::Create] Created VkPipelineLayout: 50577534877742
[PipelineCacher] Using shared VkPipelineLayout: 50577534877742
[PipelineCacher::Create] Creating VkPipeline...
[PipelineCacher::CreatePipeline] Using 2 shader stages
[PipelineCacher::Create] VkPipeline created: 51677046505519
[GeneratePipelines] Node compiled successfully: triangle_pipeline
[GeneratePipelines] Calling Setup() on node: main_fb
[GeneratePipelines] Calling Compile() on node: main_fb
[FramebufferNode::Compile] Creating 3 framebuffers from swapchain
[FramebufferNode::Compile] Processing attachment 0, view=00001B000000001B
[FramebufferNode::Compile] Created framebuffer[0]=0000300000000030
[FramebufferNode::Compile] Processing attachment 1, view=00001C000000001C
[FramebufferNode::Compile] Created framebuffer[1]=0000310000000031
[FramebufferNode::Compile] Processing attachment 2, view=00001D000000001D
[FramebufferNode::Compile] Created framebuffer[2]=0000320000000032
[FramebufferNode::Compile] Output 3 framebuffers as vector
[GeneratePipelines] Node compiled successfully: main_fb
[GeneratePipelines] Calling Setup() on node: triangle_render
[GeneratePipelines] Calling Compile() on node: triangle_render
[GeometryRenderNode::Compile] Swapchain has 3 images, allocating command buffers
[GeneratePipelines] Node compiled successfully: triangle_render
[RenderGraph::Compile] Phase: BuildExecutionOrder...
[RenderGraph::Compile] Compilation complete!
[CompileRenderGraph] Graph compilation complete
[CompileRenderGraph] Validating graph...
[CompileRenderGraph] Validation passed
[CompileRenderGraph] SUCCESS
[VulkanGraphApplication::Prepare] CompileRenderGraph complete
[VulkanGraphApplication::Prepare] SUCCESS - isPrepared = true
[main] Entering render loop...
[RenderGraph] Window state changed: FOCUSED
[RenderGraph] Render pause event: START (reason: 0)
[RenderGraph] Rendering paused - continuing with event processing only
[RenderGraph] Render pause event: END (reason: 0)
[RenderGraph] Rendering resumed
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueuePresentKHR(): pPresentInfo->pWaitSemaphores[0] queue (VkQueue 0x1be4a547390) is waiting on semaphore (VkSemaphore 0x140000000014) that has no way to be signaled.
The Vulkan spec states: All elements of the pWaitSemaphores member of pPresentInfo must reference a semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends must have also been submitted for execution (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/VK_KHR_surface/wsi.html#VUID-vkQueuePresentKHR-pWaitSemaphores-03268)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueuePresentKHR(): pPresentInfo->pImageIndices[0] was acquired with a semaphore VkSemaphore 0x130000000013 that has not since been waited on
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueuePresentKHR(): pPresentInfo->pSwapchains[0] images passed to present must be in layout VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR but VkImage 0x180000000018 is in VK_IMAGE_LAYOUT_UNDEFINED.
The Vulkan spec states: Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time the operation is executed on a VkDevice (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/VK_KHR_surface/wsi.html#VUID-VkPresentInfoKHR-pImageIndices-01430)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x140000000014) is being signaled by VkQueue 0x1be4a547390, but it may still be in use by VkSwapchainKHR 0x170000000017.
Here are the most recently acquired image indices: [0].
(brackets mark the last use of VkSemaphore 0x140000000014 in a presentation operation)
Swapchain image 0 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x140000000014 may still be in use.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueuePresentKHR(): pPresentInfo->pWaitSemaphores[0] queue (VkQueue 0x1be4a547390) is waiting on semaphore (VkSemaphore 0x110000000011) that has no way to be signaled.
The Vulkan spec states: All elements of the pWaitSemaphores member of pPresentInfo must reference a semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends must have also been submitted for execution (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/VK_KHR_surface/wsi.html#VUID-vkQueuePresentKHR-pWaitSemaphores-03268)
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueuePresentKHR(): pPresentInfo->pImageIndices[0] was acquired with a semaphore VkSemaphore 0x100000000010 that has not since been waited on
[VK_DEBUG_REPORT] ERROR: [Validation] Code 0 : vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x110000000011) is being signaled by VkQueue 0x1be4a547390, but it may still be in use by VkSwapchainKHR 0x170000000017.
Here are the most recently acquired image indices: 0, [0].
(brackets mark the last use of VkSemaphore 0x110000000011 in a presentation operation)
Swapchain image 0 was presented but was neither re-acquired nor waited on using a VK_KHR_swapchain_maintenance1 fence, so VkSemaphore 0x110000000011 may still be in use.
Vulkan insight: One solution is to assign each image its own semaphore. This also handles the case where vkAcquireNextImageKHR returns the same index twice in a row. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_KHR_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://vulkan.lunarg.com/doc/view/1.4.321.1/windows/antora/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
