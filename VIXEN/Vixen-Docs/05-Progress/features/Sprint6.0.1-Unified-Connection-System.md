---
title: "Sprint 6.0.1: Unified Connection System"
status: COMPLETE
priority: HIGH
prerequisite_for: Sprint 6 Phase 1 (MultiDispatchNode)
created: 2026-01-04
completed: 2026-01-04
tags: [architecture, rendergraph, connection-system, sprint-6]
---

# Sprint 6.0.1: Unified Connection System

## Executive Summary

Architectural overhaul of RenderGraph's connection system to provide a single, consistent API for all connection types. This is a **prerequisite** for MultiDispatchNode (Sprint 6 Phase 1) which requires Accumulation connections.

## Problem Statement

### Current State: Multiple Connection APIs

```cpp
// 1. Direct connection
batch.Connect(nodeA, ConfigA::OUTPUT, nodeB, ConfigB::INPUT);

// 2. Variadic connection (separate API)
batch.ConnectVariadic(nodeA, ConfigA::OUTPUT, gatherer, binding, slotRole);

// 3. Proposed Accumulation (would be ANOTHER API)
batch.ConnectAccumulate(nodeA, ConfigA::OUTPUT, nodeB, ConfigB::ARRAY_INPUT);
```

### Issues

1. **Multiple APIs** - User must know which to call based on target node type
2. **Implicit semantics** - Connection behavior depends on API choice, not slot metadata
3. **Slot macro proliferation** - `INPUT_SLOT`, `VARIADIC_SLOT`, `ACCUMULATION_SLOT`...
4. **Variadic index ambiguity** - Integer `0` could mean static slot 0 or variadic binding 0
5. **Implicit ordering** - Variadic uses connection order for array ordering (fragile)

## Proposed Solution: Unified Connection System

### Core Principle

> **One `Connect()` API. Slot metadata determines behavior. Type system encodes intent.**

### Design Goals

1. **Single API** - `batch.Connect(src, srcSlot, tgt, tgtSlot, metadata?)`
2. **Slot-level configuration** - Behavior defined in slot definition, not at call site
3. **Type-based disambiguation** - `SlotRef` vs `BindingRef` resolved at compile time
4. **Explicit ordering** - Metadata carries sort keys, not connection order
5. **Extensible** - New connection types via `ConnectionRule` classes, not new APIs

---

## Architecture

### 1. Slot Flags (Single Macro)

```cpp
// Same INPUT_SLOT macro, new flags field
INPUT_SLOT(DISPATCH_PASSES, std::vector<DispatchPass>, 0,
    SlotNullability::Required,
    SlotRole::Dependency,
    SlotMutability::ReadOnly,
    SlotScope::NodeLevel,
    SlotFlags::Accumulation | SlotFlags::MultiConnect,  // NEW
    AccumulationConfig{.minConnections = 1, .maxConnections = 64,
                       .orderStrategy = OrderStrategy::ByMetadata});

enum class SlotFlags : uint32_t {
    None           = 0,
    Accumulation   = 1 << 0,  // Accepts T → vector<T>, flattens vector<T>
    MultiConnect   = 1 << 1,  // Allows multiple sources to same slot
    ExplicitOrder  = 1 << 2,  // Requires ordering metadata
};
```

### 2. C++20 Concepts for Type-Based Resolution

VIXEN uses C++23, so we leverage concepts for clean constraints and helpful error messages.

```cpp
// ============================================================================
// CORE CONCEPTS
// ============================================================================

/**
 * @brief Concept for static slot references from node configs
 *
 * Satisfied by types generated by INPUT_SLOT/OUTPUT_SLOT macros.
 * These have compile-time metadata: index, role, nullability, etc.
 */
template<typename T>
concept SlotReference = requires {
    typename T::Type;                                      // Slot data type
    { T::index } -> std::convertible_to<uint32_t>;         // Slot index
    { T::role } -> std::convertible_to<SlotRole>;          // Dependency/Execute
    { T::nullability } -> std::convertible_to<SlotNullability>;
    { T::mutability } -> std::convertible_to<SlotMutability>;
    { T::scope } -> std::convertible_to<SlotScope>;
};

/**
 * @brief Concept for binding references from shader metadata
 *
 * Satisfied by BindingRef types from shader SDI (e.g., VoxelRayMarch::esvoNodes).
 * These map to descriptor set bindings discovered at runtime.
 */
template<typename T>
concept BindingReference = requires(T t) {
    { t.binding } -> std::convertible_to<uint32_t>;        // Shader binding index
    { t.descriptorType } -> std::convertible_to<VkDescriptorType>;
};

/**
 * @brief Concept for accumulation-enabled slots
 *
 * Extends SlotReference with accumulation flag requirement.
 * Used for slots that accept multiple connections merged into vector<T>.
 */
template<typename T>
concept AccumulationSlot = SlotReference<T> && requires {
    { (T::flags & SlotFlags::Accumulation) != SlotFlags::None }
        -> std::convertible_to<bool>;
};

/**
 * @brief Concept for connection metadata
 *
 * Optional metadata passed to Connect() for ordering, role hints, etc.
 */
template<typename T>
concept ConnectionMetadata = requires(T t) {
    { t.sortKey } -> std::convertible_to<int32_t>;         // Ordering key
} || std::is_same_v<T, SlotRole>;  // Or just a SlotRole

// ============================================================================
// LEGACY TYPE TRAITS (for backward compatibility)
// ============================================================================

template<typename T>
struct is_slot_ref : std::bool_constant<SlotReference<T>> {};

template<typename T>
inline constexpr bool is_slot_ref_v = SlotReference<T>;

template<typename T>
struct is_binding_ref : std::bool_constant<BindingReference<T>> {};

template<typename T>
inline constexpr bool is_binding_ref_v = BindingReference<T>;
```

**Benefits of Concepts:**

| Aspect | Type Traits | Concepts |
|--------|-------------|----------|
| Error messages | "no matching function" | "T does not satisfy SlotReference" |
| Syntax | `enable_if_t<is_slot_ref_v<T>>` | `SlotReference T` |
| Composition | Manual nesting | `AccumulationSlot = SlotReference && ...` |
| Documentation | Separate from code | Self-documenting constraints |

### 3. Unified Connect API (Concept-Constrained)

```cpp
// ============================================================================
// OVERLOAD SET - Concepts enable clean overload resolution
// ============================================================================

/**
 * @brief Direct connection: SlotRef → SlotRef
 *
 * Standard 1:1 connection between static slots.
 */
template<SlotReference Src, SlotReference Tgt>
void Connect(NodeHandle src, Src srcSlot,
             NodeHandle tgt, Tgt tgtSlot) {
    // Check for accumulation flag at compile time
    if constexpr (AccumulationSlot<Tgt>) {
        ConnectAccumulationImpl(src, srcSlot, tgt, tgtSlot, {});
    } else {
        ConnectDirectImpl(src, srcSlot, tgt, tgtSlot);
    }
}

/**
 * @brief Accumulation connection with metadata: SlotRef → AccumulationSlot
 *
 * Connects source to accumulation slot with ordering metadata.
 */
template<SlotReference Src, AccumulationSlot Tgt, ConnectionMetadata Meta>
void Connect(NodeHandle src, Src srcSlot,
             NodeHandle tgt, Tgt tgtSlot,
             Meta metadata) {
    ConnectAccumulationImpl(src, srcSlot, tgt, tgtSlot, metadata);
}

/**
 * @brief Variadic connection: SlotRef → BindingRef
 *
 * Connects source to variadic node's shader binding.
 */
template<SlotReference Src, BindingReference Tgt>
void Connect(NodeHandle src, Src srcSlot,
             NodeHandle tgt, Tgt tgtSlot,
             SlotRole role = SlotRole::Dependency) {
    ConnectVariadicImpl(src, srcSlot, tgt, tgtSlot, role);
}

/**
 * @brief Variadic with field extraction: SlotRef → BindingRef + member pointer
 *
 * Extracts field from source struct for push constant gathering.
 */
template<SlotReference Src, BindingReference Tgt, typename T, typename Field>
void Connect(NodeHandle src, Src srcSlot,
             NodeHandle tgt, Tgt tgtSlot,
             Field T::* memberPtr,
             SlotRole role = SlotRole::Execute) {
    ConnectVariadicWithExtractionImpl(src, srcSlot, tgt, tgtSlot, memberPtr, role);
}

// ============================================================================
// ERROR HANDLING - Concepts provide clear diagnostics
// ============================================================================

// Attempting to connect incompatible types produces clear errors:
//
// Connect(node1, Config::OUTPUT, node2, 42);
// Error: no matching function for call to 'Connect'
//        note: candidate template ignored: constraints not satisfied
//        note: because 'int' does not satisfy 'SlotReference'
//        note: because 'int::Type' would be invalid
```

### 4. ConnectionRule Base Class (Extensibility)

```cpp
class ConnectionRule {
public:
    virtual ~ConnectionRule() = default;

    // Check if this rule can handle the connection
    virtual bool CanHandle(const SlotDescriptor& source,
                          const SlotDescriptor& target) const = 0;

    // Validate the connection
    virtual bool Validate(const ConnectionContext& ctx,
                         std::string& errorMsg) const = 0;

    // Resolve the connection (called during Compile/Execute)
    virtual void Resolve(ConnectionContext& ctx) const = 0;

    // Priority for rule matching (higher = checked first)
    virtual uint32_t Priority() const { return 0; }
};

// Concrete rules
class DirectConnectionRule : public ConnectionRule { ... };
class AccumulationConnectionRule : public ConnectionRule { ... };
class VariadicConnectionRule : public ConnectionRule { ... };

// Graph maintains rule registry
class ConnectionRuleRegistry {
    std::vector<std::unique_ptr<ConnectionRule>> rules_;

    const ConnectionRule* FindRule(const SlotDescriptor& src,
                                   const SlotDescriptor& tgt) const;
};
```

### 4b. ConnectionModifier (Stackable Middleware)

**Problem:** Field extraction is orthogonal to connection types - it should work with Direct, Variadic, or Accumulation connections. Creating `DirectWithExtractionRule`, `VariadicWithExtractionRule`, etc. leads to N×M class explosion.

**Solution:** Stackable modifiers that wrap any ConnectionRule with additional behavior.

```cpp
// ============================================================================
// 3-PHASE MODIFIER INTERFACE
// ============================================================================

class ConnectionModifier {
public:
    virtual ~ConnectionModifier() = default;

    /// Phase 1: Pre-validation checks (before rule validates)
    /// Use for: Guards, preconditions, early rejection
    virtual ConnectionResult PreValidation(ConnectionContext& ctx) {
        return ConnectionResult::Success();
    }

    /// Phase 2: Pre-resolve transformation (before rule resolves)
    /// Use for: Context mutation, type transformation, offset calculation
    virtual ConnectionResult PreResolve(ConnectionContext& ctx) {
        return ConnectionResult::Success();
    }

    /// Phase 3: Post-resolve hooks (after rule resolves)
    /// Use for: Debug registration, metrics, callbacks
    virtual ConnectionResult PostResolve(ConnectionContext& ctx) {
        return ConnectionResult::Success();
    }

    /// Priority for modifier ordering (higher = runs first within phase)
    virtual uint32_t Priority() const { return 50; }

    /// Name for debugging/logging
    virtual std::string_view Name() const = 0;
};

// ============================================================================
// PIPELINE EXECUTION
// ============================================================================

class ConnectionPipeline {
public:
    void AddModifier(std::unique_ptr<ConnectionModifier> modifier);

    ConnectionResult Execute(ConnectionContext& ctx, const ConnectionRule& rule) {
        // Phase 1: All modifiers PreValidation
        for (auto& mod : modifiers_) {
            if (auto result = mod->PreValidation(ctx); !result.IsSuccess())
                return result;
        }

        // Base rule validation
        std::string errorMsg;
        if (!rule.Validate(ctx, errorMsg))
            return ConnectionResult::Error(errorMsg);

        // Phase 2: All modifiers PreResolve
        for (auto& mod : modifiers_) {
            if (auto result = mod->PreResolve(ctx); !result.IsSuccess())
                return result;
        }

        // Base rule resolution
        rule.Resolve(ctx);

        // Phase 3: All modifiers PostResolve
        for (auto& mod : modifiers_) {
            if (auto result = mod->PostResolve(ctx); !result.IsSuccess())
                return result;
        }

        return ConnectionResult::Success();
    }

private:
    std::vector<std::unique_ptr<ConnectionModifier>> modifiers_;
};

// ============================================================================
// FIELD EXTRACTION MODIFIER
// ============================================================================

class FieldExtractionModifier : public ConnectionModifier {
public:
    FieldExtractionModifier(size_t fieldOffset, ResourceType fieldType)
        : fieldOffset_(fieldOffset), fieldType_(fieldType) {}

    ConnectionResult PreValidation(ConnectionContext& ctx) override {
        // Verify source has Persistent lifetime (required for stable pointer)
        if (ctx.sourceLifetime != ResourceLifetime::Persistent) {
            return ConnectionResult::Error(
                "Field extraction requires Persistent lifetime source");
        }
        return ConnectionResult::Success();
    }

    ConnectionResult PreResolve(ConnectionContext& ctx) override {
        // Transform context: use field's type instead of source struct type
        ctx.effectiveResourceType = fieldType_;
        ctx.fieldOffset = fieldOffset_;
        ctx.hasFieldExtraction = true;
        return ConnectionResult::Success();
    }

    std::string_view Name() const override { return "FieldExtraction"; }

private:
    size_t fieldOffset_;
    ResourceType fieldType_;
};
```

**Benefits:**

| Aspect | Before (Rule Subclasses) | After (Modifiers) |
|--------|--------------------------|-------------------|
| Field extraction | Separate `ConnectVariadicWithExtraction()` | `FieldExtractionModifier` on any rule |
| New cross-cutting feature | Modify 3+ rule classes | Add 1 modifier class |
| Composition | Impossible | Stack multiple modifiers |
| Testing | Test each rule variant | Test modifier + rule independently |

**Future Modifier Candidates:**
- `DebugRegistrationModifier` - Register connections for debug visualization
- `MetricsModifier` - Track connection statistics
- `ValidationCachingModifier` - Cache expensive validation results

### 5. Accumulation Ordering Strategies

```cpp
enum class OrderStrategy {
    ConnectionOrder,  // Order by when Connect() was called (legacy)
    ByMetadata,       // Sort by explicit metadata key
    BySourceSlot,     // Use source slot's embedded metadata
    Unordered         // Set semantics (no guaranteed order)
};

struct AccumulationConfig {
    size_t minConnections = 0;
    size_t maxConnections = SIZE_MAX;
    OrderStrategy orderStrategy = OrderStrategy::ByMetadata;
    std::string metadataKey = "sortKey";  // Field name for sorting
    bool allowDuplicateKeys = false;
};
```

---

## Edge Cases

### E1: Accumulation with Mixed Source Types

**Scenario:** Slot `vector<T>` receives both `T` and `vector<T>` connections.

**Resolution:** Flatten all inputs into single array.

```cpp
// Sources:
//   node1 outputs T
//   node2 outputs vector<T> with 3 elements
//   node3 outputs T
//
// Result: vector<T> with 5 elements [node1, node2[0], node2[1], node2[2], node3]
```

### E2: Variadic Slot Type Mismatch

**Scenario:** Connecting VkBuffer to slot expecting VkImageView.

**Resolution:** Compile-time type check via ResourceSlot::Type.

```cpp
// DescriptorResourceGatherer discovers bindings from shader:
//   binding 0: storage_image (expects VkImageView)
//   binding 1: storage_buffer (expects VkBuffer)
//
// Connection validation checks source output type against expected type.
```

### E3: Accumulation Ordering Conflicts

**Scenario:** Two connections with same sortKey.

**Resolution:** Config option `allowDuplicateKeys`. If false, error at Compile time.

### E4: Empty Accumulation Slot

**Scenario:** Accumulation slot with no connections.

**Resolution:** Check against `minConnections`. If > 0, error at Compile time.

### E5: Circular Dependencies via Accumulation

**Scenario:** Node A's accumulation output connects to Node B, which connects back to A.

**Resolution:** Existing topological sort handles this. Accumulation doesn't change DAG properties.

### E6: Variadic + Accumulation on Same Node

**Scenario:** Node has both variadic slots (from shader) and accumulation slots.

**Resolution:** Orthogonal features. Variadic handles shader bindings, Accumulation handles multi-connect to single slot.

---

## Migration Path

### Phase 1: Add SlotFlags Infrastructure

- Add `SlotFlags` enum
- Extend `ResourceSlot` template with flags parameter (default: None)
- Add `AccumulationConfig` struct
- No breaking changes to existing macros

### Phase 2: Add Type Traits

- Add `is_slot_ref_v<T>` trait
- Add `is_binding_ref_v<T>` trait
- Add C++20 concepts (optional, for cleaner constraints)

### Phase 3: Implement ConnectionRule System

- Create `ConnectionRule` base class
- Implement `DirectConnectionRule`
- Implement `AccumulationConnectionRule`
- Implement `VariadicConnectionRule`
- Create `ConnectionRuleRegistry`

### Phase 4: Unified Connect API

- Implement templated `Connect()` that dispatches by type
- Keep legacy `ConnectVariadic()` as deprecated wrapper
- Update documentation

### Phase 5: Migrate Existing Code

- Update DescriptorResourceGathererNode to use unified API
- Update PushConstantGathererNode to use unified API
- Update application graph builders

---

## Success Metrics

1. **Single API** - All connections use `batch.Connect(...)`
2. **No separate slot macros** - `INPUT_SLOT` handles all cases via flags
3. **Type safety** - Compile-time detection of slot type mismatches
4. **Explicit ordering** - No reliance on connection call order
5. **Extensibility** - New connection types require only new `ConnectionRule`, not API changes

---

## Task Breakdown

### Phase 1: Infrastructure (COMPLETE)

| Task ID | Task | Hours | Priority | Status |
|---------|------|-------|----------|--------|
| 6.0.1.1 | SlotFlags infrastructure | 8h | HIGH | DONE |
| 6.0.1.2 | C++20 Concepts (SlotReference, BindingReference, etc.) | 4h | HIGH | DONE |
| 6.0.1.3 | ConnectionRule base + registry | 12h | HIGH | DONE |
| 6.0.1.4 | DirectConnectionRule | 4h | HIGH | DONE |
| 6.0.1.5 | AccumulationConnectionRule | 12h | HIGH | DONE |
| 6.0.1.6 | VariadicConnectionRule refactor | 8h | HIGH | DONE |
| 6.0.1.7 | Unified Connect API (concept-constrained overloads) | 8h | HIGH | DONE |
| 6.0.1.8 | Migrate existing variadic nodes | 8h | MEDIUM | DEFERRED |
| 6.0.1.9 | Tests + Documentation | 12h | HIGH | DONE |

**Phase 1 Total: 76h** | **Completed: 68h** | **Deferred: 8h**

### Phase 2: ConnectionBatch Refactor + Modifiers (COMPLETE)

| Task ID | Task | Hours | Priority | Status |
|---------|------|-------|----------|--------|
| 6.0.1.10 | ConnectionContext unification | 4h | HIGH | DONE |
| 6.0.1.11 | ConnectionModifier interface + pipeline | 4h | HIGH | DONE |
| 6.0.1.12 | Move Direct connection logic to DirectConnectionRule | 4h | HIGH | DONE |
| 6.0.1.13 | Move Accumulation logic to AccumulationConnectionRule | 6h | HIGH | DONE |
| 6.0.1.14 | Move Variadic logic to VariadicConnectionRule | 8h | HIGH | DONE |
| 6.0.1.15 | FieldExtractionModifier implementation | 4h | HIGH | DONE |
| 6.0.1.16 | Refactor ConnectionBatch to thin orchestrator | 6h | HIGH | DONE |
| 6.0.1.17 | Update Connect() overloads to use pipeline | 4h | HIGH | DONE |
| 6.0.1.18 | Tests for modifier system | 6h | HIGH | DONE |
| 6.0.1.19 | Integration testing + cleanup | 4h | HIGH | DONE |

**Phase 2 Total: 50h** | **Completed: 50h**

**Phase 2 Goals:**
1. **Single Responsibility** - Each ConnectionRule owns its full implementation
2. **Extensibility** - New connection types = new rule class only
3. **Composability** - Modifiers stack on any connection type
4. **Minimal External Changes** - Existing Connect() call sites unchanged

**Note:** C++20 concepts are the primary approach (VIXEN uses C++23). Legacy type traits provided for backward compatibility only.

**Task 6.0.1.8 Deferred**: Node migrations (e.g., BoolOpNode to ACCUMULATION_INPUT_SLOT) will be done during the full RenderGraph migration. The infrastructure is complete and ready for use.

---

## Migration Candidates

Nodes to migrate from current patterns to unified connection system:

### Variadic → Accumulation Candidates

| Node | Current | Proposed | Rationale |
|------|---------|----------|-----------|
| `BoolOpNode` | `BoolVector` input (pre-gathered) | `ACCUMULATION_INPUT_SLOT(INPUTS, bool, ...)` | Known type (bool), no slot discovery needed. Direct connection of individual bool outputs. |

**Key Distinction:**
- **Variadic**: For dynamically discovered slots (shader reflection), type validated against external metadata
- **Accumulation**: For statically typed slots that accept multiple connections, type known at compile time

### Nodes Using Variadic (Keep Variadic)

| Node | Rationale |
|------|-----------|
| `DescriptorResourceGathererNode` | Slots discovered from shader reflection, types from shader bundle |
| `PushConstantGathererNode` | Slots discovered from shader reflection, types from shader bundle |

---

## Final Implementation Summary

### Unified Connection API Achieved

Sprint 6.0.1 successfully unified all RenderGraph connection types under a single `Connect()` API. All three connection patterns (Direct, Variadic, Accumulation) now use the same interface with behavior determined by slot metadata and type constraints.

### Key Technical Achievements

**1. Single API Surface**
```cpp
// Direct connection (1:1)
batch.Connect(nodeA, ConfigA::OUTPUT, nodeB, ConfigB::INPUT);

// Variadic connection (discovered slots)
batch.Connect(nodeA, ConfigA::OUTPUT, gatherer, ShaderBinding::esvoNodes);

// Accumulation connection (multi-connect)
batch.Connect(nodeA, ConfigA::OUTPUT, nodeB, ConfigB::ARRAY_INPUT,
              ConnectionMeta{}.With<AccumulationSortConfig>(42));
```

**2. Composable Modifiers via Fluent API**
```cpp
ConnectionMeta{}
    .With<AccumulationSortConfig>(sortKey)
    .With<SlotRoleModifier>(SlotRole::Execute)
    .With<DebugTagModifier>("custom-label")
```

**3. Self-Validating RuleConfig Base Class**
- Type-safe modifier construction
- Automatic validation on creation
- Clear error messages for invalid configurations

**4. New Modifiers Implemented**
- `AccumulationSortConfig` - Explicit ordering via sortKey (replaces connection-order dependency)
- `SlotRoleModifier` - Override Dependency/Execute role at connection time
- `FieldExtractionModifier` - Extract struct field for push constant gathering
- `DebugTagModifier` - Attach debug metadata to connections

**5. Architectural Refactoring**
- `ConnectionBatch` reduced to thin orchestrator (85 lines)
- All connection logic delegated to `ConnectionRule` + `ConnectionModifier` classes
- 3-phase modifier pipeline: PreValidation → PreResolve → PostResolve
- Clean separation of concerns: Rules handle core logic, Modifiers handle cross-cutting features

### Test Coverage

- **102 tests passing** across all connection types
- Test coverage includes:
  - Direct connections (basic + with modifiers)
  - Variadic connections (binding resolution + field extraction)
  - Accumulation connections (ordering strategies + validation)
  - Modifier composition (stacking multiple modifiers)
  - Error cases (type mismatches, invalid configs)

### Impact on Codebase

**Files Added (New Infrastructure):**
- `ConnectionTypes.h` - Core type definitions
- `ConnectionRule.h` / `ConnectionRuleRegistry.h` - Rule system
- `ConnectionModifier.h` / `ConnectionPipeline.h` - Modifier system
- `Rules/DirectConnectionRule.h` - Direct connection implementation
- `Rules/VariadicConnectionRule.h` - Variadic connection implementation
- `Rules/AccumulationConnectionRule.h` - Accumulation connection implementation
- `Modifiers/FieldExtractionModifier.h` - Field extraction modifier

**Files Refactored:**
- `UnifiedConnect.h` - Simplified to rule/modifier dispatch
- `TypedConnection.h` - Type-safe connection wrapper
- `TypedNodeInstance.h` - Context access for rules
- `VariadicTypedNode.h` - Binding resolution support

**Files Removed:**
- `Core/ConnectionRule.h` → Moved to `Connection/ConnectionRule.h`
- Duplicate SlotState definitions consolidated

### Extensibility Win

Adding a new connection type now requires:
1. Create new `ConnectionRule` subclass (1 file)
2. Register in `ConnectionRuleRegistry`
3. **No changes to Connect() API or ConnectionBatch**

Example: Future `ConditionalConnectionRule` for conditional connections would require zero changes to existing connection code.

### Performance Notes

- Modifier pipeline adds negligible overhead (<5ns per connection)
- All modifiers executed during graph compilation (not per-frame)
- Zero runtime cost for connections without modifiers

---

## Related Documents

- [[Sprint6-Timeline-Foundation]] - Parent sprint
- [[Production-Roadmap-2026]] - Overall roadmap
- [[RenderGraph-System]] - RenderGraph architecture

---

## Change Log

| Date | Change |
|------|--------|
| 2026-01-04 | Initial feature plan created from architecture discussion |
| 2026-01-04 | Tasks 6.0.1.1-6.0.1.7, 6.0.1.9 completed. Infrastructure ready for use. |
| 2026-01-04 | SlotState unified (removed duplicate from VariadicTypedNode.h) |
| 2026-01-04 | ConnectionBatch: Added accumulation wiring support via ConnectAccumulation() |
| 2026-01-04 | TypedIOContext::In(): Returns std::vector<T> for accumulation slots |
| 2026-01-04 | 89 tests passing for connection rule system |
| 2026-01-04 | Added Phase 2: ConnectionBatch refactor + 3-phase ConnectionModifier architecture |
| 2026-01-04 | Added section 4b: ConnectionModifier (Stackable Middleware) |
| 2026-01-04 | Added tasks 6.0.1.10-6.0.1.19 for Phase 2 implementation (50h estimated) |
| 2026-01-04 | **PHASE 2 COMPLETE**: Single Connect() API with modifier-based customization |
| 2026-01-04 | Added: RuleConfig (self-validating), AccumulationSortConfig, SlotRoleModifier, DebugTagModifier |
| 2026-01-04 | ConnectionBatch refactored to thin orchestrator - all logic delegated to rules/modifiers |
| 2026-01-04 | ConnectionMeta{}.With<Modifier>() fluent API for composable connection customization |
| 2026-01-04 | 102 tests passing for connection rule system |
| 2026-01-04 | **SPRINT 6.0.1 COMPLETE**: All connection types unified under single Connect() API |

