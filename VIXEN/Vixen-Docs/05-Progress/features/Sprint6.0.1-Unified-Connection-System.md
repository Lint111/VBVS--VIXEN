---
title: "Sprint 6.0.1: Unified Connection System"
status: PLANNING
priority: HIGH
prerequisite_for: Sprint 6 Phase 1 (MultiDispatchNode)
created: 2026-01-04
tags: [architecture, rendergraph, connection-system, sprint-6]
---

# Sprint 6.0.1: Unified Connection System

## Executive Summary

Architectural overhaul of RenderGraph's connection system to provide a single, consistent API for all connection types. This is a **prerequisite** for MultiDispatchNode (Sprint 6 Phase 1) which requires Accumulation connections.

## Problem Statement

### Current State: Multiple Connection APIs

```cpp
// 1. Direct connection
batch.Connect(nodeA, ConfigA::OUTPUT, nodeB, ConfigB::INPUT);

// 2. Variadic connection (separate API)
batch.ConnectVariadic(nodeA, ConfigA::OUTPUT, gatherer, binding, slotRole);

// 3. Proposed Accumulation (would be ANOTHER API)
batch.ConnectAccumulate(nodeA, ConfigA::OUTPUT, nodeB, ConfigB::ARRAY_INPUT);
```

### Issues

1. **Multiple APIs** - User must know which to call based on target node type
2. **Implicit semantics** - Connection behavior depends on API choice, not slot metadata
3. **Slot macro proliferation** - `INPUT_SLOT`, `VARIADIC_SLOT`, `ACCUMULATION_SLOT`...
4. **Variadic index ambiguity** - Integer `0` could mean static slot 0 or variadic binding 0
5. **Implicit ordering** - Variadic uses connection order for array ordering (fragile)

## Proposed Solution: Unified Connection System

### Core Principle

> **One `Connect()` API. Slot metadata determines behavior. Type system encodes intent.**

### Design Goals

1. **Single API** - `batch.Connect(src, srcSlot, tgt, tgtSlot, metadata?)`
2. **Slot-level configuration** - Behavior defined in slot definition, not at call site
3. **Type-based disambiguation** - `SlotRef` vs `BindingRef` resolved at compile time
4. **Explicit ordering** - Metadata carries sort keys, not connection order
5. **Extensible** - New connection types via `ConnectionRule` classes, not new APIs

---

## Architecture

### 1. Slot Flags (Single Macro)

```cpp
// Same INPUT_SLOT macro, new flags field
INPUT_SLOT(DISPATCH_PASSES, std::vector<DispatchPass>, 0,
    SlotNullability::Required,
    SlotRole::Dependency,
    SlotMutability::ReadOnly,
    SlotScope::NodeLevel,
    SlotFlags::Accumulation | SlotFlags::MultiConnect,  // NEW
    AccumulationConfig{.minConnections = 1, .maxConnections = 64,
                       .orderStrategy = OrderStrategy::ByMetadata});

enum class SlotFlags : uint32_t {
    None           = 0,
    Accumulation   = 1 << 0,  // Accepts T → vector<T>, flattens vector<T>
    MultiConnect   = 1 << 1,  // Allows multiple sources to same slot
    ExplicitOrder  = 1 << 2,  // Requires ordering metadata
};
```

### 2. C++20 Concepts for Type-Based Resolution

VIXEN uses C++23, so we leverage concepts for clean constraints and helpful error messages.

```cpp
// ============================================================================
// CORE CONCEPTS
// ============================================================================

/**
 * @brief Concept for static slot references from node configs
 *
 * Satisfied by types generated by INPUT_SLOT/OUTPUT_SLOT macros.
 * These have compile-time metadata: index, role, nullability, etc.
 */
template<typename T>
concept SlotReference = requires {
    typename T::Type;                                      // Slot data type
    { T::index } -> std::convertible_to<uint32_t>;         // Slot index
    { T::role } -> std::convertible_to<SlotRole>;          // Dependency/Execute
    { T::nullability } -> std::convertible_to<SlotNullability>;
    { T::mutability } -> std::convertible_to<SlotMutability>;
    { T::scope } -> std::convertible_to<SlotScope>;
};

/**
 * @brief Concept for binding references from shader metadata
 *
 * Satisfied by BindingRef types from shader SDI (e.g., VoxelRayMarch::esvoNodes).
 * These map to descriptor set bindings discovered at runtime.
 */
template<typename T>
concept BindingReference = requires(T t) {
    { t.binding } -> std::convertible_to<uint32_t>;        // Shader binding index
    { t.descriptorType } -> std::convertible_to<VkDescriptorType>;
};

/**
 * @brief Concept for accumulation-enabled slots
 *
 * Extends SlotReference with accumulation flag requirement.
 * Used for slots that accept multiple connections merged into vector<T>.
 */
template<typename T>
concept AccumulationSlot = SlotReference<T> && requires {
    { (T::flags & SlotFlags::Accumulation) != SlotFlags::None }
        -> std::convertible_to<bool>;
};

/**
 * @brief Concept for connection metadata
 *
 * Optional metadata passed to Connect() for ordering, role hints, etc.
 */
template<typename T>
concept ConnectionMetadata = requires(T t) {
    { t.sortKey } -> std::convertible_to<int32_t>;         // Ordering key
} || std::is_same_v<T, SlotRole>;  // Or just a SlotRole

// ============================================================================
// LEGACY TYPE TRAITS (for backward compatibility)
// ============================================================================

template<typename T>
struct is_slot_ref : std::bool_constant<SlotReference<T>> {};

template<typename T>
inline constexpr bool is_slot_ref_v = SlotReference<T>;

template<typename T>
struct is_binding_ref : std::bool_constant<BindingReference<T>> {};

template<typename T>
inline constexpr bool is_binding_ref_v = BindingReference<T>;
```

**Benefits of Concepts:**

| Aspect | Type Traits | Concepts |
|--------|-------------|----------|
| Error messages | "no matching function" | "T does not satisfy SlotReference" |
| Syntax | `enable_if_t<is_slot_ref_v<T>>` | `SlotReference T` |
| Composition | Manual nesting | `AccumulationSlot = SlotReference && ...` |
| Documentation | Separate from code | Self-documenting constraints |

### 3. Unified Connect API (Concept-Constrained)

```cpp
// ============================================================================
// OVERLOAD SET - Concepts enable clean overload resolution
// ============================================================================

/**
 * @brief Direct connection: SlotRef → SlotRef
 *
 * Standard 1:1 connection between static slots.
 */
template<SlotReference Src, SlotReference Tgt>
void Connect(NodeHandle src, Src srcSlot,
             NodeHandle tgt, Tgt tgtSlot) {
    // Check for accumulation flag at compile time
    if constexpr (AccumulationSlot<Tgt>) {
        ConnectAccumulationImpl(src, srcSlot, tgt, tgtSlot, {});
    } else {
        ConnectDirectImpl(src, srcSlot, tgt, tgtSlot);
    }
}

/**
 * @brief Accumulation connection with metadata: SlotRef → AccumulationSlot
 *
 * Connects source to accumulation slot with ordering metadata.
 */
template<SlotReference Src, AccumulationSlot Tgt, ConnectionMetadata Meta>
void Connect(NodeHandle src, Src srcSlot,
             NodeHandle tgt, Tgt tgtSlot,
             Meta metadata) {
    ConnectAccumulationImpl(src, srcSlot, tgt, tgtSlot, metadata);
}

/**
 * @brief Variadic connection: SlotRef → BindingRef
 *
 * Connects source to variadic node's shader binding.
 */
template<SlotReference Src, BindingReference Tgt>
void Connect(NodeHandle src, Src srcSlot,
             NodeHandle tgt, Tgt tgtSlot,
             SlotRole role = SlotRole::Dependency) {
    ConnectVariadicImpl(src, srcSlot, tgt, tgtSlot, role);
}

/**
 * @brief Variadic with field extraction: SlotRef → BindingRef + member pointer
 *
 * Extracts field from source struct for push constant gathering.
 */
template<SlotReference Src, BindingReference Tgt, typename T, typename Field>
void Connect(NodeHandle src, Src srcSlot,
             NodeHandle tgt, Tgt tgtSlot,
             Field T::* memberPtr,
             SlotRole role = SlotRole::Execute) {
    ConnectVariadicWithExtractionImpl(src, srcSlot, tgt, tgtSlot, memberPtr, role);
}

// ============================================================================
// ERROR HANDLING - Concepts provide clear diagnostics
// ============================================================================

// Attempting to connect incompatible types produces clear errors:
//
// Connect(node1, Config::OUTPUT, node2, 42);
// Error: no matching function for call to 'Connect'
//        note: candidate template ignored: constraints not satisfied
//        note: because 'int' does not satisfy 'SlotReference'
//        note: because 'int::Type' would be invalid
```

### 4. ConnectionRule Base Class (Extensibility)

```cpp
class ConnectionRule {
public:
    virtual ~ConnectionRule() = default;

    // Check if this rule can handle the connection
    virtual bool CanHandle(const SlotDescriptor& source,
                          const SlotDescriptor& target) const = 0;

    // Validate the connection
    virtual bool Validate(const ConnectionContext& ctx,
                         std::string& errorMsg) const = 0;

    // Resolve the connection (called during Compile/Execute)
    virtual void Resolve(ConnectionContext& ctx) const = 0;

    // Priority for rule matching (higher = checked first)
    virtual uint32_t Priority() const { return 0; }
};

// Concrete rules
class DirectConnectionRule : public ConnectionRule { ... };
class AccumulationConnectionRule : public ConnectionRule { ... };
class VariadicConnectionRule : public ConnectionRule { ... };

// Graph maintains rule registry
class ConnectionRuleRegistry {
    std::vector<std::unique_ptr<ConnectionRule>> rules_;

    const ConnectionRule* FindRule(const SlotDescriptor& src,
                                   const SlotDescriptor& tgt) const;
};
```

### 5. Accumulation Ordering Strategies

```cpp
enum class OrderStrategy {
    ConnectionOrder,  // Order by when Connect() was called (legacy)
    ByMetadata,       // Sort by explicit metadata key
    BySourceSlot,     // Use source slot's embedded metadata
    Unordered         // Set semantics (no guaranteed order)
};

struct AccumulationConfig {
    size_t minConnections = 0;
    size_t maxConnections = SIZE_MAX;
    OrderStrategy orderStrategy = OrderStrategy::ByMetadata;
    std::string metadataKey = "sortKey";  // Field name for sorting
    bool allowDuplicateKeys = false;
};
```

---

## Edge Cases

### E1: Accumulation with Mixed Source Types

**Scenario:** Slot `vector<T>` receives both `T` and `vector<T>` connections.

**Resolution:** Flatten all inputs into single array.

```cpp
// Sources:
//   node1 outputs T
//   node2 outputs vector<T> with 3 elements
//   node3 outputs T
//
// Result: vector<T> with 5 elements [node1, node2[0], node2[1], node2[2], node3]
```

### E2: Variadic Slot Type Mismatch

**Scenario:** Connecting VkBuffer to slot expecting VkImageView.

**Resolution:** Compile-time type check via ResourceSlot::Type.

```cpp
// DescriptorResourceGatherer discovers bindings from shader:
//   binding 0: storage_image (expects VkImageView)
//   binding 1: storage_buffer (expects VkBuffer)
//
// Connection validation checks source output type against expected type.
```

### E3: Accumulation Ordering Conflicts

**Scenario:** Two connections with same sortKey.

**Resolution:** Config option `allowDuplicateKeys`. If false, error at Compile time.

### E4: Empty Accumulation Slot

**Scenario:** Accumulation slot with no connections.

**Resolution:** Check against `minConnections`. If > 0, error at Compile time.

### E5: Circular Dependencies via Accumulation

**Scenario:** Node A's accumulation output connects to Node B, which connects back to A.

**Resolution:** Existing topological sort handles this. Accumulation doesn't change DAG properties.

### E6: Variadic + Accumulation on Same Node

**Scenario:** Node has both variadic slots (from shader) and accumulation slots.

**Resolution:** Orthogonal features. Variadic handles shader bindings, Accumulation handles multi-connect to single slot.

---

## Migration Path

### Phase 1: Add SlotFlags Infrastructure

- Add `SlotFlags` enum
- Extend `ResourceSlot` template with flags parameter (default: None)
- Add `AccumulationConfig` struct
- No breaking changes to existing macros

### Phase 2: Add Type Traits

- Add `is_slot_ref_v<T>` trait
- Add `is_binding_ref_v<T>` trait
- Add C++20 concepts (optional, for cleaner constraints)

### Phase 3: Implement ConnectionRule System

- Create `ConnectionRule` base class
- Implement `DirectConnectionRule`
- Implement `AccumulationConnectionRule`
- Implement `VariadicConnectionRule`
- Create `ConnectionRuleRegistry`

### Phase 4: Unified Connect API

- Implement templated `Connect()` that dispatches by type
- Keep legacy `ConnectVariadic()` as deprecated wrapper
- Update documentation

### Phase 5: Migrate Existing Code

- Update DescriptorResourceGathererNode to use unified API
- Update PushConstantGathererNode to use unified API
- Update application graph builders

---

## Success Metrics

1. **Single API** - All connections use `batch.Connect(...)`
2. **No separate slot macros** - `INPUT_SLOT` handles all cases via flags
3. **Type safety** - Compile-time detection of slot type mismatches
4. **Explicit ordering** - No reliance on connection call order
5. **Extensibility** - New connection types require only new `ConnectionRule`, not API changes

---

## Task Breakdown

| Task ID | Task | Hours | Priority |
|---------|------|-------|----------|
| 6.0.1.1 | SlotFlags infrastructure | 8h | HIGH |
| 6.0.1.2 | C++20 Concepts (SlotReference, BindingReference, etc.) | 4h | HIGH |
| 6.0.1.3 | ConnectionRule base + registry | 12h | HIGH |
| 6.0.1.4 | DirectConnectionRule | 4h | HIGH |
| 6.0.1.5 | AccumulationConnectionRule | 12h | HIGH |
| 6.0.1.6 | VariadicConnectionRule refactor | 8h | HIGH |
| 6.0.1.7 | Unified Connect API (concept-constrained overloads) | 8h | HIGH |
| 6.0.1.8 | Migrate existing variadic nodes | 8h | MEDIUM |
| 6.0.1.9 | Tests + Documentation | 12h | HIGH |

**Total: 76h**

**Note:** C++20 concepts are the primary approach (VIXEN uses C++23). Legacy type traits provided for backward compatibility only.

---

## Migration Candidates

Nodes to migrate from current patterns to unified connection system:

### Variadic → Accumulation Candidates

| Node | Current | Proposed | Rationale |
|------|---------|----------|-----------|
| `BoolOpNode` | `BoolVector` input (pre-gathered) | `ACCUMULATION_INPUT_SLOT(INPUTS, bool, ...)` | Known type (bool), no slot discovery needed. Direct connection of individual bool outputs. |

**Key Distinction:**
- **Variadic**: For dynamically discovered slots (shader reflection), type validated against external metadata
- **Accumulation**: For statically typed slots that accept multiple connections, type known at compile time

### Nodes Using Variadic (Keep Variadic)

| Node | Rationale |
|------|-----------|
| `DescriptorResourceGathererNode` | Slots discovered from shader reflection, types from shader bundle |
| `PushConstantGathererNode` | Slots discovered from shader reflection, types from shader bundle |

---

## Related Documents

- [[Sprint6-Timeline-Foundation]] - Parent sprint
- [[Production-Roadmap-2026]] - Overall roadmap
- [[RenderGraph-System]] - RenderGraph architecture

---

## Change Log

| Date | Change |
|------|--------|
| 2026-01-04 | Initial feature plan created from architecture discussion |

