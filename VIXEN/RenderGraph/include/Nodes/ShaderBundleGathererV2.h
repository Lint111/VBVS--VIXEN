#pragma once

#include "../Core/ResourceVariant.h"
#include "../Core/ResourceTypeTraits.h"
#include <tuple>
#include <type_traits>

namespace Vixen::RenderGraph {

// Forward declaration
template<typename T>
class Slot;

// ============================================================================
// SHADER BUNDLE GATHERER V2 - Automatic type extraction from naming.h
// ============================================================================

/**
 * @brief Resource gatherer that automatically extracts types from shader bundle
 *
 * DESIGN PRINCIPLE:
 * The naming.h file (generated by SDI) IS the config. No manual declarations.
 *
 * SDI-generated naming.h should contain:
 * ```cpp
 * struct ComputeShaderResources {
 *     std::vector<VkBuffer> uniformBuffers;
 *     std::vector<VkImageView> inputImages;
 *     VkPipeline pipeline;
 *
 *     // Metadata for gatherer (auto-generated by SDI)
 *     struct _Reflection {
 *         using FieldTypes = std::tuple<
 *             std::vector<VkBuffer>,
 *             std::vector<VkImageView>,
 *             VkPipeline
 *         >;
 *         static constexpr size_t FieldCount = 3;
 *     };
 * };
 * ```
 *
 * USAGE:
 * ```cpp
 * // 1. Include naming.h (the ONLY config file)
 * #include "ShaderBundles/compute_shader_naming.h"
 *
 * // 2. Create gatherer - NO manual setup needed
 * ShaderBundleGatherer<ComputeShaderResources> gatherer;
 *
 * // 3. Connect inputs (order matches field order in naming.h)
 * gatherer.input<0>().connectFrom(uniformBuffersSlot);
 * gatherer.input<1>().connectFrom(inputImagesSlot);
 * gatherer.input<2>().connectFrom(pipelineSlot);
 *
 * // 4. Execute and get typed output
 * gatherer.execute();
 * auto& resources = gatherer.output.get();
 * ```
 *
 * BENEFITS:
 * - naming.h is self-contained (no external trait declarations)
 * - SDI controls all metadata (versioning, consistency)
 * - Include naming.h and it "just works"
 * - Zero manual configuration
 *
 * @tparam BundleType Shader bundle struct (must have nested _Reflection)
 */
template<typename BundleType>
class ShaderBundleGatherer {
private:
    // ========================================================================
    // AUTOMATIC TYPE EXTRACTION - Uses BundleType::_Reflection
    // ========================================================================

    /**
     * @brief Detect if type has _Reflection nested struct
     */
    template<typename T, typename = void>
    struct HasReflection : std::false_type {};

    template<typename T>
    struct HasReflection<T, std::void_t<typename T::_Reflection>> : std::true_type {};

    // Extract reflection metadata
    static_assert(HasReflection<BundleType>::value,
        "BundleType must have nested _Reflection struct. "
        "This should be auto-generated by SDI in the naming.h file.");

    using Reflection = typename BundleType::_Reflection;
    using FieldTypes = typename Reflection::FieldTypes;
    static constexpr size_t FieldCount = Reflection::FieldCount;

    // Validate field count matches tuple size
    static_assert(FieldCount == std::tuple_size_v<FieldTypes>,
        "FieldCount must match FieldTypes tuple size");

    // Validate all field types are registered
    template<typename... Types>
    static constexpr bool AllTypesValid(std::tuple<Types...>) {
        return (ResourceTypeTraits<Types>::isValid && ...);
    }

    static_assert(AllTypesValid(FieldTypes{}),
        "All bundle field types must be registered in RESOURCE_TYPE_REGISTRY. "
        "Check the naming.h file generated by SDI.");

    // ========================================================================
    // HELPER - Convert tuple of types to tuple of Slot<Types>
    // ========================================================================

    template<typename Tuple>
    struct InputSlotsFromTuple;

    template<typename... Types>
    struct InputSlotsFromTuple<std::tuple<Types...>> {
        using type = std::tuple<Slot<Types>...>;
    };

public:
    // ========================================================================
    // INPUT SLOTS - Auto-generated from naming.h
    // ========================================================================

    /**
     * @brief Tuple of typed input slots matching bundle fields
     *
     * Generated automatically from BundleType::_Reflection::FieldTypes
     */
    using InputSlots = typename InputSlotsFromTuple<FieldTypes>::type;
    InputSlots inputs;

    /**
     * @brief Access input slot by index
     * @tparam Index Field index (0-based, matches naming.h field order)
     */
    template<size_t Index>
    auto& input() {
        static_assert(Index < FieldCount, "Input index out of range");
        return std::get<Index>(inputs);
    }

    // ========================================================================
    // OUTPUT SLOT - Assembled bundle
    // ========================================================================

    /**
     * @brief Output slot containing assembled bundle
     */
    Slot<BundleType> output;

    // ========================================================================
    // EXECUTION - Assemble bundle from inputs
    // ========================================================================

    /**
     * @brief Gather inputs and assemble bundle
     */
    void execute() {
        BundleType bundle;
        assembleBundleFields(bundle, std::make_index_sequence<FieldCount>{});
        output.set(std::move(bundle));
    }

private:
    // ========================================================================
    // HELPERS - Field assembly using structured bindings
    // ========================================================================

    template<size_t... Indices>
    void assembleBundleFields(BundleType& bundle, std::index_sequence<Indices...>) {
        (assignField<Indices>(bundle), ...);
    }

    template<size_t Index>
    void assignField(BundleType& bundle) {
        using FieldType = std::tuple_element_t<Index, FieldTypes>;
        const FieldType& value = std::get<Index>(inputs).get();
        assignFieldAtIndex<Index>(bundle, value);
    }

    template<size_t Index, typename FieldType>
    void assignFieldAtIndex(BundleType& bundle, const FieldType& value) {
        auto refs = bundleToTuple(bundle);
        std::get<Index>(refs) = value;
    }

    /**
     * @brief Convert bundle to tuple of field references
     *
     * Uses structured bindings to decompose the aggregate.
     * Supports up to 8 fields (extend if needed).
     */
    auto bundleToTuple(BundleType& bundle) {
        if constexpr (FieldCount == 1) {
            auto& [f0] = bundle;
            return std::tie(f0);
        }
        else if constexpr (FieldCount == 2) {
            auto& [f0, f1] = bundle;
            return std::tie(f0, f1);
        }
        else if constexpr (FieldCount == 3) {
            auto& [f0, f1, f2] = bundle;
            return std::tie(f0, f1, f2);
        }
        else if constexpr (FieldCount == 4) {
            auto& [f0, f1, f2, f3] = bundle;
            return std::tie(f0, f1, f2, f3);
        }
        else if constexpr (FieldCount == 5) {
            auto& [f0, f1, f2, f3, f4] = bundle;
            return std::tie(f0, f1, f2, f3, f4);
        }
        else if constexpr (FieldCount == 6) {
            auto& [f0, f1, f2, f3, f4, f5] = bundle;
            return std::tie(f0, f1, f2, f3, f4, f5);
        }
        else if constexpr (FieldCount == 7) {
            auto& [f0, f1, f2, f3, f4, f5, f6] = bundle;
            return std::tie(f0, f1, f2, f3, f4, f5, f6);
        }
        else if constexpr (FieldCount == 8) {
            auto& [f0, f1, f2, f3, f4, f5, f6, f7] = bundle;
            return std::tie(f0, f1, f2, f3, f4, f5, f6, f7);
        }
        else if constexpr (FieldCount == 9) {
            auto& [f0, f1, f2, f3, f4, f5, f6, f7, f8] = bundle;
            return std::tie(f0, f1, f2, f3, f4, f5, f6, f7, f8);
        }
        else if constexpr (FieldCount == 10) {
            auto& [f0, f1, f2, f3, f4, f5, f6, f7, f8, f9] = bundle;
            return std::tie(f0, f1, f2, f3, f4, f5, f6, f7, f8, f9);
        }
        else {
            static_assert(FieldCount <= 10,
                "ShaderBundleGatherer currently supports up to 10 fields. "
                "Extend bundleToTuple for more fields or use a different approach.");
        }
    }
};

// ============================================================================
// HELPER FOR SDI GENERATION
// ============================================================================

/**
 * @brief Macro to generate _Reflection metadata in naming.h
 *
 * SDI should generate this automatically in the naming.h file.
 *
 * Example SDI output:
 * ```cpp
 * struct ComputeShaderResources {
 *     std::vector<VkBuffer> uniformBuffers;
 *     std::vector<VkImageView> inputImages;
 *     VkPipeline pipeline;
 *
 *     SHADER_BUNDLE_REFLECTION(
 *         std::vector<VkBuffer>,
 *         std::vector<VkImageView>,
 *         VkPipeline
 *     )
 * };
 * ```
 */
#define SHADER_BUNDLE_REFLECTION(...) \
    struct _Reflection { \
        using FieldTypes = std::tuple<__VA_ARGS__>; \
        static constexpr size_t FieldCount = std::tuple_size_v<FieldTypes>; \
    }

} // namespace Vixen::RenderGraph

// ============================================================================
// DOCUMENTATION FOR SDI GENERATOR
// ============================================================================

/*

INTEGRATION GUIDE FOR SDI GENERATOR:

When generating naming.h files from shader reflection, include the _Reflection
metadata for each resource struct:

GENERATED naming.h FORMAT:
```cpp
// compute_shader_naming.h (auto-generated by SDI)
#pragma once
#include <vulkan/vulkan.h>
#include <vector>

namespace ShaderBundles {

struct ComputeShaderResources {
    // Resource fields (from shader reflection)
    std::vector<VkBuffer> uniformBuffers;        // Descriptor set 0
    std::vector<VkImageView> inputImages;        // Descriptor set 1
    std::vector<VkImageView> outputImages;       // Descriptor set 2
    VkPipeline computePipeline;                  // Pipeline object
    VkPipelineLayout pipelineLayout;             // Pipeline layout

    // Metadata for resource gatherer (auto-generated)
    struct _Reflection {
        using FieldTypes = std::tuple<
            std::vector<VkBuffer>,
            std::vector<VkImageView>,
            std::vector<VkImageView>,
            VkPipeline,
            VkPipelineLayout
        >;
        static constexpr size_t FieldCount = 5;
    };
};

} // namespace ShaderBundles
```

USAGE (no manual setup required):
```cpp
#include "ShaderBundles/compute_shader_naming.h"
#include "Nodes/ShaderBundleGatherer.h"

using namespace Vixen::RenderGraph;

// Just works - no trait declarations needed!
ShaderBundleGatherer<ShaderBundles::ComputeShaderResources> gatherer;

gatherer.input<0>().connectFrom(uniformBuffersSlot);
gatherer.input<1>().connectFrom(inputImagesSlot);
// ... etc
```

BENEFITS:
1. naming.h is self-contained (include and use)
2. SDI controls all metadata (versioning, consistency)
3. Zero manual configuration in C++ code
4. Type-safe and refactoring-safe
5. Compile-time validation

*/
